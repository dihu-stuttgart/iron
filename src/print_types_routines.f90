
!> \file
!> \author Benjamin Maier
!> \brief This module contains routines that print the composite values of each type defined in types.f90
!>
!> \section LICENSE
!>
!> Version: MPL 1.1/GPL 2.0/LGPL 2.1
!>
!> The contents of this file are subject to the Mozilla Public License
!> Version 1.1 (the "License"); you may not use this file except in
!> compliance with the License. You may obtain a copy of the License at
!> http://www.mozilla.org/MPL/
!>
!> Software distributed under the License is distributed on an "AS IS"
!> basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
!> License for the specific language governing rights and limitations
!> under the License.
!>
!> The Original Code is OpenCMISS
!>
!> The Initial Developer of the Original Code is University of Auckland,
!> Auckland, New Zealand, the University of Oxford, Oxford, United
!> Kingdom and King's College, London, United Kingdom. Portions created
!> by the University of Auckland, the University of Oxford and King's
!> College, London are Copyright (C) 2007-2010 by the University of
!> Auckland, the University of Oxford and King's College, London.
!> All Rights Reserved.
!>
!> Contributor(s):
!>
!> Alternatively, the contents of this file may be used under the terms of
!> either the GNU General Public License Version 2 or later (the "GPL"), or
!> the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
!> in which case the provisions of the GPL or the LGPL are applicable instead
!> of those above. If you wish to allow use of your version of this file only
!> under the terms of either the GPL or the LGPL, and not to allow others to
!> use your version of this file under the terms of the MPL, indicate your
!> decision by deleting the provisions above and replace them with the notice
!> and other provisions required by the GPL or the LGPL. If you do not delete
!> the provisions above, a recipient may use your version of this file under
!> the terms of any one of the MPL, the GPL or the LGPL.
!>
!> This module contains a print routine for each type in types.f90
!> The routines were created automatically at 2017-03-16 19:03:37.

MODULE PRINT_TYPES_ROUTINES
  USE TYPES
  
  IMPLICIT NONE
  
CONTAINS

FUNCTION GetPrintIndent(Depth)
  INTEGER(INTG), INTENT(IN) :: Depth
  CHARACTER(LEN=400) :: GetPrintIndent
  INTEGER(INTG) :: I
  
  WRITE(GetPrintIndent, "(I3)") Depth
  GetPrintIndent = TRIM(GetPrintIndent) // "|"
  DO I = 1, Depth
    GetPrintIndent = TRIM(GetPrintIndent) // " ."
  END DO

END FUNCTION GetPrintIndent


!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DECOMPOSITION_ADJACENT_ELEMENT_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DECOMPOSITION_ADJACENT_ELEMENT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(DECOMPOSITION_ADJACENT_ELEMENT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ADJACENT_ELEMENTS:     ", &
    & Variable%NUMBER_OF_ADJACENT_ELEMENTS
  
  ! Variable%ADJACENT_ELEMENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ADJACENT_ELEMENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ADJACENT_ELEMENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ADJACENT_ELEMENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ADJACENT_ELEMENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ADJACENT_ELEMENTS,1), MIN(LBOUND(Variable%ADJACENT_ELEMENTS,1)+MaxArrayLength, UBOUND(Variable% &
      & ADJACENT_ELEMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ADJACENT_ELEMENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ADJACENT_ELEMENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DECOMPOSITION_ADJACENT_ELEMENT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_VARIABLE_TO_SOLVER_COL_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(VARIABLE_TO_SOLVER_COL_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(VARIABLE_TO_SOLVER_COL_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%COLUMN_NUMBERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COLUMN_NUMBERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COLUMN_NUMBERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLUMN_NUMBERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COLUMN_NUMBERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COLUMN_NUMBERS,1), MIN(LBOUND(Variable%COLUMN_NUMBERS,1)+MaxArrayLength, UBOUND(Variable% &
      & COLUMN_NUMBERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COLUMN_NUMBERS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLUMN_NUMBERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COUPLING_COEFFICIENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COUPLING_COEFFICIENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COUPLING_COEFFICIENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COUPLING_COEFFICIENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COUPLING_COEFFICIENTS,1), MIN(LBOUND(Variable% &
      & COUPLING_COEFFICIENTS,1)+MaxArrayLength, UBOUND(Variable%COUPLING_COEFFICIENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COUPLING_COEFFICIENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ADDITIVE_CONSTANTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ADDITIVE_CONSTANTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ADDITIVE_CONSTANTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "ADDITIVE_CONSTANTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ADDITIVE_CONSTANTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ADDITIVE_CONSTANTS,1), MIN(LBOUND(Variable% &
      & ADDITIVE_CONSTANTS,1)+MaxArrayLength, UBOUND(Variable%ADDITIVE_CONSTANTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ADDITIVE_CONSTANTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "ADDITIVE_CONSTANTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_VARIABLE_TO_SOLVER_COL_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_MESH_CONNECTIVITY_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
  & CheckVariable24, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable24

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr4
  TYPE(MeshComponentTopologyType), POINTER :: NullPtr5
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: NullPtr6
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: NullPtr7
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr8
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr9
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr11
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: NullPtr12
  TYPE(BASIS_TYPE), POINTER :: NullPtr13
  TYPE(BASIS_PTR_TYPE), POINTER :: NullPtr14

  TYPE(INTERFACE_TYPE), POINTER :: Ptr0
  TYPE(MESH_TYPE), POINTER :: Ptr1

  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable10)) THEN
    Variable2 => CheckVariable10
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)

  
  ! Variable%INTERFACE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_MESH_CONNECTIVITY_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_PTR_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), CELLML_ENVIRONMENTS_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), MeshComponentTopologyPtrType (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), INTERFACES_TYPE (CheckVariable19), DATA_POINTS_TYPE (CheckVariable20), GENERATED_MESH_PTR_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), DECOMPOSITION_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable24

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE
    IF (ASSOCIATED(Ptr0, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE"
      CALL Print_INTERFACE_TYPE(Variable% &
        & INTERFACE, NullPtr0, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, &
        & CheckVariable5, CheckVariable6, CheckVariable7, NullPtr1, CheckVariable8, CheckVariable9, Variable2, &
        & CheckVariable11, NullPtr2, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
        & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, NullPtr3, &
        & CheckVariable23, NullPtr4, CheckVariable24, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE_MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_TYPE), POINTER :: " // &
      & "INTERFACE_MESH " // &
      & "(associated): " 
  
! Signature of Print_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, REGION_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_MESH_CONNECTIVITY_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_PTR_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), CELLML_ENVIRONMENTS_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), MeshComponentTopologyPtrType (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), INTERFACES_TYPE (CheckVariable19), DATA_POINTS_TYPE (CheckVariable20), GENERATED_MESH_PTR_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), DECOMPOSITION_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_CYLINDER_TYPE
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_ELLIPSOID_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable14
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable13
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_REGULAR_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable24

    ! if variable was already followed
    Ptr1 => Variable%INTERFACE_MESH
    IF (ASSOCIATED(Ptr1, CheckVariable13)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_MESH"
      CALL Print_MESH_TYPE(Variable% &
        & INTERFACE_MESH, NullPtr5, CheckVariable0, NullPtr6, CheckVariable1, CheckVariable2, NullPtr7, NullPtr8, &
        & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable14, CheckVariable7, CheckVariable8, NullPtr9, &
        & CheckVariable9, CheckVariable6, Variable2, CheckVariable11, CheckVariable13, NullPtr10, CheckVariable15, &
        & CheckVariable16, CheckVariable17, CheckVariable18, NullPtr11, CheckVariable19, CheckVariable20, CheckVariable21, &
        & CheckVariable22, NullPtr12, CheckVariable23, CheckVariable24, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_TYPE), POINTER :: " // &
      & "INTERFACE_MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%BASIS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%BASIS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_TYPE), POINTER :: " // &
      & "BASIS " // &
      & "(associated): " 
  
! Signature of Print_BASIS_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: INTERFACE_MESH_CONNECTIVITY_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_PTR_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), CELLML_ENVIRONMENTS_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), MeshComponentTopologyPtrType (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), INTERFACES_TYPE (CheckVariable19), DATA_POINTS_TYPE (CheckVariable20), GENERATED_MESH_PTR_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), DECOMPOSITION_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type BASIS_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_TYPE
! - signature type BASIS_PTR_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_PTR_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BASIS"
      CALL Print_BASIS_TYPE(Variable%BASIS, NullPtr13, NullPtr14, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_TYPE), POINTER :: " // &
      & "BASIS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "MESH_CONNECTIVITY_FINISHED:                      ", &
    & Variable%MESH_CONNECTIVITY_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_INTERFACE_ELEMENTS:    ", &
    & Variable%NUMBER_OF_INTERFACE_ELEMENTS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COUPLED_MESHES:        ", &
    & Variable%NUMBER_OF_COUPLED_MESHES
  
  ! Variable%ELEMENT_CONNECTIVITY(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_CONNECTIVITY)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_CONNECTIVITY),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_ELEMENT_CONNECTIVITY_TYPE), ALLOCATABLE :: " // &
      & "ELEMENT_CONNECTIVITY(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_CONNECTIVITY, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%ELEMENT_CONNECTIVITY,1), MIN(LBOUND(Variable% &
      & ELEMENT_CONNECTIVITY,1)+MaxArrayLength, UBOUND(Variable%ELEMENT_CONNECTIVITY,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%ELEMENT_CONNECTIVITY,2), MIN(LBOUND(Variable% &
        & ELEMENT_CONNECTIVITY,2)+MaxArrayLength, UBOUND(Variable%ELEMENT_CONNECTIVITY,2))
        WRITE(I1_STR,"(I4)") I1 

! Signature of Print_INTERFACE_ELEMENT_CONNECTIVITY_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_MESH_CONNECTIVITY_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_PTR_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), CELLML_ENVIRONMENTS_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), MeshComponentTopologyPtrType (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), INTERFACES_TYPE (CheckVariable19), DATA_POINTS_TYPE (CheckVariable20), GENERATED_MESH_PTR_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), DECOMPOSITION_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
          PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ELEMENT_CONNECTIVITY("//TRIM(ADJUSTL(I0_STR))//"," // &
            & ""//TRIM(ADJUSTL(I1_STR))//")"
          CALL Print_INTERFACE_ELEMENT_CONNECTIVITY_TYPE(Variable%ELEMENT_CONNECTIVITY(I0,I1), Depth+1, MaxDepth, MaxArrayLength)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_ELEMENT_CONNECTIVITY_TYPE), ALLOCATABLE :: " // &
      & "ELEMENT_CONNECTIVITY(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_INTERFACE_MESH_CONNECTIVITY_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MeshComponentTopologyType(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, Depth, MaxDepth, MaxArrayLength)
  TYPE(MeshComponentTopologyType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MeshDataPointsType), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(MeshNodesType), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(MeshElementsType), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(MeshComponentTopologyType), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(MeshDofsType), POINTER, INTENT(IN) :: CheckVariable18

  ! iterator variables

  ! null pointers
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: NullPtr2
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr4
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr6
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr8
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr9
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr10
  TYPE(NODES_TYPE), POINTER :: NullPtr11
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr13
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr14
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr15
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: NullPtr16

  TYPE(MESH_TYPE), POINTER :: Ptr0
  TYPE(MeshNodesType), POINTER :: Ptr1
  TYPE(MeshElementsType), POINTER :: Ptr2
  TYPE(MeshDofsType), POINTER :: Ptr3
  TYPE(MeshDataPointsType), POINTER :: Ptr4

  TYPE(MeshComponentTopologyType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable13)) THEN
    Variable2 => CheckVariable13
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)

  
  ! Variable%mesh
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%mesh)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_TYPE), POINTER :: " // &
      & "mesh " // &
      & "(associated): " 
  
! Signature of Print_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, REGION_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MeshComponentTopologyType (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), MeshDataPointsType (CheckVariable2), MeshComponentTopologyPtrType (CheckVariable3), FIELD_TYPE (CheckVariable4), MESH_PTR_TYPE (CheckVariable5), FIELDS_TYPE (CheckVariable6), DECOMPOSITION_TYPE (CheckVariable7), MeshNodesType (CheckVariable8), MeshElementsType (CheckVariable9), REGION_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), GENERATED_MESH_TYPE (CheckVariable12), MeshComponentTopologyType (CheckVariable13), MESHES_TYPE (CheckVariable14), DECOMPOSITIONS_TYPE (CheckVariable15), InterfacePointsConnectivityType (CheckVariable16), INTERFACE_TYPE (CheckVariable17), MeshDofsType (CheckVariable18), 
! - signature type MeshComponentTopologyType
!   is type of this print routine, use Variable2
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_CYLINDER_TYPE
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_ELLIPSOID_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable3
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_REGULAR_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable10

    ! if variable was already followed
    Ptr0 => Variable%mesh
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"mesh"
      CALL Print_MESH_TYPE(Variable% &
        & mesh, Variable2, CheckVariable14, NullPtr0, CheckVariable5, NullPtr1, NullPtr2, NullPtr3, NullPtr4, &
        & CheckVariable12, CheckVariable4, CheckVariable3, CheckVariable16, CheckVariable17, NullPtr5, NullPtr6, NullPtr7, &
        & CheckVariable11, NullPtr8, CheckVariable1, NullPtr9, CheckVariable6, NullPtr10, CheckVariable15, NullPtr11, &
        & NullPtr12, NullPtr13, NullPtr14, NullPtr15, CheckVariable0, NullPtr16, CheckVariable7, CheckVariable10, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_TYPE), POINTER :: " // &
      & "mesh (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "meshComponentNumber:             ", &
    & Variable%meshComponentNumber
  
  ! Variable%nodes
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%nodes)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshNodesType), POINTER :: " // &
      & "nodes " // &
      & "(associated): " 
  
! Signature of Print_MeshNodesType has the following CheckVariable types: MESH_TYPE, MeshComponentTopologyType, MeshComponentTopologyPtrType, MESH_PTR_TYPE, MeshNodesType, MeshElementsType, MeshDataPointsType, DECOMPOSITIONS_TYPE, INTERFACE_TYPE, MeshDofsType, 
! The type to handle in this routine is: MeshComponentTopologyType (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), MeshDataPointsType (CheckVariable2), MeshComponentTopologyPtrType (CheckVariable3), FIELD_TYPE (CheckVariable4), MESH_PTR_TYPE (CheckVariable5), FIELDS_TYPE (CheckVariable6), DECOMPOSITION_TYPE (CheckVariable7), MeshNodesType (CheckVariable8), MeshElementsType (CheckVariable9), REGION_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), GENERATED_MESH_TYPE (CheckVariable12), MeshComponentTopologyType (CheckVariable13), MESHES_TYPE (CheckVariable14), DECOMPOSITIONS_TYPE (CheckVariable15), InterfacePointsConnectivityType (CheckVariable16), INTERFACE_TYPE (CheckVariable17), MeshDofsType (CheckVariable18), 
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MeshComponentTopologyType
!   is type of this print routine, use Variable2
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable3
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type MeshNodesType
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type MeshElementsType
!   matches available passing type, use it as CheckVariable9
! - signature type MeshDataPointsType
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type MeshDofsType
!   matches available passing type, use it as CheckVariable18

    ! if variable was already followed
    Ptr1 => Variable%nodes
    IF (ASSOCIATED(Ptr1, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"nodes"
      CALL Print_MeshNodesType(Variable% &
        & nodes, CheckVariable1, Variable2, CheckVariable3, CheckVariable5, CheckVariable8, CheckVariable9, CheckVariable2, &
        & CheckVariable15, CheckVariable17, CheckVariable18, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshNodesType), POINTER :: " // &
      & "nodes (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%elements
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%elements)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshElementsType), POINTER :: " // &
      & "elements " // &
      & "(associated): " 
  
! Signature of Print_MeshElementsType has the following CheckVariable types: MESH_TYPE, MeshComponentTopologyType, MeshComponentTopologyPtrType, MESH_PTR_TYPE, MeshNodesType, MeshElementsType, MeshDataPointsType, DECOMPOSITIONS_TYPE, INTERFACE_TYPE, MeshDofsType, 
! The type to handle in this routine is: MeshComponentTopologyType (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), MeshDataPointsType (CheckVariable2), MeshComponentTopologyPtrType (CheckVariable3), FIELD_TYPE (CheckVariable4), MESH_PTR_TYPE (CheckVariable5), FIELDS_TYPE (CheckVariable6), DECOMPOSITION_TYPE (CheckVariable7), MeshNodesType (CheckVariable8), MeshElementsType (CheckVariable9), REGION_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), GENERATED_MESH_TYPE (CheckVariable12), MeshComponentTopologyType (CheckVariable13), MESHES_TYPE (CheckVariable14), DECOMPOSITIONS_TYPE (CheckVariable15), InterfacePointsConnectivityType (CheckVariable16), INTERFACE_TYPE (CheckVariable17), MeshDofsType (CheckVariable18), 
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MeshComponentTopologyType
!   is type of this print routine, use Variable2
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable3
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type MeshNodesType
!   matches available passing type, use it as CheckVariable8
! - signature type MeshElementsType
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type MeshDataPointsType
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type MeshDofsType
!   matches available passing type, use it as CheckVariable18

    ! if variable was already followed
    Ptr2 => Variable%elements
    IF (ASSOCIATED(Ptr2, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"elements"
      CALL Print_MeshElementsType(Variable% &
        & elements, CheckVariable1, Variable2, CheckVariable3, CheckVariable5, CheckVariable8, CheckVariable9, &
        & CheckVariable2, CheckVariable15, CheckVariable17, CheckVariable18, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshElementsType), POINTER :: " // &
      & "elements (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%dofs
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%dofs)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshDofsType), POINTER :: " // &
      & "dofs " // &
      & "(associated): " 
  
! Signature of Print_MeshDofsType has the following CheckVariable types: MESH_TYPE, MeshComponentTopologyType, MeshComponentTopologyPtrType, MESH_PTR_TYPE, MeshNodesType, MeshElementsType, MeshDataPointsType, DECOMPOSITIONS_TYPE, INTERFACE_TYPE, MeshDofsType, 
! The type to handle in this routine is: MeshComponentTopologyType (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), MeshDataPointsType (CheckVariable2), MeshComponentTopologyPtrType (CheckVariable3), FIELD_TYPE (CheckVariable4), MESH_PTR_TYPE (CheckVariable5), FIELDS_TYPE (CheckVariable6), DECOMPOSITION_TYPE (CheckVariable7), MeshNodesType (CheckVariable8), MeshElementsType (CheckVariable9), REGION_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), GENERATED_MESH_TYPE (CheckVariable12), MeshComponentTopologyType (CheckVariable13), MESHES_TYPE (CheckVariable14), DECOMPOSITIONS_TYPE (CheckVariable15), InterfacePointsConnectivityType (CheckVariable16), INTERFACE_TYPE (CheckVariable17), MeshDofsType (CheckVariable18), 
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MeshComponentTopologyType
!   is type of this print routine, use Variable2
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable3
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type MeshNodesType
!   matches available passing type, use it as CheckVariable8
! - signature type MeshElementsType
!   matches available passing type, use it as CheckVariable9
! - signature type MeshDataPointsType
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type MeshDofsType
!   matches available passing type (and equals subtype), use it as CheckVariable18

    ! if variable was already followed
    Ptr3 => Variable%dofs
    IF (ASSOCIATED(Ptr3, CheckVariable18)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"dofs"
      CALL Print_MeshDofsType(Variable% &
        & dofs, CheckVariable1, Variable2, CheckVariable3, CheckVariable5, CheckVariable8, CheckVariable9, CheckVariable2, &
        & CheckVariable15, CheckVariable17, CheckVariable18, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshDofsType), POINTER :: " // &
      & "dofs (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%dataPoints
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%dataPoints)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshDataPointsType), POINTER :: " // &
      & "dataPoints " // &
      & "(associated): " 
  
! Signature of Print_MeshDataPointsType has the following CheckVariable types: MESH_TYPE, MeshComponentTopologyType, MeshComponentTopologyPtrType, MESH_PTR_TYPE, MeshNodesType, MeshElementsType, MeshDataPointsType, DECOMPOSITIONS_TYPE, INTERFACE_TYPE, MeshDofsType, 
! The type to handle in this routine is: MeshComponentTopologyType (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), MeshDataPointsType (CheckVariable2), MeshComponentTopologyPtrType (CheckVariable3), FIELD_TYPE (CheckVariable4), MESH_PTR_TYPE (CheckVariable5), FIELDS_TYPE (CheckVariable6), DECOMPOSITION_TYPE (CheckVariable7), MeshNodesType (CheckVariable8), MeshElementsType (CheckVariable9), REGION_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), GENERATED_MESH_TYPE (CheckVariable12), MeshComponentTopologyType (CheckVariable13), MESHES_TYPE (CheckVariable14), DECOMPOSITIONS_TYPE (CheckVariable15), InterfacePointsConnectivityType (CheckVariable16), INTERFACE_TYPE (CheckVariable17), MeshDofsType (CheckVariable18), 
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MeshComponentTopologyType
!   is type of this print routine, use Variable2
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable3
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type MeshNodesType
!   matches available passing type, use it as CheckVariable8
! - signature type MeshElementsType
!   matches available passing type, use it as CheckVariable9
! - signature type MeshDataPointsType
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type MeshDofsType
!   matches available passing type, use it as CheckVariable18

    ! if variable was already followed
    Ptr4 => Variable%dataPoints
    IF (ASSOCIATED(Ptr4, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"dataPoints"
      CALL Print_MeshDataPointsType(Variable% &
        & dataPoints, CheckVariable1, Variable2, CheckVariable3, CheckVariable5, CheckVariable8, CheckVariable9, &
        & CheckVariable2, CheckVariable15, CheckVariable17, CheckVariable18, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshDataPointsType), POINTER :: " // &
      & "dataPoints (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_MeshComponentTopologyType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable27

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr1
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr3
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr5
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr6
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: NullPtr7
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr8
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: NullPtr9
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: NullPtr10
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr11
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: NullPtr12
  TYPE(DecompositionDataPointsType), POINTER :: NullPtr13
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: NullPtr14

  TYPE(FIELDS_TYPE), POINTER :: Ptr0
  TYPE(REGION_TYPE), POINTER :: Ptr1
  TYPE(INTERFACE_TYPE), POINTER :: Ptr2
  TYPE(DECOMPOSITION_TYPE), POINTER :: Ptr3
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: Ptr4
  TYPE(FIELD_TYPE), POINTER :: Ptr5
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: Ptr6
  TYPE(DATA_PROJECTION_TYPE), POINTER :: Ptr7

  TYPE(FIELD_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable4)) THEN
    Variable2 => CheckVariable4
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "FIELD_FINISHED:                                  ", &
    & Variable%FIELD_FINISHED
  
  ! Variable%FIELDS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELDS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELDS_TYPE), POINTER :: " // &
      & "FIELDS " // &
      & "(associated): " 
  
! Signature of Print_FIELDS_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), InterfacePointsConnectivityType (CheckVariable6), EQUATIONS_SETS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CONTROL_LOOP_TYPE (CheckVariable11), CELLML_TYPE (CheckVariable12), INTERFACE_CONDITION_PTR_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), DOMAIN_PTR_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), FIELD_VARIABLE_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27

    ! if variable was already followed
    Ptr0 => Variable%FIELDS
    IF (ASSOCIATED(Ptr0, CheckVariable15)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELDS"
      CALL Print_FIELDS_TYPE(Variable% &
        & FIELDS, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, NullPtr0, Variable2, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, NullPtr1, CheckVariable9, CheckVariable10, CheckVariable12, &
        & CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, &
        & CheckVariable19, CheckVariable20, CheckVariable21, NullPtr2, CheckVariable22, CheckVariable23, CheckVariable24, &
        & CheckVariable25, CheckVariable26, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELDS_TYPE), POINTER :: " // &
      & "FIELDS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), InterfacePointsConnectivityType (CheckVariable6), EQUATIONS_SETS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CONTROL_LOOP_TYPE (CheckVariable11), CELLML_TYPE (CheckVariable12), INTERFACE_CONDITION_PTR_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), DOMAIN_PTR_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), FIELD_VARIABLE_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable27

    ! if variable was already followed
    Ptr1 => Variable%REGION
    IF (ASSOCIATED(Ptr1, CheckVariable27)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr3, CheckVariable3, NullPtr0, Variable2, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, NullPtr4, NullPtr1, CheckVariable9, &
        & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable14, CheckVariable15, CheckVariable16, &
        & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, NullPtr2, CheckVariable22, &
        & CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), InterfacePointsConnectivityType (CheckVariable6), EQUATIONS_SETS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CONTROL_LOOP_TYPE (CheckVariable11), CELLML_TYPE (CheckVariable12), INTERFACE_CONDITION_PTR_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), DOMAIN_PTR_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), FIELD_VARIABLE_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27

    ! if variable was already followed
    Ptr2 => Variable%INTERFACE
    IF (ASSOCIATED(Ptr2, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE"
      CALL Print_INTERFACE_TYPE(Variable% &
        & INTERFACE, NullPtr5, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, NullPtr0, Variable2, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, NullPtr1, CheckVariable9, CheckVariable10, &
        & CheckVariable11, CheckVariable13, CheckVariable14, NullPtr6, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable20, CheckVariable21, NullPtr2, CheckVariable22, CheckVariable23, CheckVariable24, &
        & CheckVariable26, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TYPE:                            ", &
    & Variable%TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DEPENDENT_TYPE:                  ", &
    & Variable%DEPENDENT_TYPE
  
  ! Variable%DECOMPOSITION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DECOMPOSITION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "DECOMPOSITION " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), InterfacePointsConnectivityType (CheckVariable6), EQUATIONS_SETS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CONTROL_LOOP_TYPE (CheckVariable11), CELLML_TYPE (CheckVariable12), INTERFACE_CONDITION_PTR_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), DOMAIN_PTR_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), FIELD_VARIABLE_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DOMAIN_MAPPINGS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_MAPPINGS_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DECOMPOSITION_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_FACES_TYPE
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_ELEMENTS_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TOPOLOGY_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable24
! - signature type DecompositionDataPointsType
!   is not available in passing variables, use NullPtr of type DecompositionDataPointsType
! - signature type DECOMPOSITION_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_LINES_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27

    ! if variable was already followed
    Ptr3 => Variable%DECOMPOSITION
    IF (ASSOCIATED(Ptr3, CheckVariable24)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DECOMPOSITION"
      CALL Print_DECOMPOSITION_TYPE(Variable% &
        & DECOMPOSITION, CheckVariable0, CheckVariable1, NullPtr7, NullPtr8, CheckVariable3, NullPtr0, Variable2, &
        & CheckVariable6, CheckVariable8, NullPtr4, CheckVariable9, NullPtr9, NullPtr10, CheckVariable14, NullPtr11, &
        & CheckVariable15, CheckVariable17, CheckVariable19, CheckVariable21, CheckVariable22, NullPtr12, CheckVariable24, &
        & NullPtr13, NullPtr14, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "DECOMPOSITION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_VARIABLES:             ", &
    & Variable%NUMBER_OF_VARIABLES
  
  ! Variable%VARIABLE_TYPE_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLE_TYPE_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLE_TYPE_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_PTR_TYPE), ALLOCATABLE :: " // &
      & "VARIABLE_TYPE_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLE_TYPE_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%VARIABLE_TYPE_MAP,1), MIN(LBOUND(Variable%VARIABLE_TYPE_MAP,1)+MaxArrayLength, UBOUND(Variable% &
      & VARIABLE_TYPE_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_VARIABLE_PTR_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, FIELDS_TYPE, FIELD_PTR_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACE_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: FIELD_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), InterfacePointsConnectivityType (CheckVariable6), EQUATIONS_SETS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CONTROL_LOOP_TYPE (CheckVariable11), CELLML_TYPE (CheckVariable12), INTERFACE_CONDITION_PTR_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), DOMAIN_PTR_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), FIELD_VARIABLE_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLE_TYPE_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_VARIABLE_PTR_TYPE(Variable% &
          & VARIABLE_TYPE_MAP(I0), CheckVariable22, CheckVariable23, CheckVariable15, CheckVariable3, CheckVariable26, &
          & Variable2, CheckVariable8, CheckVariable27, CheckVariable21, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_PTR_TYPE), ALLOCATABLE :: " // &
      & "VARIABLE_TYPE_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%VARIABLES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), ALLOCATABLE :: " // &
      & "VARIABLES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%VARIABLES,1), MIN(LBOUND(Variable%VARIABLES,1)+MaxArrayLength, UBOUND(Variable%VARIABLES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: FIELD_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), InterfacePointsConnectivityType (CheckVariable6), EQUATIONS_SETS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CONTROL_LOOP_TYPE (CheckVariable11), CELLML_TYPE (CheckVariable12), INTERFACE_CONDITION_PTR_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), DOMAIN_PTR_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), FIELD_VARIABLE_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable26
! - signature type FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21

      ! if variable was already followed
      Ptr4 => Variable%VARIABLES(I0)
      IF (ASSOCIATED(Ptr4, CheckVariable26)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_VARIABLE_TYPE(Variable% &
          & VARIABLES(I0), CheckVariable22, CheckVariable23, CheckVariable0, CheckVariable15, CheckVariable24, &
          & CheckVariable5, CheckVariable3, CheckVariable16, CheckVariable12, CheckVariable26, Variable2, CheckVariable20, &
          & CheckVariable8, CheckVariable10, CheckVariable18, CheckVariable7, CheckVariable27, CheckVariable21, Depth+1, &
          & MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), ALLOCATABLE :: " // &
      & "VARIABLES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%GEOMETRIC_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GEOMETRIC_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "GEOMETRIC_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), InterfacePointsConnectivityType (CheckVariable6), EQUATIONS_SETS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CONTROL_LOOP_TYPE (CheckVariable11), CELLML_TYPE (CheckVariable12), INTERFACE_CONDITION_PTR_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), DOMAIN_PTR_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), FIELD_VARIABLE_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27

    ! if variable was already followed
    Ptr5 => Variable%GEOMETRIC_FIELD
    IF (ASSOCIATED(Ptr5, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GEOMETRIC_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & GEOMETRIC_FIELD, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, Variable2, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
        & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "GEOMETRIC_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%GEOMETRIC_FIELD_PARAMETERS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GEOMETRIC_FIELD_PARAMETERS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: " // &
      & "GEOMETRIC_FIELD_PARAMETERS " // &
      & "(associated): " 
  
! Signature of Print_FIELD_GEOMETRIC_PARAMETERS_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, FIELDS_TYPE, FIELD_PTR_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), InterfacePointsConnectivityType (CheckVariable6), EQUATIONS_SETS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CONTROL_LOOP_TYPE (CheckVariable11), CELLML_TYPE (CheckVariable12), INTERFACE_CONDITION_PTR_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), DOMAIN_PTR_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), FIELD_VARIABLE_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable23
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27

    ! if variable was already followed
    Ptr6 => Variable%GEOMETRIC_FIELD_PARAMETERS
    IF (ASSOCIATED(Ptr6, CheckVariable23)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GEOMETRIC_FIELD_PARAMETERS"
      CALL Print_FIELD_GEOMETRIC_PARAMETERS_TYPE(Variable% &
        & GEOMETRIC_FIELD_PARAMETERS, CheckVariable22, CheckVariable23, CheckVariable15, CheckVariable3, CheckVariable26, &
        & Variable2, CheckVariable8, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: " // &
      & "GEOMETRIC_FIELD_PARAMETERS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CREATE_VALUES_CACHE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CREATE_VALUES_CACHE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_CREATE_VALUES_CACHE_TYPE), POINTER :: " // &
      & "CREATE_VALUES_CACHE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_CREATE_VALUES_CACHE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), InterfacePointsConnectivityType (CheckVariable6), EQUATIONS_SETS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CONTROL_LOOP_TYPE (CheckVariable11), CELLML_TYPE (CheckVariable12), INTERFACE_CONDITION_PTR_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), DOMAIN_PTR_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), FIELD_VARIABLE_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CREATE_VALUES_CACHE"
      CALL Print_FIELD_CREATE_VALUES_CACHE_TYPE(Variable%CREATE_VALUES_CACHE, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_CREATE_VALUES_CACHE_TYPE), POINTER :: " // &
      & "CREATE_VALUES_CACHE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DataProjection
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DataProjection)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DATA_PROJECTION_TYPE), POINTER :: " // &
      & "DataProjection " // &
      & "(associated): " 
  
! Signature of Print_DATA_PROJECTION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), InterfacePointsConnectivityType (CheckVariable6), EQUATIONS_SETS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CONTROL_LOOP_TYPE (CheckVariable11), CELLML_TYPE (CheckVariable12), INTERFACE_CONDITION_PTR_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), DOMAIN_PTR_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), FIELD_VARIABLE_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable22
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27

    ! if variable was already followed
    Ptr7 => Variable%DataProjection
    IF (ASSOCIATED(Ptr7, CheckVariable22)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DataProjection"
      CALL Print_DATA_PROJECTION_TYPE(Variable% &
        & DataProjection, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, NullPtr0, Variable2, &
        & CheckVariable5, CheckVariable6, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable14, &
        & CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable20, CheckVariable21, &
        & CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable26, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DATA_PROJECTION_TYPE), POINTER :: " // &
      & "DataProjection (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELD_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_SET_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable22

  ! iterator variables

  ! null pointers
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr0
  TYPE(EquationsSetDerivedType), POINTER :: NullPtr1
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: NullPtr4
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: NullPtr5

  TYPE(EQUATIONS_SET_TYPE), POINTER :: Ptr0

  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable20)) THEN
    Variable2 => CheckVariable20
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_TYPE has the following CheckVariable types: EQUATIONS_TYPE, MESHES_TYPE, EquationsSetDerivedType, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_PTR_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), REGION_PTR_TYPE (CheckVariable2), EQUATIONS_SETS_TYPE (CheckVariable3), INTERFACE_TYPE (CheckVariable4), CELLML_ENVIRONMENTS_TYPE (CheckVariable5), CONTROL_LOOP_TYPE (CheckVariable6), EQUATIONS_SET_TYPE (CheckVariable7), BOUNDARY_CONDITIONS_TYPE (CheckVariable8), FIELDS_TYPE (CheckVariable9), SOLVER_EQUATIONS_TYPE (CheckVariable10), NODES_TYPE (CheckVariable11), INTERFACES_TYPE (CheckVariable12), DATA_POINTS_TYPE (CheckVariable13), DATA_PROJECTION_TYPE (CheckVariable14), SOLVERS_TYPE (CheckVariable15), DECOMPOSITION_TYPE (CheckVariable16), SOLVER_TYPE (CheckVariable17), SOLVER_MAPPING_TYPE (CheckVariable18), SOLVER_MATRICES_TYPE (CheckVariable19), EQUATIONS_SET_PTR_TYPE (CheckVariable20), GENERATED_MESHES_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EquationsSetDerivedType
!   is not available in passing variables, use NullPtr of type EquationsSetDerivedType
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_MATERIALS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable7
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_ANALYTIC_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_SOURCE_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type EQUATIONS_SET_PTR_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_INDEPENDENT_TYPE

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable7)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_EQUATIONS_SET_TYPE(Variable% &
        & PTR, NullPtr0, CheckVariable0, NullPtr1, CheckVariable1, CheckVariable2, CheckVariable3, NullPtr2, &
        & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable21, &
        & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, NullPtr3, CheckVariable15, CheckVariable16, &
        & CheckVariable17, NullPtr4, CheckVariable18, CheckVariable19, Variable2, CheckVariable10, CheckVariable22, &
        & NullPtr5, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_SET_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_NEWTON_LINESEARCH_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16

  ! iterator variables

  ! null pointers
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr0
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr3
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr4
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr5
  TYPE(HISTORY_TYPE), POINTER :: NullPtr6

  TYPE(NEWTON_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable16)) THEN
    Variable2 => CheckVariable16
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%NEWTON_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NEWTON_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NEWTON_SOLVER_TYPE), POINTER :: " // &
      & "NEWTON_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_NEWTON_SOLVER_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, PROBLEM_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, LINEAR_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: NEWTON_LINESEARCH_SOLVER_TYPE (Variable)
! Available CheckVariables are: QUASI_NEWTON_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), CELLML_EQUATIONS_TYPE (CheckVariable2), DAE_SOLVER_TYPE (CheckVariable3), SOLVERS_TYPE (CheckVariable4), NEWTON_SOLVER_TYPE (CheckVariable5), SOLVER_TYPE (CheckVariable6), LINEAR_SOLVER_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), OPTIMISER_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_TYPE (CheckVariable10), DYNAMIC_SOLVER_TYPE (CheckVariable11), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable12), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable13), EIGENPROBLEM_SOLVER_TYPE (CheckVariable14), GeometricTransformationSolverType (CheckVariable15), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable16), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable5
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable15
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr0 => Variable%NEWTON_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NEWTON_SOLVER"
      CALL Print_NEWTON_SOLVER_TYPE(Variable% &
        & NEWTON_SOLVER, NullPtr0, Variable2, CheckVariable0, CheckVariable1, CheckVariable5, NullPtr1, NullPtr2, &
        & CheckVariable9, NullPtr3, CheckVariable11, CheckVariable12, CheckVariable15, NullPtr4, CheckVariable2, &
        & CheckVariable10, CheckVariable8, CheckVariable13, NullPtr5, NullPtr6, CheckVariable3, CheckVariable4, &
        & CheckVariable6, CheckVariable7, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NEWTON_SOLVER_TYPE), POINTER :: " // &
      & "NEWTON_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRICES_LIBRARY:         ", &
    & Variable%SOLVER_MATRICES_LIBRARY
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LINESEARCH_TYPE:                 ", &
    & Variable%LINESEARCH_TYPE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "LINESEARCH_ALPHA:            ", &
    & Variable%LINESEARCH_ALPHA
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "LINESEARCH_MAXSTEP:          ", &
    & Variable%LINESEARCH_MAXSTEP
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "LINESEARCH_STEPTOLERANCE:    ", &
    & Variable%LINESEARCH_STEPTOLERANCE
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "linesearchMonitorOutput:                         ", &
    & Variable%linesearchMonitorOutput

  
END SUBROUTINE Print_NEWTON_LINESEARCH_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable22

  ! iterator variables

  ! null pointers
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr0
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_TYPE), POINTER :: NullPtr2
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr4

  TYPE(FIELD_TYPE), POINTER :: Ptr0

  TYPE(FIELD_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable3)) THEN
    Variable2 => CheckVariable3
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_PTR_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), InterfacePointsConnectivityType (CheckVariable6), INTERFACE_TYPE (CheckVariable7), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable8), CELLML_ENVIRONMENTS_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), FIELDS_TYPE (CheckVariable11), GENERATED_MESHES_TYPE (CheckVariable12), DECOMPOSITIONS_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), DOMAIN_PTR_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable22

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_FIELD_TYPE(Variable% &
        & PTR, CheckVariable0, CheckVariable1, CheckVariable2, Variable2, CheckVariable4, CheckVariable5, CheckVariable6, &
        & NullPtr0, CheckVariable7, CheckVariable8, CheckVariable9, NullPtr1, NullPtr2, NullPtr3, CheckVariable10, &
        & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
        & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, NullPtr4, CheckVariable21, CheckVariable22, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELD_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_LINE_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_LINE_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(DOMAIN_LINE_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_LINE_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_LINE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DOMAIN_LINE_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_DOMAIN_LINE_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_LINE_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DOMAIN_LINE_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BoundaryConditionsCoupledDofsType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(BoundaryConditionsCoupledDofsType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(BoundaryConditionsCoupledDofsType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfDofs:                    ", &
    & Variable%numberOfDofs
  
  ! Variable%globalDofs(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%globalDofs)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%globalDofs),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "globalDofs(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%globalDofs, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%globalDofs,1), MIN(LBOUND(Variable%globalDofs,1)+MaxArrayLength, UBOUND(Variable%globalDofs,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%globalDofs(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "globalDofs(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%localDofs(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%localDofs)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%localDofs),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "localDofs(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%localDofs, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%localDofs,1), MIN(LBOUND(Variable%localDofs,1)+MaxArrayLength, UBOUND(Variable%localDofs,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%localDofs(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "localDofs(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%coefficients(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%coefficients)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%coefficients),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "coefficients(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%coefficients, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%coefficients,1), MIN(LBOUND(Variable%coefficients,1)+MaxArrayLength, UBOUND(Variable%coefficients,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%coefficients(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "coefficients(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_BoundaryConditionsCoupledDofsType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_LINES_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(DOMAIN_DOFS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DOMAIN_FACES_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DecompositionDataPointsType), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(DOMAIN_NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable25

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr2
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr3
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr4
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr5
  TYPE(MeshComponentTopologyType), POINTER :: NullPtr6
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr8
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: NullPtr9
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr10
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr11
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr12
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr13
  TYPE(NODES_TYPE), POINTER :: NullPtr14
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr15
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr16
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: NullPtr17
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr18
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr19
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr20
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr21
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr23

  TYPE(DECOMPOSITION_TYPE), POINTER :: Ptr0
  TYPE(MESH_TYPE), POINTER :: Ptr1
  TYPE(REGION_TYPE), POINTER :: Ptr2
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: Ptr3
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: Ptr4

  TYPE(DOMAIN_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)

  
  ! Variable%DECOMPOSITION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DECOMPOSITION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "DECOMPOSITION " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DOMAIN_TYPE (Variable)
! Available CheckVariables are: DOMAIN_MAPPINGS_TYPE (CheckVariable0), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable1), FIELD_PTR_TYPE (CheckVariable2), DOMAIN_LINES_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), DOMAIN_DOFS_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), DOMAIN_TYPE (CheckVariable7), FIELDS_TYPE (CheckVariable8), DECOMPOSITION_FACES_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CELLML_TYPE (CheckVariable11), DECOMPOSITION_ELEMENTS_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), DOMAIN_ELEMENTS_TYPE (CheckVariable15), DECOMPOSITIONS_TYPE (CheckVariable16), DOMAIN_PTR_TYPE (CheckVariable17), DOMAIN_FACES_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), DOMAIN_TOPOLOGY_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), DecompositionDataPointsType (CheckVariable22), DOMAIN_NODES_TYPE (CheckVariable23), DECOMPOSITION_LINES_TYPE (CheckVariable24), REGION_TYPE (CheckVariable25), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type DOMAIN_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DOMAIN_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DECOMPOSITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable21
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable22
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable25

    ! if variable was already followed
    Ptr0 => Variable%DECOMPOSITION
    IF (ASSOCIATED(Ptr0, CheckVariable21)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DECOMPOSITION"
      CALL Print_DECOMPOSITION_TYPE(Variable% &
        & DECOMPOSITION, NullPtr0, NullPtr1, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr2, CheckVariable4, &
        & NullPtr3, CheckVariable6, Variable2, NullPtr4, CheckVariable9, CheckVariable12, CheckVariable13, CheckVariable14, &
        & CheckVariable8, CheckVariable16, CheckVariable17, NullPtr5, CheckVariable19, CheckVariable20, CheckVariable21, &
        & CheckVariable22, CheckVariable24, CheckVariable25, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "DECOMPOSITION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_TYPE), POINTER :: " // &
      & "MESH " // &
      & "(associated): " 
  
! Signature of Print_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, REGION_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DOMAIN_TYPE (Variable)
! Available CheckVariables are: DOMAIN_MAPPINGS_TYPE (CheckVariable0), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable1), FIELD_PTR_TYPE (CheckVariable2), DOMAIN_LINES_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), DOMAIN_DOFS_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), DOMAIN_TYPE (CheckVariable7), FIELDS_TYPE (CheckVariable8), DECOMPOSITION_FACES_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CELLML_TYPE (CheckVariable11), DECOMPOSITION_ELEMENTS_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), DOMAIN_ELEMENTS_TYPE (CheckVariable15), DECOMPOSITIONS_TYPE (CheckVariable16), DOMAIN_PTR_TYPE (CheckVariable17), DOMAIN_FACES_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), DOMAIN_TOPOLOGY_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), DecompositionDataPointsType (CheckVariable22), DOMAIN_NODES_TYPE (CheckVariable23), DECOMPOSITION_LINES_TYPE (CheckVariable24), REGION_TYPE (CheckVariable25), 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_CYLINDER_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_ELLIPSOID_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type DOMAIN_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable13
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_REGULAR_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable25

    ! if variable was already followed
    Ptr1 => Variable%MESH
    IF (ASSOCIATED(Ptr1, CheckVariable13)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MESH"
      CALL Print_MESH_TYPE(Variable% &
        & MESH, NullPtr6, NullPtr0, NullPtr7, NullPtr1, NullPtr8, NullPtr9, CheckVariable1, CheckVariable2, NullPtr2, &
        & CheckVariable4, NullPtr10, NullPtr3, CheckVariable6, Variable2, NullPtr11, NullPtr12, NullPtr4, CheckVariable10, &
        & CheckVariable13, CheckVariable14, CheckVariable8, NullPtr13, CheckVariable16, NullPtr14, CheckVariable17, &
        & NullPtr15, NullPtr5, NullPtr16, CheckVariable19, NullPtr17, CheckVariable21, CheckVariable25, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_TYPE), POINTER :: " // &
      & "MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MESH_COMPONENT_NUMBER:           ", &
    & Variable%MESH_COMPONENT_NUMBER
  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DOMAIN_TYPE (Variable)
! Available CheckVariables are: DOMAIN_MAPPINGS_TYPE (CheckVariable0), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable1), FIELD_PTR_TYPE (CheckVariable2), DOMAIN_LINES_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), DOMAIN_DOFS_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), DOMAIN_TYPE (CheckVariable7), FIELDS_TYPE (CheckVariable8), DECOMPOSITION_FACES_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CELLML_TYPE (CheckVariable11), DECOMPOSITION_ELEMENTS_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), DOMAIN_ELEMENTS_TYPE (CheckVariable15), DECOMPOSITIONS_TYPE (CheckVariable16), DOMAIN_PTR_TYPE (CheckVariable17), DOMAIN_FACES_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), DOMAIN_TOPOLOGY_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), DecompositionDataPointsType (CheckVariable22), DOMAIN_NODES_TYPE (CheckVariable23), DECOMPOSITION_LINES_TYPE (CheckVariable24), REGION_TYPE (CheckVariable25), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type DOMAIN_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable25

    ! if variable was already followed
    Ptr2 => Variable%REGION
    IF (ASSOCIATED(Ptr2, CheckVariable25)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, NullPtr0, NullPtr1, NullPtr8, NullPtr18, CheckVariable2, NullPtr2, CheckVariable4, NullPtr12, NullPtr3, &
        & NullPtr19, CheckVariable6, Variable2, NullPtr11, NullPtr4, CheckVariable10, NullPtr20, CheckVariable11, &
        & CheckVariable13, CheckVariable8, NullPtr13, CheckVariable16, NullPtr14, CheckVariable17, NullPtr15, NullPtr5, &
        & NullPtr16, CheckVariable19, NullPtr21, CheckVariable21, NullPtr22, NullPtr23, CheckVariable25, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DIMENSIONS:            ", &
    & Variable%NUMBER_OF_DIMENSIONS
  
  ! Variable%NODE_DOMAIN(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODE_DOMAIN)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODE_DOMAIN),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_DOMAIN(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODE_DOMAIN, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NODE_DOMAIN,1), MIN(LBOUND(Variable%NODE_DOMAIN,1)+MaxArrayLength, UBOUND(Variable%NODE_DOMAIN,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NODE_DOMAIN(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_DOMAIN(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%MAPPINGS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MAPPINGS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: " // &
      & "MAPPINGS " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPINGS_TYPE has the following CheckVariable types: DOMAIN_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_TYPE, DOMAIN_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DOMAIN_TYPE (Variable)
! Available CheckVariables are: DOMAIN_MAPPINGS_TYPE (CheckVariable0), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable1), FIELD_PTR_TYPE (CheckVariable2), DOMAIN_LINES_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), DOMAIN_DOFS_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), DOMAIN_TYPE (CheckVariable7), FIELDS_TYPE (CheckVariable8), DECOMPOSITION_FACES_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CELLML_TYPE (CheckVariable11), DECOMPOSITION_ELEMENTS_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), DOMAIN_ELEMENTS_TYPE (CheckVariable15), DECOMPOSITIONS_TYPE (CheckVariable16), DOMAIN_PTR_TYPE (CheckVariable17), DOMAIN_FACES_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), DOMAIN_TOPOLOGY_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), DecompositionDataPointsType (CheckVariable22), DOMAIN_NODES_TYPE (CheckVariable23), DECOMPOSITION_LINES_TYPE (CheckVariable24), REGION_TYPE (CheckVariable25), 
! - signature type DOMAIN_TYPE
!   is type of this print routine, use Variable2
! - signature type DOMAIN_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable25

    ! if variable was already followed
    Ptr3 => Variable%MAPPINGS
    IF (ASSOCIATED(Ptr3, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MAPPINGS"
      CALL Print_DOMAIN_MAPPINGS_TYPE(Variable% &
        & MAPPINGS, Variable2, CheckVariable20, CheckVariable21, CheckVariable0, CheckVariable1, CheckVariable4, &
        & CheckVariable17, CheckVariable25, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: " // &
      & "MAPPINGS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%TOPOLOGY
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%TOPOLOGY)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: " // &
      & "TOPOLOGY " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_TOPOLOGY_TYPE has the following CheckVariable types: DOMAIN_ELEMENTS_TYPE, DOMAIN_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, DOMAIN_NODES_TYPE, DOMAIN_LINES_TYPE, FIELD_TYPE, DOMAIN_DOFS_TYPE, DOMAIN_PTR_TYPE, REGION_TYPE, DOMAIN_FACES_TYPE, 
! The type to handle in this routine is: DOMAIN_TYPE (Variable)
! Available CheckVariables are: DOMAIN_MAPPINGS_TYPE (CheckVariable0), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable1), FIELD_PTR_TYPE (CheckVariable2), DOMAIN_LINES_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), DOMAIN_DOFS_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), DOMAIN_TYPE (CheckVariable7), FIELDS_TYPE (CheckVariable8), DECOMPOSITION_FACES_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), CELLML_TYPE (CheckVariable11), DECOMPOSITION_ELEMENTS_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), DOMAIN_ELEMENTS_TYPE (CheckVariable15), DECOMPOSITIONS_TYPE (CheckVariable16), DOMAIN_PTR_TYPE (CheckVariable17), DOMAIN_FACES_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), DOMAIN_TOPOLOGY_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), DecompositionDataPointsType (CheckVariable22), DOMAIN_NODES_TYPE (CheckVariable23), DECOMPOSITION_LINES_TYPE (CheckVariable24), REGION_TYPE (CheckVariable25), 
! - signature type DOMAIN_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DOMAIN_TYPE
!   is type of this print routine, use Variable2
! - signature type DOMAIN_TOPOLOGY_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable20
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DOMAIN_NODES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DOMAIN_LINES_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DOMAIN_DOFS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DOMAIN_FACES_TYPE
!   matches available passing type, use it as CheckVariable18

    ! if variable was already followed
    Ptr4 => Variable%TOPOLOGY
    IF (ASSOCIATED(Ptr4, CheckVariable20)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TOPOLOGY"
      CALL Print_DOMAIN_TOPOLOGY_TYPE(Variable% &
        & TOPOLOGY, CheckVariable15, Variable2, CheckVariable20, CheckVariable21, CheckVariable0, CheckVariable1, &
        & CheckVariable23, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable17, CheckVariable25, &
        & CheckVariable18, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: " // &
      & "TOPOLOGY (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DOMAIN_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_DATA_POINT_PARAM_TO_DOF_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_DATA_POINT_PARAM_TO_DOF_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(FIELD_DATA_POINT_PARAM_TO_DOF_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DATA_POINT_PARAMETERS: ", &
    & Variable%NUMBER_OF_DATA_POINT_PARAMETERS
  
  ! Variable%DATA_POINTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_POINTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_POINTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DATA_POINTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_POINTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_POINTS,1), MIN(LBOUND(Variable%DATA_POINTS,1)+MaxArrayLength, UBOUND(Variable%DATA_POINTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_POINTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DATA_POINTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_DATA_POINT_PARAM_TO_DOF_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_PHYSICAL_POINT_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_PHYSICAL_POINT_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(FIELD_PHYSICAL_POINT_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_FIELD_PHYSICAL_POINT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_PHYSICAL_POINT_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_FIELD_PHYSICAL_POINT_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELD_PHYSICAL_POINT_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_MODEL_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_MODEL_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_TYPE), POINTER :: NullPtr4
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr5
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr6
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr8
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr9
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr10
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr11
  TYPE(CELLML_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr13
  TYPE(MESH_TYPE), POINTER :: NullPtr14
  TYPE(FIELDS_TYPE), POINTER :: NullPtr15
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr16
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr17
  TYPE(NODES_TYPE), POINTER :: NullPtr18
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr19
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr20
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr21
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr23
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr24
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr25
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr26
  TYPE(REGION_TYPE), POINTER :: NullPtr27


  TYPE(CELLML_MODEL_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "CELLML_MAP_TYPE:                 ", &
    & Variable%CELLML_MAP_TYPE
  
  ! Variable%FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_MODEL_MAP_TYPE (Variable)
! Available CheckVariables are: 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & FIELD, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, NullPtr18, NullPtr19, &
        & NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "VARIABLE_TYPE:                   ", &
    & Variable%VARIABLE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "COMPONENT_NUMBER:                ", &
    & Variable%COMPONENT_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "FIELD_PARAMETER_SET:             ", &
    & Variable%FIELD_PARAMETER_SET
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "CELLML_FIELD_TYPE:               ", &
    & Variable%CELLML_FIELD_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "CELLML_VARIABLE_NUMBER:          ", &
    & Variable%CELLML_VARIABLE_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "CELLML_PARAMETER_SET:            ", &
    & Variable%CELLML_PARAMETER_SET

  
END SUBROUTINE Print_CELLML_MODEL_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_GENERATED_MESH_CYLINDER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, Depth, MaxDepth, MaxArrayLength)
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable17

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MeshComponentTopologyType), POINTER :: NullPtr0
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr2
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr4
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr5
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr6
  TYPE(NODES_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(BASIS_TYPE), POINTER :: NullPtr10
  TYPE(BASIS_PTR_TYPE), POINTER :: NullPtr11

  TYPE(GENERATED_MESH_TYPE), POINTER :: Ptr0

  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable4)) THEN
    Variable2 => CheckVariable4
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)

  
  ! Variable%GENERATED_MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GENERATED_MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GENERATED_MESH_TYPE), POINTER :: " // &
      & "GENERATED_MESH " // &
      & "(associated): " 
  
! Signature of Print_GENERATED_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, DECOMPOSITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_CYLINDER_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), GENERATED_MESH_REGULAR_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), MESHES_TYPE (CheckVariable3), GENERATED_MESH_CYLINDER_TYPE (CheckVariable4), MESH_PTR_TYPE (CheckVariable5), FIELDS_TYPE (CheckVariable6), DECOMPOSITION_TYPE (CheckVariable7), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable8), REGION_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), GENERATED_MESH_TYPE (CheckVariable11), GENERATED_MESHES_TYPE (CheckVariable12), FIELD_TYPE (CheckVariable13), DECOMPOSITIONS_TYPE (CheckVariable14), InterfacePointsConnectivityType (CheckVariable15), INTERFACE_TYPE (CheckVariable16), GENERATED_MESH_PTR_TYPE (CheckVariable17), 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is type of this print routine, use Variable2
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable11
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type GENERATED_MESH_REGULAR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable9

    ! if variable was already followed
    Ptr0 => Variable%GENERATED_MESH
    IF (ASSOCIATED(Ptr0, CheckVariable11)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GENERATED_MESH"
      CALL Print_GENERATED_MESH_TYPE(Variable% &
        & GENERATED_MESH, NullPtr0, CheckVariable3, Variable2, CheckVariable5, NullPtr1, CheckVariable8, NullPtr2, &
        & CheckVariable11, CheckVariable13, NullPtr3, CheckVariable15, CheckVariable16, CheckVariable10, NullPtr4, &
        & NullPtr5, CheckVariable2, NullPtr6, CheckVariable6, CheckVariable12, CheckVariable14, NullPtr7, NullPtr8, &
        & NullPtr9, CheckVariable17, CheckVariable0, CheckVariable1, CheckVariable7, CheckVariable9, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GENERATED_MESH_TYPE), POINTER :: " // &
      & "GENERATED_MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%ORIGIN(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ORIGIN)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ORIGIN),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "ORIGIN(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ORIGIN, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ORIGIN,1), MIN(LBOUND(Variable%ORIGIN,1)+MaxArrayLength, UBOUND(Variable%ORIGIN,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ORIGIN(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "ORIGIN(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%CYLINDER_EXTENT(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%CYLINDER_EXTENT)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%CYLINDER_EXTENT),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "CYLINDER_EXTENT(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%CYLINDER_EXTENT, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%CYLINDER_EXTENT,1), MIN(LBOUND(Variable%CYLINDER_EXTENT,1)+MaxArrayLength, UBOUND(Variable% &
      & CYLINDER_EXTENT,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%CYLINDER_EXTENT(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "CYLINDER_EXTENT(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MESH_DIMENSION:                  ", &
    & Variable%MESH_DIMENSION
  
  ! Variable%NUMBER_OF_ELEMENTS_XI(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_ELEMENTS_XI)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_ELEMENTS_XI),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_ELEMENTS_XI(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_ELEMENTS_XI, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_ELEMENTS_XI,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_ELEMENTS_XI,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_ELEMENTS_XI,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_ELEMENTS_XI(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_ELEMENTS_XI(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%BASES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%BASES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%BASES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_PTR_TYPE), ALLOCATABLE :: " // &
      & "BASES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%BASES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%BASES,1), MIN(LBOUND(Variable%BASES,1)+MaxArrayLength, UBOUND(Variable%BASES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_BASIS_PTR_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_CYLINDER_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), GENERATED_MESH_REGULAR_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), MESHES_TYPE (CheckVariable3), GENERATED_MESH_CYLINDER_TYPE (CheckVariable4), MESH_PTR_TYPE (CheckVariable5), FIELDS_TYPE (CheckVariable6), DECOMPOSITION_TYPE (CheckVariable7), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable8), REGION_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), GENERATED_MESH_TYPE (CheckVariable11), GENERATED_MESHES_TYPE (CheckVariable12), FIELD_TYPE (CheckVariable13), DECOMPOSITIONS_TYPE (CheckVariable14), InterfacePointsConnectivityType (CheckVariable15), INTERFACE_TYPE (CheckVariable16), GENERATED_MESH_PTR_TYPE (CheckVariable17), 
! - signature type BASIS_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_TYPE
! - signature type BASIS_PTR_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_PTR_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BASES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_BASIS_PTR_TYPE(Variable%BASES(I0), NullPtr10, NullPtr11, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_PTR_TYPE), ALLOCATABLE :: " // &
      & "BASES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "APPEND_LINEAR_COMPONENT:                         ", &
    & Variable%APPEND_LINEAR_COMPONENT

  
END SUBROUTINE Print_GENERATED_MESH_CYLINDER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_ENVIRONMENTS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
  & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, &
  & CheckVariable31, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable31

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr1
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr2
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr4

  TYPE(REGION_TYPE), POINTER :: Ptr0

  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable14)) THEN
    Variable2 => CheckVariable14
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)

  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_ENVIRONMENTS_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), CELLML_MODELS_FIELD_TYPE (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), InterfacePointsConnectivityType (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CELLML_STATE_FIELD_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), CELLML_FIELD_MAPS_TYPE (CheckVariable19), GENERATED_MESHES_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), DATA_POINTS_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable10
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable31

    ! if variable was already followed
    Ptr0 => Variable%REGION
    IF (ASSOCIATED(Ptr0, CheckVariable31)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr0, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable10, CheckVariable8, CheckVariable9, CheckVariable11, CheckVariable12, &
        & CheckVariable13, Variable2, NullPtr1, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable20, &
        & NullPtr2, CheckVariable21, NullPtr3, CheckVariable22, CheckVariable28, CheckVariable24, CheckVariable25, &
        & NullPtr4, CheckVariable27, CheckVariable29, CheckVariable30, CheckVariable31, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ENVIRONMENTS:          ", &
    & Variable%NUMBER_OF_ENVIRONMENTS
  
  ! Variable%ENVIRONMENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ENVIRONMENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ENVIRONMENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_PTR_TYPE), ALLOCATABLE :: " // &
      & "ENVIRONMENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ENVIRONMENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%ENVIRONMENTS,1), MIN(LBOUND(Variable%ENVIRONMENTS,1)+MaxArrayLength, UBOUND(Variable%ENVIRONMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_CELLML_PTR_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, DATA_POINTS_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_ENVIRONMENTS_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), CELLML_MODELS_FIELD_TYPE (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), InterfacePointsConnectivityType (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CELLML_STATE_FIELD_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), CELLML_FIELD_MAPS_TYPE (CheckVariable19), GENERATED_MESHES_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), DATA_POINTS_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable31
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ENVIRONMENTS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_CELLML_PTR_TYPE(Variable% &
          & ENVIRONMENTS(I0), CheckVariable0, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable9, &
          & CheckVariable11, Variable2, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, &
          & CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable25, &
          & CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable30, CheckVariable31, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_PTR_TYPE), ALLOCATABLE :: " // &
      & "ENVIRONMENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_CELLML_ENVIRONMENTS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_EQUATIONS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_PENALTY_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable16

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr2
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr3
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr4
  TYPE(MESH_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr9
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr10
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr13
  TYPE(REGION_TYPE), POINTER :: NullPtr14
  TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER :: NullPtr15
  TYPE(INTERFACE_RHS_TYPE), POINTER :: NullPtr16

  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: Ptr0
  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: Ptr1
  TYPE(INTERFACE_MAPPING_TYPE), POINTER :: Ptr2
  TYPE(INTERFACE_MATRICES_TYPE), POINTER :: Ptr3

  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable4)) THEN
    Variable2 => CheckVariable4
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)

  
  ! Variable%INTERFACE_CONDITION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_CONDITION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITION " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_CONDITION_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, SOLVER_EQUATIONS_TYPE, INTERFACE_LAGRANGE_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, INTERFACE_PENALTY_TYPE, GENERATED_MESHES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_EQUATIONS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_LAGRANGE_TYPE (CheckVariable1), BOUNDARY_CONDITIONS_TYPE (CheckVariable2), INTERFACE_MATRICES_TYPE (CheckVariable3), INTERFACE_EQUATIONS_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), INTERFACE_CONDITIONS_TYPE (CheckVariable6), SOLVER_TYPE (CheckVariable7), INTERFACE_DEPENDENT_TYPE (CheckVariable8), SOLVER_MAPPING_TYPE (CheckVariable9), INTERFACE_MAPPING_TYPE (CheckVariable10), INTERFACE_PENALTY_TYPE (CheckVariable11), SOLVER_EQUATIONS_TYPE (CheckVariable12), FIELD_TYPE (CheckVariable13), INTERFACE_EQUATIONS_INTERPOLATION_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), INTERFACE_TYPE (CheckVariable16), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_LAGRANGE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_DEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type INTERFACE_PENALTY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_CONDITION
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_CONDITION"
      CALL Print_INTERFACE_CONDITION_TYPE(Variable% &
        & INTERFACE_CONDITION, CheckVariable0, NullPtr0, NullPtr1, CheckVariable6, CheckVariable13, NullPtr2, &
        & CheckVariable16, NullPtr3, NullPtr4, CheckVariable15, NullPtr5, CheckVariable2, Variable2, CheckVariable5, &
        & CheckVariable12, CheckVariable1, NullPtr6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, NullPtr11, CheckVariable7, &
        & CheckVariable8, CheckVariable9, NullPtr12, CheckVariable11, NullPtr13, NullPtr14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "INTERFACE_EQUATIONS_FINISHED:                    ", &
    & Variable%INTERFACE_EQUATIONS_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "OUTPUT_TYPE:                     ", &
    & Variable%OUTPUT_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SPARSITY_TYPE:                   ", &
    & Variable%SPARSITY_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LINEARITY:                       ", &
    & Variable%LINEARITY
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TIME_DEPENDENCE:                 ", &
    & Variable%TIME_DEPENDENCE
  
  ! Variable%INTERPOLATION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERPOLATION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: " // &
      & "INTERPOLATION " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_EQUATIONS_INTERPOLATION_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_EQUATIONS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_MAPPING_TYPE, FIELD_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_EQUATIONS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_LAGRANGE_TYPE (CheckVariable1), BOUNDARY_CONDITIONS_TYPE (CheckVariable2), INTERFACE_MATRICES_TYPE (CheckVariable3), INTERFACE_EQUATIONS_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), INTERFACE_CONDITIONS_TYPE (CheckVariable6), SOLVER_TYPE (CheckVariable7), INTERFACE_DEPENDENT_TYPE (CheckVariable8), SOLVER_MAPPING_TYPE (CheckVariable9), INTERFACE_MAPPING_TYPE (CheckVariable10), INTERFACE_PENALTY_TYPE (CheckVariable11), SOLVER_EQUATIONS_TYPE (CheckVariable12), FIELD_TYPE (CheckVariable13), INTERFACE_EQUATIONS_INTERPOLATION_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), INTERFACE_TYPE (CheckVariable16), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type INTERFACE_EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable16

    ! if variable was already followed
    Ptr1 => Variable%INTERPOLATION
    IF (ASSOCIATED(Ptr1, CheckVariable14)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERPOLATION"
      CALL Print_INTERFACE_EQUATIONS_INTERPOLATION_TYPE(Variable% &
        & INTERPOLATION, CheckVariable0, Variable2, CheckVariable6, CheckVariable9, CheckVariable13, CheckVariable16, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: " // &
      & "INTERPOLATION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MAPPING_TYPE), POINTER :: " // &
      & "INTERFACE_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_MAPPING_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_MAPPING_RHS_TYPE, INTERFACE_EQUATIONS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_MAPPING_TYPE, FIELD_TYPE, INTERFACE_TYPE, INTERFACE_MATRICES_TYPE, 
! The type to handle in this routine is: INTERFACE_EQUATIONS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_LAGRANGE_TYPE (CheckVariable1), BOUNDARY_CONDITIONS_TYPE (CheckVariable2), INTERFACE_MATRICES_TYPE (CheckVariable3), INTERFACE_EQUATIONS_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), INTERFACE_CONDITIONS_TYPE (CheckVariable6), SOLVER_TYPE (CheckVariable7), INTERFACE_DEPENDENT_TYPE (CheckVariable8), SOLVER_MAPPING_TYPE (CheckVariable9), INTERFACE_MAPPING_TYPE (CheckVariable10), INTERFACE_PENALTY_TYPE (CheckVariable11), SOLVER_EQUATIONS_TYPE (CheckVariable12), FIELD_TYPE (CheckVariable13), INTERFACE_EQUATIONS_INTERPOLATION_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), INTERFACE_TYPE (CheckVariable16), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type INTERFACE_MAPPING_RHS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MAPPING_RHS_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable3

    ! if variable was already followed
    Ptr2 => Variable%INTERFACE_MAPPING
    IF (ASSOCIATED(Ptr2, CheckVariable10)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_MAPPING"
      CALL Print_INTERFACE_MAPPING_TYPE(Variable% &
        & INTERFACE_MAPPING, CheckVariable0, NullPtr15, Variable2, CheckVariable6, CheckVariable9, CheckVariable13, &
        & CheckVariable16, CheckVariable3, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MAPPING_TYPE), POINTER :: " // &
      & "INTERFACE_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MATRICES_TYPE), POINTER :: " // &
      & "INTERFACE_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_MATRICES_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_EQUATIONS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_EQUATIONS_TYPE, INTERFACE_RHS_TYPE, FIELD_TYPE, INTERFACE_MAPPING_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_EQUATIONS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_LAGRANGE_TYPE (CheckVariable1), BOUNDARY_CONDITIONS_TYPE (CheckVariable2), INTERFACE_MATRICES_TYPE (CheckVariable3), INTERFACE_EQUATIONS_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), INTERFACE_CONDITIONS_TYPE (CheckVariable6), SOLVER_TYPE (CheckVariable7), INTERFACE_DEPENDENT_TYPE (CheckVariable8), SOLVER_MAPPING_TYPE (CheckVariable9), INTERFACE_MAPPING_TYPE (CheckVariable10), INTERFACE_PENALTY_TYPE (CheckVariable11), SOLVER_EQUATIONS_TYPE (CheckVariable12), FIELD_TYPE (CheckVariable13), INTERFACE_EQUATIONS_INTERPOLATION_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), INTERFACE_TYPE (CheckVariable16), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type INTERFACE_EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_RHS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_RHS_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable16

    ! if variable was already followed
    Ptr3 => Variable%INTERFACE_MATRICES
    IF (ASSOCIATED(Ptr3, CheckVariable3)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_MATRICES"
      CALL Print_INTERFACE_MATRICES_TYPE(Variable% &
        & INTERFACE_MATRICES, CheckVariable0, Variable2, CheckVariable6, CheckVariable7, CheckVariable9, CheckVariable12, &
        & NullPtr16, CheckVariable13, CheckVariable10, CheckVariable16, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MATRICES_TYPE), POINTER :: " // &
      & "INTERFACE_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_EQUATIONS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_STATE_FIELD_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable12

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr2
  TYPE(MESH_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_MODEL_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr9
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr11
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr12
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr13
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr14
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr15
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr16
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr17
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr18
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr19
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr20
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr21

  TYPE(CELLML_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)

  
  ! Variable%CELLML
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CELLML)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML " // &
      & "(associated): " 
  
! Signature of Print_CELLML_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, CELLML_MODEL_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_STATE_FIELD_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), CELLML_FIELD_MAPS_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), CELLML_ENVIRONMENTS_TYPE (CheckVariable6), CELLML_STATE_FIELD_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), CELLML_MODELS_FIELD_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable12), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_STATE_FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CELLML_MODEL_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_MODEL_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr0 => Variable%CELLML
    IF (ASSOCIATED(Ptr0, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML"
      CALL Print_CELLML_TYPE(Variable% &
        & CELLML, NullPtr0, CheckVariable8, NullPtr1, CheckVariable10, CheckVariable12, CheckVariable5, NullPtr2, &
        & CheckVariable6, Variable2, CheckVariable9, NullPtr3, CheckVariable2, CheckVariable4, NullPtr4, NullPtr5, &
        & NullPtr6, NullPtr7, NullPtr8, CheckVariable0, CheckVariable1, CheckVariable3, NullPtr9, CheckVariable11, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "STATE_FIELD_FINISHED:                            ", &
    & Variable%STATE_FIELD_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "STATE_FIELD_AUTO_CREATED:                        ", &
    & Variable%STATE_FIELD_AUTO_CREATED
  
  ! Variable%STATE_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%STATE_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "STATE_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_STATE_FIELD_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), CELLML_FIELD_MAPS_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), CELLML_ENVIRONMENTS_TYPE (CheckVariable6), CELLML_STATE_FIELD_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), CELLML_MODELS_FIELD_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable12), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr1 => Variable%STATE_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"STATE_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & STATE_FIELD, NullPtr0, NullPtr10, NullPtr11, NullPtr12, CheckVariable8, NullPtr1, NullPtr13, NullPtr14, &
        & CheckVariable5, NullPtr15, CheckVariable6, NullPtr16, CheckVariable9, NullPtr17, NullPtr3, CheckVariable2, &
        & NullPtr5, NullPtr18, NullPtr6, NullPtr19, NullPtr7, NullPtr8, CheckVariable0, NullPtr20, CheckVariable3, &
        & NullPtr21, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "STATE_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_CELLML_STATE_FIELD_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CellMLPETScContextType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(CellMLPETScContextType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr1
  TYPE(FIELD_TYPE), POINTER :: NullPtr2
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr10
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr11
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: NullPtr12
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: NullPtr13
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr14
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr15
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr16
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr17
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr18
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr19
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr20
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr21
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr22
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: NullPtr23
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr24
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr25
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr26
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr27
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr28
  TYPE(HISTORY_TYPE), POINTER :: NullPtr29
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr30
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr31
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: NullPtr32
  TYPE(SOLVER_TYPE), POINTER :: NullPtr33
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr34
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr35
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr36
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr37
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr38
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr39
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr40
  TYPE(MESHES_TYPE), POINTER :: NullPtr41
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr42
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: NullPtr43
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: NullPtr44
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr45
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr46
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr47
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: NullPtr48
  TYPE(CELLML_TYPE), POINTER :: NullPtr49
  TYPE(MESH_TYPE), POINTER :: NullPtr50
  TYPE(FIELDS_TYPE), POINTER :: NullPtr51
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: NullPtr52
  TYPE(CELLML_MODEL_TYPE), POINTER :: NullPtr53
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr54
  TYPE(NODES_TYPE), POINTER :: NullPtr55
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr56
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr57
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr58
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: NullPtr59
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr60
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr61
  TYPE(REGION_TYPE), POINTER :: NullPtr62


  TYPE(CellMLPETScContextType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)
  Nullify(NullPtr29)
  Nullify(NullPtr30)
  Nullify(NullPtr31)
  Nullify(NullPtr32)
  Nullify(NullPtr33)
  Nullify(NullPtr34)
  Nullify(NullPtr35)
  Nullify(NullPtr36)
  Nullify(NullPtr37)
  Nullify(NullPtr38)
  Nullify(NullPtr39)
  Nullify(NullPtr40)
  Nullify(NullPtr41)
  Nullify(NullPtr42)
  Nullify(NullPtr43)
  Nullify(NullPtr44)
  Nullify(NullPtr45)
  Nullify(NullPtr46)
  Nullify(NullPtr47)
  Nullify(NullPtr48)
  Nullify(NullPtr49)
  Nullify(NullPtr50)
  Nullify(NullPtr51)
  Nullify(NullPtr52)
  Nullify(NullPtr53)
  Nullify(NullPtr54)
  Nullify(NullPtr55)
  Nullify(NullPtr56)
  Nullify(NullPtr57)
  Nullify(NullPtr58)
  Nullify(NullPtr59)
  Nullify(NullPtr60)
  Nullify(NullPtr61)
  Nullify(NullPtr62)

  
  ! Variable%solver
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%solver)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "solver " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CellMLPETScContextType (Variable)
! Available CheckVariables are: 
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"solver"
      CALL Print_SOLVER_TYPE(Variable% &
        & solver, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, NullPtr18, NullPtr19, &
        & NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, NullPtr29, &
        & NullPtr30, NullPtr31, NullPtr32, NullPtr33, NullPtr34, NullPtr35, NullPtr36, NullPtr37, NullPtr38, NullPtr39, &
        & NullPtr40, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "solver (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%cellml
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%cellml)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_TYPE), POINTER :: " // &
      & "cellml " // &
      & "(associated): " 
  
! Signature of Print_CELLML_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, CELLML_MODEL_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CellMLPETScContextType (Variable)
! Available CheckVariables are: 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type CELLML_MODELS_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_MODELS_FIELD_TYPE
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_INTERMEDIATE_FIELD_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CELLML_STATE_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_STATE_FIELD_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type CELLML_FIELD_MAPS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_FIELD_MAPS_TYPE
! - signature type CELLML_MODEL_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_MODEL_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_PARAMETERS_FIELD_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"cellml"
      CALL Print_CELLML_TYPE(Variable% &
        & cellml, NullPtr41, NullPtr2, NullPtr42, NullPtr43, NullPtr44, NullPtr45, NullPtr46, NullPtr47, NullPtr48, &
        & NullPtr49, NullPtr50, NullPtr51, NullPtr52, NullPtr53, NullPtr54, NullPtr55, NullPtr56, NullPtr57, NullPtr58, &
        & NullPtr59, NullPtr60, NullPtr61, NullPtr62, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_TYPE), POINTER :: " // &
      & "cellml (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "dofIdx:                          ", &
    & Variable%dofIdx
  
  ! Variable%rates(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%rates)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), POINTER :: " // &
      & "rates(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%rates,1), "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%rates,1), MIN(LBOUND(Variable%rates,1)+MaxArrayLength, UBOUND(Variable%rates,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%rates(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), POINTER :: " // &
      & "rates(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%ratesIndices(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ratesIndices)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ratesIndices),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ratesIndices(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ratesIndices, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ratesIndices,1), MIN(LBOUND(Variable%ratesIndices,1)+MaxArrayLength, UBOUND(Variable%ratesIndices,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ratesIndices(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ratesIndices(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_CellMLPETScContextType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MeshDataPointType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(MeshDataPointType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(MeshDataPointType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "userNumber:                      ", &
    & Variable%userNumber
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "globalNumber:                    ", &
    & Variable%globalNumber
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "elementNumber:                   ", &
    & Variable%elementNumber

  
END SUBROUTINE Print_MeshDataPointType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_SCALING_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_SCALING_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: NullPtr0
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr1
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: NullPtr2


  TYPE(FIELD_SCALING_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MESH_COMPONENT_NUMBER:           ", &
    & Variable%MESH_COMPONENT_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAX_NUMBER_OF_DERIVATIVES:       ", &
    & Variable%MAX_NUMBER_OF_DERIVATIVES
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAX_NUMBER_OF_ELEMENT_PARAMETERS: ", &
    & Variable%MAX_NUMBER_OF_ELEMENT_PARAMETERS
  
  ! Variable%SCALE_FACTORS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SCALE_FACTORS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "SCALE_FACTORS " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: FIELD_SCALING_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SCALE_FACTORS"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%SCALE_FACTORS, NullPtr0, NullPtr1, NullPtr2, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "SCALE_FACTORS (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELD_SCALING_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MAPPING_RHS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable3

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr3
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr4
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr6
  TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER :: NullPtr8
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr10
  TYPE(MESHES_TYPE), POINTER :: NullPtr11
  TYPE(FIELDS_TYPE), POINTER :: NullPtr12
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr13
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr16
  TYPE(CELLML_TYPE), POINTER :: NullPtr17
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr19
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr20
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr21
  TYPE(NODES_TYPE), POINTER :: NullPtr22
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr23

  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: Ptr0

  TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)

  
  ! Variable%EQUATIONS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MAPPING_LINEAR_TYPE, EQUATIONS_MAPPING_DYNAMIC_TYPE, EQUATIONS_MAPPING_RHS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, REGION_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_MAPPING_SOURCE_TYPE, EQUATIONS_MAPPING_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_RHS_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), REGION_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EQUATIONS_MAPPING_LINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_LINEAR_TYPE
! - signature type EQUATIONS_MAPPING_DYNAMIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_DYNAMIC_TYPE
! - signature type EQUATIONS_MAPPING_RHS_TYPE
!   is type of this print routine, use Variable2
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type EQUATIONS_MAPPING_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_NONLINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_NONLINEAR_TYPE

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_MAPPING
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MAPPING"
      CALL Print_EQUATIONS_MAPPING_TYPE(Variable% &
        & EQUATIONS_MAPPING, CheckVariable0, NullPtr0, NullPtr1, NullPtr2, Variable2, NullPtr3, NullPtr4, CheckVariable2, &
        & NullPtr5, CheckVariable3, NullPtr6, NullPtr7, NullPtr8, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "RHS_VARIABLE_TYPE:               ", &
    & Variable%RHS_VARIABLE_TYPE
  
  ! Variable%RHS_VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RHS_VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "RHS_VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_RHS_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), REGION_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RHS_VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & RHS_VARIABLE, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, &
        & NullPtr18, CheckVariable3, NullPtr19, NullPtr20, NullPtr21, NullPtr22, NullPtr6, CheckVariable2, NullPtr23, &
        & Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "RHS_VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%RHS_VARIABLE_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RHS_VARIABLE_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "RHS_VARIABLE_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MAPPING_RHS_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), REGION_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RHS_VARIABLE_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%RHS_VARIABLE_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "RHS_VARIABLE_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "RHS_COEFFICIENT:             ", &
    & Variable%RHS_COEFFICIENT
  
  ! Variable%RHS_DOF_TO_EQUATIONS_ROW_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%RHS_DOF_TO_EQUATIONS_ROW_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%RHS_DOF_TO_EQUATIONS_ROW_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "RHS_DOF_TO_EQUATIONS_ROW_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%RHS_DOF_TO_EQUATIONS_ROW_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%RHS_DOF_TO_EQUATIONS_ROW_MAP,1), MIN(LBOUND(Variable% &
      & RHS_DOF_TO_EQUATIONS_ROW_MAP,1)+MaxArrayLength, UBOUND(Variable%RHS_DOF_TO_EQUATIONS_ROW_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%RHS_DOF_TO_EQUATIONS_ROW_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "RHS_DOF_TO_EQUATIONS_ROW_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_ROW_TO_RHS_DOF_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_ROW_TO_RHS_DOF_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_ROW_TO_RHS_DOF_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_ROW_TO_RHS_DOF_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_ROW_TO_RHS_DOF_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_ROW_TO_RHS_DOF_MAP,1), MIN(LBOUND(Variable% &
      & EQUATIONS_ROW_TO_RHS_DOF_MAP,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_ROW_TO_RHS_DOF_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_ROW_TO_RHS_DOF_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_ROW_TO_RHS_DOF_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EQUATIONS_MAPPING_RHS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FORWARD_EULER_DAE_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, Depth, MaxDepth, MaxArrayLength)
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13

  ! iterator variables

  ! null pointers
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr4
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr8

  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)

  
  ! Variable%EULER_DAE_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EULER_DAE_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "EULER_DAE_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_EULER_DAE_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, EXTERNAL_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: FORWARD_EULER_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable4), EULER_DAE_SOLVER_TYPE (CheckVariable5), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable6), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable7), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable8), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_TYPE (CheckVariable10), BDF_DAE_SOLVER_TYPE (CheckVariable11), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable5
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13

    ! if variable was already followed
    Ptr0 => Variable%EULER_DAE_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EULER_DAE_SOLVER"
      CALL Print_EULER_DAE_SOLVER_TYPE(Variable% &
        & EULER_DAE_SOLVER, CheckVariable11, Variable2, CheckVariable12, NullPtr0, CheckVariable4, NullPtr1, &
        & CheckVariable9, CheckVariable10, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, CheckVariable6, NullPtr7, &
        & CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable5, NullPtr8, CheckVariable8, &
        & CheckVariable13, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "EULER_DAE_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)

  
END SUBROUTINE Print_FORWARD_EULER_DAE_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DATA_PROJECTION_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, Depth, MaxDepth, MaxArrayLength)
  TYPE(DATA_PROJECTION_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable21

  ! iterator variables

  ! null pointers
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr0

  TYPE(DATA_PROJECTION_TYPE), POINTER :: Ptr0

  TYPE(DATA_PROJECTION_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DATA_PROJECTION_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_DATA_PROJECTION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DATA_PROJECTION_PTR_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), GENERATED_MESH_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), InterfacePointsConnectivityType (CheckVariable6), INTERFACE_TYPE (CheckVariable7), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable8), CELLML_ENVIRONMENTS_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), FIELDS_TYPE (CheckVariable11), GENERATED_MESHES_TYPE (CheckVariable12), DECOMPOSITIONS_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), INTERFACES_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), DATA_PROJECTION_TYPE (CheckVariable17), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable18), DECOMPOSITION_TYPE (CheckVariable19), FIELD_VARIABLE_TYPE (CheckVariable20), REGION_TYPE (CheckVariable21), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable17
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable21

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable17)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_DATA_PROJECTION_TYPE(Variable% &
        & PTR, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr0, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DATA_PROJECTION_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DATA_PROJECTION_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_GENERATED_MESH_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, Depth, MaxDepth, MaxArrayLength)
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MeshComponentTopologyType), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable27

  ! iterator variables

  ! null pointers
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_TYPE), POINTER :: NullPtr2
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr4
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr5
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr6
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr7
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr11
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr12

  TYPE(GENERATED_MESHES_TYPE), POINTER :: Ptr0
  TYPE(REGION_TYPE), POINTER :: Ptr1
  TYPE(INTERFACE_TYPE), POINTER :: Ptr2
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: Ptr3
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: Ptr4
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: Ptr5
  TYPE(MESH_TYPE), POINTER :: Ptr6

  TYPE(GENERATED_MESH_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  
  ! Variable%GENERATED_MESHES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GENERATED_MESHES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GENERATED_MESHES_TYPE), POINTER :: " // &
      & "GENERATED_MESHES " // &
      & "(associated): " 
  
! Signature of Print_GENERATED_MESHES_TYPE has the following CheckVariable types: MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), FIELD_PTR_TYPE (CheckVariable6), GENERATED_MESH_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), REGION_PTR_TYPE (CheckVariable9), InterfacePointsConnectivityType (CheckVariable10), INTERFACE_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), MeshComponentTopologyPtrType (CheckVariable16), FIELDS_TYPE (CheckVariable17), GENERATED_MESHES_TYPE (CheckVariable18), DECOMPOSITIONS_TYPE (CheckVariable19), NODES_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), GENERATED_MESH_REGULAR_TYPE (CheckVariable25), DECOMPOSITION_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type GENERATED_MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable10
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable18
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type GENERATED_MESH_REGULAR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27

    ! if variable was already followed
    Ptr0 => Variable%GENERATED_MESHES
    IF (ASSOCIATED(Ptr0, CheckVariable18)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GENERATED_MESHES"
      CALL Print_GENERATED_MESHES_TYPE(Variable% &
        & GENERATED_MESHES, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, &
        & Variable2, CheckVariable8, CheckVariable9, CheckVariable10, NullPtr0, CheckVariable11, NullPtr1, CheckVariable12, &
        & CheckVariable13, NullPtr2, NullPtr3, CheckVariable15, CheckVariable17, CheckVariable18, CheckVariable19, &
        & CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, &
        & CheckVariable26, NullPtr4, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GENERATED_MESHES_TYPE), POINTER :: " // &
      & "GENERATED_MESHES (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "GENERATED_MESH_FINISHED:                         ", &
    & Variable%GENERATED_MESH_FINISHED
  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), FIELD_PTR_TYPE (CheckVariable6), GENERATED_MESH_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), REGION_PTR_TYPE (CheckVariable9), InterfacePointsConnectivityType (CheckVariable10), INTERFACE_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), MeshComponentTopologyPtrType (CheckVariable16), FIELDS_TYPE (CheckVariable17), GENERATED_MESHES_TYPE (CheckVariable18), DECOMPOSITIONS_TYPE (CheckVariable19), NODES_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), GENERATED_MESH_REGULAR_TYPE (CheckVariable25), DECOMPOSITION_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type GENERATED_MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable10
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable27

    ! if variable was already followed
    Ptr1 => Variable%REGION
    IF (ASSOCIATED(Ptr1, CheckVariable27)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, CheckVariable1, CheckVariable3, CheckVariable4, NullPtr5, CheckVariable6, Variable2, CheckVariable8, &
        & CheckVariable9, CheckVariable10, NullPtr0, CheckVariable11, NullPtr6, NullPtr1, CheckVariable12, CheckVariable13, &
        & NullPtr7, NullPtr2, CheckVariable15, CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, &
        & NullPtr8, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, NullPtr9, CheckVariable26, &
        & NullPtr4, NullPtr10, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), FIELD_PTR_TYPE (CheckVariable6), GENERATED_MESH_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), REGION_PTR_TYPE (CheckVariable9), InterfacePointsConnectivityType (CheckVariable10), INTERFACE_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), MeshComponentTopologyPtrType (CheckVariable16), FIELDS_TYPE (CheckVariable17), GENERATED_MESHES_TYPE (CheckVariable18), DECOMPOSITIONS_TYPE (CheckVariable19), NODES_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), GENERATED_MESH_REGULAR_TYPE (CheckVariable25), DECOMPOSITION_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type GENERATED_MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable10
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable11
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable16
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27

    ! if variable was already followed
    Ptr2 => Variable%INTERFACE
    IF (ASSOCIATED(Ptr2, CheckVariable11)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE"
      CALL Print_INTERFACE_TYPE(Variable% &
        & INTERFACE, NullPtr11, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable6, Variable2, CheckVariable8, &
        & CheckVariable9, CheckVariable10, NullPtr0, CheckVariable11, NullPtr1, CheckVariable12, CheckVariable13, NullPtr7, &
        & NullPtr3, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, &
        & CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, NullPtr9, CheckVariable26, NullPtr10, &
        & CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GENERATED_TYPE:                  ", &
    & Variable%GENERATED_TYPE
  
  ! Variable%REGULAR_MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGULAR_MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: " // &
      & "REGULAR_MESH " // &
      & "(associated): " 
  
! Signature of Print_GENERATED_MESH_REGULAR_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, MESH_TYPE, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, REGION_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, GENERATED_MESH_TYPE, GENERATED_MESHES_TYPE, FIELD_TYPE, DECOMPOSITIONS_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, GENERATED_MESH_PTR_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), FIELD_PTR_TYPE (CheckVariable6), GENERATED_MESH_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), REGION_PTR_TYPE (CheckVariable9), InterfacePointsConnectivityType (CheckVariable10), INTERFACE_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), MeshComponentTopologyPtrType (CheckVariable16), FIELDS_TYPE (CheckVariable17), GENERATED_MESHES_TYPE (CheckVariable18), DECOMPOSITIONS_TYPE (CheckVariable19), NODES_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), GENERATED_MESH_REGULAR_TYPE (CheckVariable25), DECOMPOSITION_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type GENERATED_MESH_REGULAR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable25
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type GENERATED_MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable23

    ! if variable was already followed
    Ptr3 => Variable%REGULAR_MESH
    IF (ASSOCIATED(Ptr3, CheckVariable25)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGULAR_MESH"
      CALL Print_GENERATED_MESH_REGULAR_TYPE(Variable% &
        & REGULAR_MESH, CheckVariable24, CheckVariable25, CheckVariable15, CheckVariable1, CheckVariable2, CheckVariable3, &
        & CheckVariable17, CheckVariable26, CheckVariable5, CheckVariable27, CheckVariable12, Variable2, CheckVariable18, &
        & CheckVariable8, CheckVariable19, CheckVariable10, CheckVariable11, CheckVariable23, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: " // &
      & "REGULAR_MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CYLINDER_MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CYLINDER_MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: " // &
      & "CYLINDER_MESH " // &
      & "(associated): " 
  
! Signature of Print_GENERATED_MESH_CYLINDER_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, MESH_TYPE, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, REGION_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, GENERATED_MESH_TYPE, GENERATED_MESHES_TYPE, FIELD_TYPE, DECOMPOSITIONS_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, GENERATED_MESH_PTR_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), FIELD_PTR_TYPE (CheckVariable6), GENERATED_MESH_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), REGION_PTR_TYPE (CheckVariable9), InterfacePointsConnectivityType (CheckVariable10), INTERFACE_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), MeshComponentTopologyPtrType (CheckVariable16), FIELDS_TYPE (CheckVariable17), GENERATED_MESHES_TYPE (CheckVariable18), DECOMPOSITIONS_TYPE (CheckVariable19), NODES_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), GENERATED_MESH_REGULAR_TYPE (CheckVariable25), DECOMPOSITION_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type GENERATED_MESH_REGULAR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type GENERATED_MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable23

    ! if variable was already followed
    Ptr4 => Variable%CYLINDER_MESH
    IF (ASSOCIATED(Ptr4, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CYLINDER_MESH"
      CALL Print_GENERATED_MESH_CYLINDER_TYPE(Variable% &
        & CYLINDER_MESH, CheckVariable24, CheckVariable25, CheckVariable15, CheckVariable1, CheckVariable2, CheckVariable3, &
        & CheckVariable17, CheckVariable26, CheckVariable5, CheckVariable27, CheckVariable12, Variable2, CheckVariable18, &
        & CheckVariable8, CheckVariable19, CheckVariable10, CheckVariable11, CheckVariable23, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: " // &
      & "CYLINDER_MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%ELLIPSOID_MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ELLIPSOID_MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: " // &
      & "ELLIPSOID_MESH " // &
      & "(associated): " 
  
! Signature of Print_GENERATED_MESH_ELLIPSOID_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, MESH_TYPE, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, REGION_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, GENERATED_MESH_TYPE, GENERATED_MESHES_TYPE, FIELD_TYPE, DECOMPOSITIONS_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, GENERATED_MESH_PTR_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), FIELD_PTR_TYPE (CheckVariable6), GENERATED_MESH_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), REGION_PTR_TYPE (CheckVariable9), InterfacePointsConnectivityType (CheckVariable10), INTERFACE_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), MeshComponentTopologyPtrType (CheckVariable16), FIELDS_TYPE (CheckVariable17), GENERATED_MESHES_TYPE (CheckVariable18), DECOMPOSITIONS_TYPE (CheckVariable19), NODES_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), GENERATED_MESH_REGULAR_TYPE (CheckVariable25), DECOMPOSITION_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type GENERATED_MESH_REGULAR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable5
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type GENERATED_MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable23

    ! if variable was already followed
    Ptr5 => Variable%ELLIPSOID_MESH
    IF (ASSOCIATED(Ptr5, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ELLIPSOID_MESH"
      CALL Print_GENERATED_MESH_ELLIPSOID_TYPE(Variable% &
        & ELLIPSOID_MESH, CheckVariable24, CheckVariable25, CheckVariable15, CheckVariable1, CheckVariable2, &
        & CheckVariable3, CheckVariable17, CheckVariable26, CheckVariable5, CheckVariable27, CheckVariable12, Variable2, &
        & CheckVariable18, CheckVariable8, CheckVariable19, CheckVariable10, CheckVariable11, CheckVariable23, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: " // &
      & "ELLIPSOID_MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_TYPE), POINTER :: " // &
      & "MESH " // &
      & "(associated): " 
  
! Signature of Print_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, REGION_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), FIELD_PTR_TYPE (CheckVariable6), GENERATED_MESH_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), REGION_PTR_TYPE (CheckVariable9), InterfacePointsConnectivityType (CheckVariable10), INTERFACE_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), MeshComponentTopologyPtrType (CheckVariable16), FIELDS_TYPE (CheckVariable17), GENERATED_MESHES_TYPE (CheckVariable18), DECOMPOSITIONS_TYPE (CheckVariable19), NODES_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), GENERATED_MESH_REGULAR_TYPE (CheckVariable25), DECOMPOSITION_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type MeshComponentTopologyType
!   matches available passing type, use it as CheckVariable0
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type GENERATED_MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable16
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable15
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type GENERATED_MESH_REGULAR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27

    ! if variable was already followed
    Ptr6 => Variable%MESH
    IF (ASSOCIATED(Ptr6, CheckVariable15)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MESH"
      CALL Print_MESH_TYPE(Variable% &
        & MESH, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, NullPtr12, &
        & CheckVariable6, Variable2, CheckVariable8, CheckVariable16, CheckVariable10, CheckVariable11, NullPtr6, NullPtr1, &
        & CheckVariable9, CheckVariable12, CheckVariable13, CheckVariable15, CheckVariable14, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, NullPtr8, CheckVariable21, CheckVariable22, CheckVariable23, &
        & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_TYPE), POINTER :: " // &
      & "MESH (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_GENERATED_MESH_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_GAUSS_POINT_PARAM_TO_DOF_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_GAUSS_POINT_PARAM_TO_DOF_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers


  TYPE(FIELD_GAUSS_POINT_PARAM_TO_DOF_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GAUSS_POINT_PARAMETERS: ", &
    & Variable%NUMBER_OF_GAUSS_POINT_PARAMETERS
  
  ! Variable%GAUSS_POINTS(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GAUSS_POINTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GAUSS_POINTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "GAUSS_POINTS(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GAUSS_POINTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%GAUSS_POINTS,1), MIN(LBOUND(Variable%GAUSS_POINTS,1)+MaxArrayLength, UBOUND(Variable%GAUSS_POINTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%GAUSS_POINTS,2), MIN(LBOUND(Variable%GAUSS_POINTS,2)+MaxArrayLength, UBOUND(Variable%GAUSS_POINTS,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%GAUSS_POINTS(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "GAUSS_POINTS(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_GAUSS_POINT_PARAM_TO_DOF_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_SET_INDEPENDENT_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(EquationsSetDerivedType), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable15

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr3
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr9
  TYPE(SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr16
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr19
  TYPE(MESH_TYPE), POINTER :: NullPtr20
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr21
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr23
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr24

  TYPE(EQUATIONS_SET_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable15)) THEN
    Variable2 => CheckVariable15
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  
  ! Variable%EQUATIONS_SET
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SET)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_TYPE has the following CheckVariable types: EQUATIONS_TYPE, MESHES_TYPE, EquationsSetDerivedType, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_INDEPENDENT_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_SET
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SET"
      CALL Print_EQUATIONS_SET_TYPE(Variable% &
        & EQUATIONS_SET, CheckVariable1, NullPtr0, CheckVariable3, CheckVariable12, NullPtr1, CheckVariable13, &
        & CheckVariable8, CheckVariable9, NullPtr2, NullPtr3, CheckVariable2, NullPtr4, CheckVariable5, NullPtr5, NullPtr6, &
        & NullPtr7, NullPtr8, CheckVariable0, CheckVariable4, NullPtr9, CheckVariable6, NullPtr10, CheckVariable7, &
        & NullPtr11, NullPtr12, CheckVariable10, CheckVariable11, CheckVariable14, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "INDEPENDENT_FINISHED:                            ", &
    & Variable%INDEPENDENT_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "INDEPENDENT_FIELD_AUTO_CREATED:                  ", &
    & Variable%INDEPENDENT_FIELD_AUTO_CREATED
  
  ! Variable%INDEPENDENT_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INDEPENDENT_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "INDEPENDENT_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_INDEPENDENT_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr1 => Variable%INDEPENDENT_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INDEPENDENT_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & INDEPENDENT_FIELD, NullPtr0, NullPtr13, NullPtr14, NullPtr15, CheckVariable12, NullPtr1, NullPtr16, &
        & CheckVariable13, CheckVariable9, NullPtr17, NullPtr2, NullPtr3, NullPtr18, NullPtr19, NullPtr20, CheckVariable5, &
        & NullPtr5, NullPtr21, NullPtr6, NullPtr22, NullPtr7, NullPtr8, CheckVariable0, NullPtr23, CheckVariable6, &
        & CheckVariable10, NullPtr24, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "INDEPENDENT_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_SET_INDEPENDENT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_TO_SOLVER_MAPS_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_TO_SOLVER_MAPS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(INTERFACE_MATRICES_TYPE), POINTER :: NullPtr0
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr1
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr2
  TYPE(SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr4
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr5


  TYPE(INTERFACE_TO_SOLVER_MAPS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INTERFACE_MATRIX_NUMBER:         ", &
    & Variable%INTERFACE_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRIX_NUMBER:            ", &
    & Variable%SOLVER_MATRIX_NUMBER
  
  ! Variable%INTERFACE_MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MATRIX_TYPE), POINTER :: " // &
      & "INTERFACE_MATRIX " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_MATRIX_TYPE has the following CheckVariable types: INTERFACE_MATRICES_TYPE, 
! The type to handle in this routine is: INTERFACE_TO_SOLVER_MAPS_TYPE (Variable)
! Available CheckVariables are: 
! - signature type INTERFACE_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MATRICES_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_MATRIX"
      CALL Print_INTERFACE_MATRIX_TYPE(Variable%INTERFACE_MATRIX, NullPtr0, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MATRIX_TYPE), POINTER :: " // &
      & "INTERFACE_MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOLVER_MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MATRIX_TYPE), POINTER :: " // &
      & "SOLVER_MATRIX " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MATRIX_TYPE has the following CheckVariable types: SOLVER_MATRICES_TYPE, SOLVERS_TYPE, SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, 
! The type to handle in this routine is: INTERFACE_TO_SOLVER_MAPS_TYPE (Variable)
! Available CheckVariables are: 
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MATRIX"
      CALL Print_SOLVER_MATRIX_TYPE(Variable% &
        & SOLVER_MATRIX, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MATRIX_TYPE), POINTER :: " // &
      & "SOLVER_MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE_ROW_TO_SOLVER_COLS_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_ROW_TO_SOLVER_COLS_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_ROW_TO_SOLVER_COLS_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_ROW_TO_SOLVER_COLS_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_ROW_TO_SOLVER_COLS_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_ROW_TO_SOLVER_COLS_MAP,1), MIN(LBOUND(Variable% &
      & INTERFACE_ROW_TO_SOLVER_COLS_MAP,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_ROW_TO_SOLVER_COLS_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_TO_SOLVER_MAPS_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_ROW_TO_SOLVER_COLS_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE(Variable% &
          & INTERFACE_ROW_TO_SOLVER_COLS_MAP(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_ROW_TO_SOLVER_COLS_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_INTERFACE_TO_SOLVER_MAPS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_ROW_TO_EQUATIONS_MAPS_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_ROW_TO_EQUATIONS_MAPS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(SOLVER_ROW_TO_EQUATIONS_MAPS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_EQUATIONS_SET_ROWS:    ", &
    & Variable%NUMBER_OF_EQUATIONS_SET_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INTERFACE_CONDITION_INDEX:       ", &
    & Variable%INTERFACE_CONDITION_INDEX
  
  ! Variable%EQUATIONS_INDEX(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_INDEX)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_INDEX),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_INDEX(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_INDEX, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_INDEX,1), MIN(LBOUND(Variable%EQUATIONS_INDEX,1)+MaxArrayLength, UBOUND(Variable% &
      & EQUATIONS_INDEX,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_INDEX(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_INDEX(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ROWCOL_NUMBER(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ROWCOL_NUMBER)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ROWCOL_NUMBER),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ROWCOL_NUMBER(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ROWCOL_NUMBER, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ROWCOL_NUMBER,1), MIN(LBOUND(Variable%ROWCOL_NUMBER,1)+MaxArrayLength, UBOUND(Variable%ROWCOL_NUMBER,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ROWCOL_NUMBER(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ROWCOL_NUMBER(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COUPLING_COEFFICIENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COUPLING_COEFFICIENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COUPLING_COEFFICIENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COUPLING_COEFFICIENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COUPLING_COEFFICIENTS,1), MIN(LBOUND(Variable% &
      & COUPLING_COEFFICIENTS,1)+MaxArrayLength, UBOUND(Variable%COUPLING_COEFFICIENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COUPLING_COEFFICIENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_SOLVER_ROW_TO_EQUATIONS_MAPS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_InterfacePointsConnectivityType(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
  & CheckVariable24, Depth, MaxDepth, MaxArrayLength)
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable24

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr4
  TYPE(MeshComponentTopologyType), POINTER :: NullPtr5
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: NullPtr6
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: NullPtr7
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr8
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr9
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr11
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: NullPtr12

  TYPE(INTERFACE_TYPE), POINTER :: Ptr0
  TYPE(MESH_TYPE), POINTER :: Ptr1

  TYPE(InterfacePointsConnectivityType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)

  
  ! Variable%interface
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%interface)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "interface " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: InterfacePointsConnectivityType (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_PTR_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), CELLML_ENVIRONMENTS_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), MeshComponentTopologyPtrType (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), INTERFACES_TYPE (CheckVariable19), DATA_POINTS_TYPE (CheckVariable20), GENERATED_MESH_PTR_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), DECOMPOSITION_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   is type of this print routine, use Variable2
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable24

    ! if variable was already followed
    Ptr0 => Variable%interface
    IF (ASSOCIATED(Ptr0, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"interface"
      CALL Print_INTERFACE_TYPE(Variable% &
        & interface, NullPtr0, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, &
        & CheckVariable5, CheckVariable6, Variable2, NullPtr1, CheckVariable8, CheckVariable9, CheckVariable10, &
        & CheckVariable11, NullPtr2, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
        & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, NullPtr3, &
        & CheckVariable23, NullPtr4, CheckVariable24, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "interface (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%interfaceMesh
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%interfaceMesh)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_TYPE), POINTER :: " // &
      & "interfaceMesh " // &
      & "(associated): " 
  
! Signature of Print_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, REGION_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: InterfacePointsConnectivityType (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_PTR_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), CELLML_ENVIRONMENTS_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), MeshComponentTopologyPtrType (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), INTERFACES_TYPE (CheckVariable19), DATA_POINTS_TYPE (CheckVariable20), GENERATED_MESH_PTR_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), DECOMPOSITION_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_CYLINDER_TYPE
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_ELLIPSOID_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable14
! - signature type InterfacePointsConnectivityType
!   is type of this print routine, use Variable2
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable13
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_REGULAR_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable24

    ! if variable was already followed
    Ptr1 => Variable%interfaceMesh
    IF (ASSOCIATED(Ptr1, CheckVariable13)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"interfaceMesh"
      CALL Print_MESH_TYPE(Variable% &
        & interfaceMesh, NullPtr5, CheckVariable0, NullPtr6, CheckVariable1, CheckVariable2, NullPtr7, NullPtr8, &
        & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable14, Variable2, CheckVariable8, NullPtr9, &
        & CheckVariable9, CheckVariable6, CheckVariable10, CheckVariable11, CheckVariable13, NullPtr10, CheckVariable15, &
        & CheckVariable16, CheckVariable17, CheckVariable18, NullPtr11, CheckVariable19, CheckVariable20, CheckVariable21, &
        & CheckVariable22, NullPtr12, CheckVariable23, CheckVariable24, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_TYPE), POINTER :: " // &
      & "interfaceMesh (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "pointsConnectivityFinished:                      ", &
    & Variable%pointsConnectivityFinished
  
  ! Variable%pointsConnectivity(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%pointsConnectivity)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%pointsConnectivity),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(InterfacePointConnectivityType), ALLOCATABLE :: " // &
      & "pointsConnectivity(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%pointsConnectivity, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%pointsConnectivity,1), MIN(LBOUND(Variable% &
      & pointsConnectivity,1)+MaxArrayLength, UBOUND(Variable%pointsConnectivity,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%pointsConnectivity,2), MIN(LBOUND(Variable% &
        & pointsConnectivity,2)+MaxArrayLength, UBOUND(Variable%pointsConnectivity,2))
        WRITE(I1_STR,"(I4)") I1 

! Signature of Print_InterfacePointConnectivityType has the following CheckVariable types: 
! The type to handle in this routine is: InterfacePointsConnectivityType (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_PTR_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), CELLML_ENVIRONMENTS_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), MeshComponentTopologyPtrType (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), INTERFACES_TYPE (CheckVariable19), DATA_POINTS_TYPE (CheckVariable20), GENERATED_MESH_PTR_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), DECOMPOSITION_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
          PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"pointsConnectivity("//TRIM(ADJUSTL(I0_STR))//"," // &
            & ""//TRIM(ADJUSTL(I1_STR))//")"
          CALL Print_InterfacePointConnectivityType(Variable%pointsConnectivity(I0,I1), Depth+1, MaxDepth, MaxArrayLength)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(InterfacePointConnectivityType), ALLOCATABLE :: " // &
      & "pointsConnectivity(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%coupledElements(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%coupledElements)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%coupledElements),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(InterfaceCoupledElementsType), ALLOCATABLE :: " // &
      & "coupledElements(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%coupledElements, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%coupledElements,1), MIN(LBOUND(Variable%coupledElements,1)+MaxArrayLength, UBOUND(Variable% &
      & coupledElements,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%coupledElements,2), MIN(LBOUND(Variable%coupledElements,2)+MaxArrayLength, UBOUND(Variable% &
        & coupledElements,2))
        WRITE(I1_STR,"(I4)") I1 

! Signature of Print_InterfaceCoupledElementsType has the following CheckVariable types: 
! The type to handle in this routine is: InterfacePointsConnectivityType (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_PTR_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), CELLML_ENVIRONMENTS_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), MeshComponentTopologyPtrType (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), DECOMPOSITIONS_TYPE (CheckVariable17), NODES_TYPE (CheckVariable18), INTERFACES_TYPE (CheckVariable19), DATA_POINTS_TYPE (CheckVariable20), GENERATED_MESH_PTR_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), DECOMPOSITION_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
          PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"coupledElements("//TRIM(ADJUSTL(I0_STR))//"," // &
            & ""//TRIM(ADJUSTL(I1_STR))//")"
          CALL Print_InterfaceCoupledElementsType(Variable%coupledElements(I0,I1), Depth+1, MaxDepth, MaxArrayLength)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(InterfaceCoupledElementsType), ALLOCATABLE :: " // &
      & "coupledElements(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%maxNumberOfCoupledElements(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%maxNumberOfCoupledElements)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%maxNumberOfCoupledElements),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "maxNumberOfCoupledElements(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%maxNumberOfCoupledElements, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%maxNumberOfCoupledElements,1), MIN(LBOUND(Variable% &
      & maxNumberOfCoupledElements,1)+MaxArrayLength, UBOUND(Variable%maxNumberOfCoupledElements,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%maxNumberOfCoupledElements(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "maxNumberOfCoupledElements(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_InterfacePointsConnectivityType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_RUSH_LARSON_DAE_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, Depth, MaxDepth, MaxArrayLength)
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable19

  ! iterator variables

  ! null pointers
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr0
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr6
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr8
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr10
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(HISTORY_TYPE), POINTER :: NullPtr13
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr14
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr15
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr16

  TYPE(DAE_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable18)) THEN
    Variable2 => CheckVariable18
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)

  
  ! Variable%DAE_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DAE_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_DAE_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: RUSH_LARSON_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), CELLML_EQUATIONS_TYPE (CheckVariable2), SOLVERS_TYPE (CheckVariable3), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable4), SOLVER_TYPE (CheckVariable5), GeometricTransformationSolverType (CheckVariable6), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable7), EULER_DAE_SOLVER_TYPE (CheckVariable8), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable9), LINEAR_SOLVER_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), BDF_DAE_SOLVER_TYPE (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable18), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable19), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BACKWARD_EULER_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type FORWARD_EULER_DAE_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable6
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type IMPROVED_EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DAE_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DAE_SOLVER"
      CALL Print_DAE_SOLVER_TYPE(Variable% &
        & DAE_SOLVER, CheckVariable16, NullPtr0, Variable2, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, NullPtr4, &
        & NullPtr5, NullPtr6, CheckVariable7, CheckVariable19, CheckVariable12, NullPtr7, NullPtr8, CheckVariable14, &
        & CheckVariable15, NullPtr9, CheckVariable6, CheckVariable17, NullPtr10, CheckVariable2, CheckVariable13, &
        & CheckVariable9, CheckVariable11, NullPtr11, NullPtr12, NullPtr13, CheckVariable0, CheckVariable3, CheckVariable4, &
        & CheckVariable5, NullPtr14, CheckVariable8, CheckVariable10, NullPtr15, NullPtr16, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)

  
END SUBROUTINE Print_RUSH_LARSON_DAE_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MESH_ELEMENT_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(MESH_ELEMENT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers
  TYPE(BASIS_TYPE), POINTER :: NullPtr0
  TYPE(BASIS_PTR_TYPE), POINTER :: NullPtr1


  TYPE(MESH_ELEMENT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  
  ! Variable%BASIS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%BASIS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_TYPE), POINTER :: " // &
      & "BASIS " // &
      & "(associated): " 
  
! Signature of Print_BASIS_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: MESH_ELEMENT_TYPE (Variable)
! Available CheckVariables are: 
! - signature type BASIS_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_TYPE
! - signature type BASIS_PTR_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_PTR_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BASIS"
      CALL Print_BASIS_TYPE(Variable%BASIS, NullPtr0, NullPtr1, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_TYPE), POINTER :: " // &
      & "BASIS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MESH_ELEMENT_NODES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MESH_ELEMENT_NODES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MESH_ELEMENT_NODES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "MESH_ELEMENT_NODES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MESH_ELEMENT_NODES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%MESH_ELEMENT_NODES,1), MIN(LBOUND(Variable% &
      & MESH_ELEMENT_NODES,1)+MaxArrayLength, UBOUND(Variable%MESH_ELEMENT_NODES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%MESH_ELEMENT_NODES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "MESH_ELEMENT_NODES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%GLOBAL_ELEMENT_NODES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GLOBAL_ELEMENT_NODES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GLOBAL_ELEMENT_NODES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "GLOBAL_ELEMENT_NODES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GLOBAL_ELEMENT_NODES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%GLOBAL_ELEMENT_NODES,1), MIN(LBOUND(Variable% &
      & GLOBAL_ELEMENT_NODES,1)+MaxArrayLength, UBOUND(Variable%GLOBAL_ELEMENT_NODES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%GLOBAL_ELEMENT_NODES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "GLOBAL_ELEMENT_NODES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%USER_ELEMENT_NODE_VERSIONS(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%USER_ELEMENT_NODE_VERSIONS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%USER_ELEMENT_NODE_VERSIONS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "USER_ELEMENT_NODE_VERSIONS(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%USER_ELEMENT_NODE_VERSIONS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%USER_ELEMENT_NODE_VERSIONS,1), MIN(LBOUND(Variable% &
      & USER_ELEMENT_NODE_VERSIONS,1)+MaxArrayLength, UBOUND(Variable%USER_ELEMENT_NODE_VERSIONS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%USER_ELEMENT_NODE_VERSIONS,2), MIN(LBOUND(Variable% &
        & USER_ELEMENT_NODE_VERSIONS,2)+MaxArrayLength, UBOUND(Variable%USER_ELEMENT_NODE_VERSIONS,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%USER_ELEMENT_NODE_VERSIONS(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "USER_ELEMENT_NODE_VERSIONS(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%USER_ELEMENT_NODES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%USER_ELEMENT_NODES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%USER_ELEMENT_NODES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "USER_ELEMENT_NODES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%USER_ELEMENT_NODES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%USER_ELEMENT_NODES,1), MIN(LBOUND(Variable% &
      & USER_ELEMENT_NODES,1)+MaxArrayLength, UBOUND(Variable%USER_ELEMENT_NODES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%USER_ELEMENT_NODES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "USER_ELEMENT_NODES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ADJACENT_ELEMENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ADJACENT_ELEMENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ADJACENT_ELEMENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_ADJACENT_ELEMENT_TYPE), ALLOCATABLE :: " // &
      & "ADJACENT_ELEMENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ADJACENT_ELEMENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%ADJACENT_ELEMENTS,1), MIN(LBOUND(Variable%ADJACENT_ELEMENTS,1)+MaxArrayLength, UBOUND(Variable% &
      & ADJACENT_ELEMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_MESH_ADJACENT_ELEMENT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: MESH_ELEMENT_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ADJACENT_ELEMENTS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_MESH_ADJACENT_ELEMENT_TYPE(Variable%ADJACENT_ELEMENTS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_ADJACENT_ELEMENT_TYPE), ALLOCATABLE :: " // &
      & "ADJACENT_ELEMENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "BOUNDARY_ELEMENT:                                ", &
    & Variable%BOUNDARY_ELEMENT

  
END SUBROUTINE Print_MESH_ELEMENT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BACKWARD_EULER_DAE_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, Depth, MaxDepth, MaxArrayLength)
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13

  ! iterator variables

  ! null pointers
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr4
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr8

  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable9)) THEN
    Variable2 => CheckVariable9
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)

  
  ! Variable%EULER_DAE_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EULER_DAE_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "EULER_DAE_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_EULER_DAE_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, EXTERNAL_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: BACKWARD_EULER_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable4), EULER_DAE_SOLVER_TYPE (CheckVariable5), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable6), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable7), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable8), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_TYPE (CheckVariable10), BDF_DAE_SOLVER_TYPE (CheckVariable11), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable5
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13

    ! if variable was already followed
    Ptr0 => Variable%EULER_DAE_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EULER_DAE_SOLVER"
      CALL Print_EULER_DAE_SOLVER_TYPE(Variable% &
        & EULER_DAE_SOLVER, CheckVariable11, CheckVariable7, CheckVariable12, NullPtr0, CheckVariable4, NullPtr1, &
        & Variable2, CheckVariable10, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, CheckVariable6, NullPtr7, &
        & CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable5, NullPtr8, CheckVariable8, &
        & CheckVariable13, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "EULER_DAE_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)

  
END SUBROUTINE Print_BACKWARD_EULER_DAE_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_VECTOR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(VECTOR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(VECTOR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ID:                              ", &
    & Variable%ID
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "VECTOR_FINISHED:                                 ", &
    & Variable%VECTOR_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "N:                               ", &
    & Variable%N
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DATA_TYPE:                       ", &
    & Variable%DATA_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SIZE:                            ", &
    & Variable%SIZE
  
  ! Variable%DATA_INTG(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_INTG)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_INTG),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DATA_INTG(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_INTG, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_INTG,1), MIN(LBOUND(Variable%DATA_INTG,1)+MaxArrayLength, UBOUND(Variable%DATA_INTG,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_INTG(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DATA_INTG(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_SP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_SP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_SP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(SP), ALLOCATABLE :: " // &
      & "DATA_SP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_SP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(SP), ALLOCATABLE :: " // &
      & "DATA_SP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_DP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_DP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_DP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "DATA_DP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_DP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_DP,1), MIN(LBOUND(Variable%DATA_DP,1)+MaxArrayLength, UBOUND(Variable%DATA_DP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_DP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "DATA_DP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_L(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_L)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_L),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "DATA_L(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_L, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_L,1), MIN(LBOUND(Variable%DATA_L,1)+MaxArrayLength, UBOUND(Variable%DATA_L,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_L(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "DATA_L(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_VECTOR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_REGION_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable24

  ! iterator variables

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr2
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr3
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr4
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr6

  TYPE(REGION_TYPE), POINTER :: Ptr0

  TYPE(REGION_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable6)) THEN
    Variable2 => CheckVariable6
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: REGION_PTR_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), NODES_TYPE (CheckVariable17), INTERFACES_TYPE (CheckVariable18), DATA_POINTS_TYPE (CheckVariable19), GENERATED_MESH_PTR_TYPE (CheckVariable20), DATA_PROJECTION_TYPE (CheckVariable21), DECOMPOSITION_TYPE (CheckVariable22), EQUATIONS_SET_PTR_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   is type of this print routine, use Variable2
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable24

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable24)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_REGION_TYPE(Variable% &
        & PTR, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr0, CheckVariable3, CheckVariable4, CheckVariable5, &
        & Variable2, CheckVariable7, CheckVariable8, CheckVariable9, NullPtr1, CheckVariable10, CheckVariable11, &
        & CheckVariable12, NullPtr2, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, NullPtr3, &
        & CheckVariable17, NullPtr4, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, NullPtr5, &
        & CheckVariable22, CheckVariable23, NullPtr6, CheckVariable24, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_REGION_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_GeometricTransformationSolverType(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
  & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, &
  & CheckVariable31, CheckVariable32, CheckVariable33, CheckVariable34, Depth, MaxDepth, MaxArrayLength)
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable31
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable32
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable33
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable34

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1, I2
  CHARACTER(LEN=30) :: I0_STR, I1_STR, I2_STR

  ! null pointers
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr1
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr5
  TYPE(MESHES_TYPE), POINTER :: NullPtr6
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr9
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr10
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr11
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr14
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr15
  TYPE(CELLML_TYPE), POINTER :: NullPtr16
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr17
  TYPE(MESH_TYPE), POINTER :: NullPtr18
  TYPE(FIELDS_TYPE), POINTER :: NullPtr19
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr20
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr21
  TYPE(NODES_TYPE), POINTER :: NullPtr22
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr23
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr24
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr25
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr26
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr27
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr28
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr29
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr30
  TYPE(REGION_TYPE), POINTER :: NullPtr31

  TYPE(SOLVER_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(GeometricTransformationSolverType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable17)) THEN
    Variable2 => CheckVariable17
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)
  Nullify(NullPtr29)
  Nullify(NullPtr30)
  Nullify(NullPtr31)

  
  ! Variable%solver
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%solver)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "solver " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: GeometricTransformationSolverType (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), QUASI_NEWTON_SOLVER_TYPE (CheckVariable6), NONLINEAR_SOLVER_TYPE (CheckVariable7), NEWTON_SOLVER_TYPE (CheckVariable8), CONTROL_LOOP_FIXED_TYPE (CheckVariable9), CONTROL_LOOP_TIME_TYPE (CheckVariable10), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable11), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable12), OPTIMISER_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), GeometricTransformationSolverType (CheckVariable17), PROBLEM_TYPE (CheckVariable18), BOUNDARY_CONDITIONS_TYPE (CheckVariable19), CELLML_EQUATIONS_TYPE (CheckVariable20), CONTROL_LOOP_TYPE (CheckVariable21), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable22), SOLVER_EQUATIONS_TYPE (CheckVariable23), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable24), SOLVER_MATRICES_TYPE (CheckVariable25), HISTORY_TYPE (CheckVariable26), DAE_SOLVER_TYPE (CheckVariable27), SOLVERS_TYPE (CheckVariable28), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable29), SOLVER_TYPE (CheckVariable30), SOLVER_MAPPING_TYPE (CheckVariable31), EULER_DAE_SOLVER_TYPE (CheckVariable32), LINEAR_SOLVER_TYPE (CheckVariable33), EIGENPROBLEM_SOLVER_TYPE (CheckVariable34), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GeometricTransformationSolverType
!   is type of this print routine, use Variable2
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable30
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable18

    ! if variable was already followed
    Ptr0 => Variable%solver
    IF (ASSOCIATED(Ptr0, CheckVariable30)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"solver"
      CALL Print_SOLVER_TYPE(Variable% &
        & solver, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, NullPtr0, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, Variable2, CheckVariable34, &
        & CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, NullPtr1, CheckVariable23, NullPtr2, &
        & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, &
        & CheckVariable30, NullPtr3, NullPtr4, CheckVariable31, CheckVariable32, NullPtr5, CheckVariable33, &
        & CheckVariable18, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "solver (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "arbitraryPath:                                   ", &
    & Variable%arbitraryPath
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfIncrements:              ", &
    & Variable%numberOfIncrements
  
  ! Variable%scalings(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%scalings)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%scalings),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "scalings(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%scalings, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%scalings,1), MIN(LBOUND(Variable%scalings,1)+MaxArrayLength, UBOUND(Variable%scalings,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%scalings(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "scalings(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%transformationMatrices(:,:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%transformationMatrices)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%transformationMatrices),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "transformationMatrices(:,:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%transformationMatrices, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%transformationMatrices,1), MIN(LBOUND(Variable% &
      & transformationMatrices,1)+MaxArrayLength, UBOUND(Variable%transformationMatrices,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%transformationMatrices,2), MIN(LBOUND(Variable% &
        & transformationMatrices,2)+MaxArrayLength, UBOUND(Variable%transformationMatrices,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//","//TRIM(ADJUSTL(I1_STR))//",*): "
        DO I2 = LBOUND(Variable%transformationMatrices,3), MIN(LBOUND(Variable% &
          & transformationMatrices,3)+MaxArrayLength, UBOUND(Variable%transformationMatrices,3))
          WRITE(I2_STR,"(I4)") I2 

          PRINT*, TRIM(PrintIndent), Variable%transformationMatrices(I0,I1,I2)

        ENDDO  ! I2
      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "transformationMatrices(:,:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%field
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%field)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "field " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: GeometricTransformationSolverType (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), QUASI_NEWTON_SOLVER_TYPE (CheckVariable6), NONLINEAR_SOLVER_TYPE (CheckVariable7), NEWTON_SOLVER_TYPE (CheckVariable8), CONTROL_LOOP_FIXED_TYPE (CheckVariable9), CONTROL_LOOP_TIME_TYPE (CheckVariable10), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable11), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable12), OPTIMISER_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), GeometricTransformationSolverType (CheckVariable17), PROBLEM_TYPE (CheckVariable18), BOUNDARY_CONDITIONS_TYPE (CheckVariable19), CELLML_EQUATIONS_TYPE (CheckVariable20), CONTROL_LOOP_TYPE (CheckVariable21), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable22), SOLVER_EQUATIONS_TYPE (CheckVariable23), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable24), SOLVER_MATRICES_TYPE (CheckVariable25), HISTORY_TYPE (CheckVariable26), DAE_SOLVER_TYPE (CheckVariable27), SOLVERS_TYPE (CheckVariable28), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable29), SOLVER_TYPE (CheckVariable30), SOLVER_MAPPING_TYPE (CheckVariable31), EULER_DAE_SOLVER_TYPE (CheckVariable32), LINEAR_SOLVER_TYPE (CheckVariable33), EIGENPROBLEM_SOLVER_TYPE (CheckVariable34), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr1 => Variable%field
    IF (ASSOCIATED(Ptr1, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"field"
      CALL Print_FIELD_TYPE(Variable% &
        & field, NullPtr6, NullPtr7, NullPtr8, NullPtr9, CheckVariable2, NullPtr10, NullPtr11, NullPtr12, NullPtr13, &
        & NullPtr14, NullPtr15, CheckVariable21, NullPtr16, NullPtr17, NullPtr18, NullPtr19, NullPtr20, NullPtr21, &
        & NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, NullPtr29, NullPtr30, NullPtr31, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "field (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "fieldVariableType:               ", &
    & Variable%fieldVariableType

  
END SUBROUTINE Print_GeometricTransformationSolverType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_MATRIX_TO_VAR_MAP_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_MATRIX_TO_VAR_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(INTERFACE_MATRICES_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr1
  TYPE(MESHES_TYPE), POINTER :: NullPtr2
  TYPE(EquationsSetDerivedType), POINTER :: NullPtr3
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr4
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr5
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr8
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr10
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr11
  TYPE(FIELDS_TYPE), POINTER :: NullPtr12
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr13
  TYPE(NODES_TYPE), POINTER :: NullPtr14
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr15
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr16
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr17
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: NullPtr18
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr19
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr20
  TYPE(SOLVER_TYPE), POINTER :: NullPtr21
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: NullPtr22
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr23
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr24
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr25
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr26
  TYPE(REGION_TYPE), POINTER :: NullPtr27
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: NullPtr28
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: NullPtr29
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr30
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: NullPtr31
  TYPE(INTERFACE_PENALTY_TYPE), POINTER :: NullPtr32
  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: NullPtr33
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr34
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr35
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr36
  TYPE(CELLML_TYPE), POINTER :: NullPtr37
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr38

  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: Ptr0

  TYPE(INTERFACE_MATRIX_TO_VAR_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)
  Nullify(NullPtr29)
  Nullify(NullPtr30)
  Nullify(NullPtr31)
  Nullify(NullPtr32)
  Nullify(NullPtr33)
  Nullify(NullPtr34)
  Nullify(NullPtr35)
  Nullify(NullPtr36)
  Nullify(NullPtr37)
  Nullify(NullPtr38)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MATRIX_NUMBER:                   ", &
    & Variable%MATRIX_NUMBER
  
  ! Variable%INTERFACE_MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MATRIX_TYPE), POINTER :: " // &
      & "INTERFACE_MATRIX " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_MATRIX_TYPE has the following CheckVariable types: INTERFACE_MATRICES_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRIX_TO_VAR_MAP_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MAPPING_TYPE (CheckVariable0), INTERFACE_CONDITION_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), INTERFACE_EQUATIONS_TYPE (CheckVariable3), 
! - signature type INTERFACE_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MATRICES_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_MATRIX"
      CALL Print_INTERFACE_MATRIX_TYPE(Variable%INTERFACE_MATRIX, NullPtr0, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MATRIX_TYPE), POINTER :: " // &
      & "INTERFACE_MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%EQUATIONS_SET
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SET)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_TYPE has the following CheckVariable types: EQUATIONS_TYPE, MESHES_TYPE, EquationsSetDerivedType, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRIX_TO_VAR_MAP_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MAPPING_TYPE (CheckVariable0), INTERFACE_CONDITION_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), INTERFACE_EQUATIONS_TYPE (CheckVariable3), 
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type EquationsSetDerivedType
!   is not available in passing variables, use NullPtr of type EquationsSetDerivedType
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_MATERIALS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_ANALYTIC_TYPE
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_SOURCE_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_INDEPENDENT_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SET"
      CALL Print_EQUATIONS_SET_TYPE(Variable% &
        & EQUATIONS_SET, NullPtr1, NullPtr2, NullPtr3, CheckVariable2, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, &
        & NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, NullPtr18, &
        & NullPtr19, NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, &
        & Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE_EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_EQUATIONS_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_LAGRANGE_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_MATRICES_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, INTERFACE_MAPPING_TYPE, INTERFACE_PENALTY_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_EQUATIONS_INTERPOLATION_TYPE, INTERFACE_CONDITION_PTR_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRIX_TO_VAR_MAP_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MAPPING_TYPE (CheckVariable0), INTERFACE_CONDITION_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), INTERFACE_EQUATIONS_TYPE (CheckVariable3), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_LAGRANGE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_LAGRANGE_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type INTERFACE_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MATRICES_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable3
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type INTERFACE_DEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_DEPENDENT_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type INTERFACE_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type INTERFACE_PENALTY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PENALTY_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_EQUATIONS_INTERPOLATION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_INTERPOLATION_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_EQUATIONS
    IF (ASSOCIATED(Ptr0, CheckVariable3)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_EQUATIONS"
      CALL Print_INTERFACE_EQUATIONS_TYPE(Variable% &
        & INTERFACE_EQUATIONS, CheckVariable1, NullPtr29, NullPtr11, NullPtr0, CheckVariable3, NullPtr12, NullPtr30, &
        & NullPtr21, NullPtr31, NullPtr23, CheckVariable0, NullPtr32, NullPtr26, CheckVariable2, NullPtr33, NullPtr34, &
        & NullPtr7, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "VARIABLE_TYPE:                   ", &
    & Variable%VARIABLE_TYPE
  
  ! Variable%VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRIX_TO_VAR_MAP_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MAPPING_TYPE (CheckVariable0), INTERFACE_CONDITION_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), INTERFACE_EQUATIONS_TYPE (CheckVariable3), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & VARIABLE, NullPtr17, NullPtr35, NullPtr2, NullPtr12, NullPtr20, NullPtr4, NullPtr36, NullPtr13, NullPtr37, &
        & NullPtr38, CheckVariable2, NullPtr15, NullPtr7, NullPtr8, NullPtr14, NullPtr5, NullPtr27, NullPtr16, Depth+1, &
        & MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MESH_INDEX:                      ", &
    & Variable%MESH_INDEX
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "MATRIX_COEFFICIENT:          ", &
    & Variable%MATRIX_COEFFICIENT
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "HAS_TRANSPOSE:                                   ", &
    & Variable%HAS_TRANSPOSE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ROWS:                  ", &
    & Variable%NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_ROWS:            ", &
    & Variable%TOTAL_NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_ROWS:           ", &
    & Variable%NUMBER_OF_GLOBAL_ROWS
  
  ! Variable%ROW_DOFS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ROW_DOFS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "ROW_DOFS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_MATRIX_TO_VAR_MAP_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MAPPING_TYPE (CheckVariable0), INTERFACE_CONDITION_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), INTERFACE_EQUATIONS_TYPE (CheckVariable3), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ROW_DOFS_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%ROW_DOFS_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "ROW_DOFS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%VARIABLE_DOF_TO_ROW_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLE_DOF_TO_ROW_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLE_DOF_TO_ROW_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "VARIABLE_DOF_TO_ROW_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLE_DOF_TO_ROW_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%VARIABLE_DOF_TO_ROW_MAP,1), MIN(LBOUND(Variable% &
      & VARIABLE_DOF_TO_ROW_MAP,1)+MaxArrayLength, UBOUND(Variable%VARIABLE_DOF_TO_ROW_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%VARIABLE_DOF_TO_ROW_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "VARIABLE_DOF_TO_ROW_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_INTERFACE_MATRIX_TO_VAR_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CELLML_MODEL_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable22

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr3
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr4
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr5
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr8
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr9
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr11
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr12
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr13
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr14

  TYPE(REGION_TYPE), POINTER :: Ptr0
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: Ptr1
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: Ptr2
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: Ptr3
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: Ptr4
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: Ptr5
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: Ptr6

  TYPE(CELLML_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable9)) THEN
    Variable2 => CheckVariable9
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)

  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), REGION_PTR_TYPE (CheckVariable2), CELLML_MODELS_FIELD_TYPE (CheckVariable3), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), DOMAIN_TYPE (CheckVariable6), CELLML_ENVIRONMENTS_TYPE (CheckVariable7), CELLML_STATE_FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), FIELDS_TYPE (CheckVariable11), CELLML_FIELD_MAPS_TYPE (CheckVariable12), CELLML_MODEL_TYPE (CheckVariable13), GENERATED_MESHES_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is type of this print routine, use Variable2
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable22

    ! if variable was already followed
    Ptr0 => Variable%REGION
    IF (ASSOCIATED(Ptr0, CheckVariable22)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, CheckVariable0, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, CheckVariable1, CheckVariable2, &
        & NullPtr5, NullPtr6, CheckVariable5, CheckVariable6, NullPtr7, NullPtr8, CheckVariable7, NullPtr9, Variable2, &
        & CheckVariable10, CheckVariable11, CheckVariable14, NullPtr10, CheckVariable15, NullPtr11, CheckVariable16, &
        & CheckVariable17, NullPtr12, CheckVariable18, NullPtr13, CheckVariable20, NullPtr14, CheckVariable21, &
        & CheckVariable22, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  
  ! Variable%ENVIRONMENTS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ENVIRONMENTS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: " // &
      & "ENVIRONMENTS " // &
      & "(associated): " 
  
! Signature of Print_CELLML_ENVIRONMENTS_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, InterfacePointsConnectivityType, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, DATA_POINTS_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), REGION_PTR_TYPE (CheckVariable2), CELLML_MODELS_FIELD_TYPE (CheckVariable3), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), DOMAIN_TYPE (CheckVariable6), CELLML_ENVIRONMENTS_TYPE (CheckVariable7), CELLML_STATE_FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), FIELDS_TYPE (CheckVariable11), CELLML_FIELD_MAPS_TYPE (CheckVariable12), CELLML_MODEL_TYPE (CheckVariable13), GENERATED_MESHES_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable7
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_TYPE
!   is type of this print routine, use Variable2
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable22

    ! if variable was already followed
    Ptr1 => Variable%ENVIRONMENTS
    IF (ASSOCIATED(Ptr1, CheckVariable7)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ENVIRONMENTS"
      CALL Print_CELLML_ENVIRONMENTS_TYPE(Variable% &
        & ENVIRONMENTS, CheckVariable0, NullPtr0, NullPtr1, NullPtr3, NullPtr4, CheckVariable1, CheckVariable2, &
        & CheckVariable3, NullPtr6, CheckVariable5, NullPtr5, CheckVariable6, NullPtr7, NullPtr8, CheckVariable7, &
        & CheckVariable8, Variable2, CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable14, CheckVariable15, &
        & CheckVariable16, CheckVariable4, NullPtr12, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable17, &
        & NullPtr14, CheckVariable21, CheckVariable22, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: " // &
      & "ENVIRONMENTS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "CELLML_FINISHED:                                 ", &
    & Variable%CELLML_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_MODELS:                ", &
    & Variable%NUMBER_OF_MODELS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_STATE:         ", &
    & Variable%MAXIMUM_NUMBER_OF_STATE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_PARAMETERS:    ", &
    & Variable%MAXIMUM_NUMBER_OF_PARAMETERS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_INTERMEDIATE:  ", &
    & Variable%MAXIMUM_NUMBER_OF_INTERMEDIATE
  
  ! Variable%MODELS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MODELS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MODELS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_MODEL_PTR_TYPE), ALLOCATABLE :: " // &
      & "MODELS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MODELS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%MODELS,1), MIN(LBOUND(Variable%MODELS,1)+MaxArrayLength, UBOUND(Variable%MODELS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_CELLML_MODEL_PTR_TYPE has the following CheckVariable types: CELLML_PARAMETERS_FIELD_TYPE, CELLML_FIELD_MAPS_TYPE, CELLML_MODEL_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, FIELD_TYPE, CELLML_TYPE, CELLML_MODELS_FIELD_TYPE, REGION_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, 
! The type to handle in this routine is: CELLML_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), REGION_PTR_TYPE (CheckVariable2), CELLML_MODELS_FIELD_TYPE (CheckVariable3), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), DOMAIN_TYPE (CheckVariable6), CELLML_ENVIRONMENTS_TYPE (CheckVariable7), CELLML_STATE_FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), FIELDS_TYPE (CheckVariable11), CELLML_FIELD_MAPS_TYPE (CheckVariable12), CELLML_MODEL_TYPE (CheckVariable13), GENERATED_MESHES_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_MODEL_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CELLML_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MODELS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_CELLML_MODEL_PTR_TYPE(Variable% &
          & MODELS(I0), CheckVariable19, CheckVariable12, CheckVariable13, CheckVariable7, CheckVariable8, CheckVariable1, &
          & Variable2, CheckVariable3, CheckVariable22, CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_MODEL_PTR_TYPE), ALLOCATABLE :: " // &
      & "MODELS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%FIELD_MAPS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELD_MAPS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: " // &
      & "FIELD_MAPS " // &
      & "(associated): " 
  
! Signature of Print_CELLML_FIELD_MAPS_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, MESH_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, CELLML_FIELD_MAPS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, FIELD_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, CELLML_MODELS_FIELD_TYPE, REGION_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, 
! The type to handle in this routine is: CELLML_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), REGION_PTR_TYPE (CheckVariable2), CELLML_MODELS_FIELD_TYPE (CheckVariable3), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), DOMAIN_TYPE (CheckVariable6), CELLML_ENVIRONMENTS_TYPE (CheckVariable7), CELLML_STATE_FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), FIELDS_TYPE (CheckVariable11), CELLML_FIELD_MAPS_TYPE (CheckVariable12), CELLML_MODEL_TYPE (CheckVariable13), GENERATED_MESHES_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CELLML_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable4

    ! if variable was already followed
    Ptr2 => Variable%FIELD_MAPS
    IF (ASSOCIATED(Ptr2, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELD_MAPS"
      CALL Print_CELLML_FIELD_MAPS_TYPE(Variable% &
        & FIELD_MAPS, CheckVariable18, CheckVariable19, CheckVariable10, CheckVariable6, CheckVariable11, CheckVariable20, &
        & CheckVariable12, CheckVariable5, CheckVariable7, CheckVariable8, CheckVariable1, Variable2, CheckVariable21, &
        & CheckVariable3, CheckVariable22, CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: " // &
      & "FIELD_MAPS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MODELS_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MODELS_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: " // &
      & "MODELS_FIELD " // &
      & "(associated): " 
  
! Signature of Print_CELLML_MODELS_FIELD_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, CELLML_FIELD_MAPS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, FIELD_TYPE, CELLML_TYPE, CELLML_MODELS_FIELD_TYPE, REGION_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, 
! The type to handle in this routine is: CELLML_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), REGION_PTR_TYPE (CheckVariable2), CELLML_MODELS_FIELD_TYPE (CheckVariable3), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), DOMAIN_TYPE (CheckVariable6), CELLML_ENVIRONMENTS_TYPE (CheckVariable7), CELLML_STATE_FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), FIELDS_TYPE (CheckVariable11), CELLML_FIELD_MAPS_TYPE (CheckVariable12), CELLML_MODEL_TYPE (CheckVariable13), GENERATED_MESHES_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CELLML_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable3
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable4

    ! if variable was already followed
    Ptr3 => Variable%MODELS_FIELD
    IF (ASSOCIATED(Ptr3, CheckVariable3)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MODELS_FIELD"
      CALL Print_CELLML_MODELS_FIELD_TYPE(Variable% &
        & MODELS_FIELD, CheckVariable18, CheckVariable19, CheckVariable11, CheckVariable20, CheckVariable12, &
        & CheckVariable5, CheckVariable7, CheckVariable8, CheckVariable1, Variable2, CheckVariable3, CheckVariable22, &
        & CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: " // &
      & "MODELS_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%STATE_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%STATE_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: " // &
      & "STATE_FIELD " // &
      & "(associated): " 
  
! Signature of Print_CELLML_STATE_FIELD_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, CELLML_FIELD_MAPS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, FIELD_TYPE, CELLML_TYPE, CELLML_MODELS_FIELD_TYPE, REGION_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, 
! The type to handle in this routine is: CELLML_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), REGION_PTR_TYPE (CheckVariable2), CELLML_MODELS_FIELD_TYPE (CheckVariable3), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), DOMAIN_TYPE (CheckVariable6), CELLML_ENVIRONMENTS_TYPE (CheckVariable7), CELLML_STATE_FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), FIELDS_TYPE (CheckVariable11), CELLML_FIELD_MAPS_TYPE (CheckVariable12), CELLML_MODEL_TYPE (CheckVariable13), GENERATED_MESHES_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CELLML_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable4

    ! if variable was already followed
    Ptr4 => Variable%STATE_FIELD
    IF (ASSOCIATED(Ptr4, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"STATE_FIELD"
      CALL Print_CELLML_STATE_FIELD_TYPE(Variable% &
        & STATE_FIELD, CheckVariable18, CheckVariable19, CheckVariable11, CheckVariable20, CheckVariable12, CheckVariable5, &
        & CheckVariable7, CheckVariable8, CheckVariable1, Variable2, CheckVariable3, CheckVariable22, CheckVariable4, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: " // &
      & "STATE_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERMEDIATE_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERMEDIATE_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: " // &
      & "INTERMEDIATE_FIELD " // &
      & "(associated): " 
  
! Signature of Print_CELLML_INTERMEDIATE_FIELD_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, CELLML_FIELD_MAPS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, FIELD_TYPE, CELLML_TYPE, CELLML_MODELS_FIELD_TYPE, REGION_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, 
! The type to handle in this routine is: CELLML_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), REGION_PTR_TYPE (CheckVariable2), CELLML_MODELS_FIELD_TYPE (CheckVariable3), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), DOMAIN_TYPE (CheckVariable6), CELLML_ENVIRONMENTS_TYPE (CheckVariable7), CELLML_STATE_FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), FIELDS_TYPE (CheckVariable11), CELLML_FIELD_MAPS_TYPE (CheckVariable12), CELLML_MODEL_TYPE (CheckVariable13), GENERATED_MESHES_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CELLML_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4

    ! if variable was already followed
    Ptr5 => Variable%INTERMEDIATE_FIELD
    IF (ASSOCIATED(Ptr5, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERMEDIATE_FIELD"
      CALL Print_CELLML_INTERMEDIATE_FIELD_TYPE(Variable% &
        & INTERMEDIATE_FIELD, CheckVariable18, CheckVariable19, CheckVariable11, CheckVariable20, CheckVariable12, &
        & CheckVariable5, CheckVariable7, CheckVariable8, CheckVariable1, Variable2, CheckVariable3, CheckVariable22, &
        & CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: " // &
      & "INTERMEDIATE_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%PARAMETERS_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PARAMETERS_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: " // &
      & "PARAMETERS_FIELD " // &
      & "(associated): " 
  
! Signature of Print_CELLML_PARAMETERS_FIELD_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, CELLML_FIELD_MAPS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, FIELD_TYPE, CELLML_TYPE, CELLML_MODELS_FIELD_TYPE, REGION_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, 
! The type to handle in this routine is: CELLML_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), REGION_PTR_TYPE (CheckVariable2), CELLML_MODELS_FIELD_TYPE (CheckVariable3), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), DOMAIN_TYPE (CheckVariable6), CELLML_ENVIRONMENTS_TYPE (CheckVariable7), CELLML_STATE_FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), FIELDS_TYPE (CheckVariable11), CELLML_FIELD_MAPS_TYPE (CheckVariable12), CELLML_MODEL_TYPE (CheckVariable13), GENERATED_MESHES_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable19
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CELLML_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable4

    ! if variable was already followed
    Ptr6 => Variable%PARAMETERS_FIELD
    IF (ASSOCIATED(Ptr6, CheckVariable19)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PARAMETERS_FIELD"
      CALL Print_CELLML_PARAMETERS_FIELD_TYPE(Variable% &
        & PARAMETERS_FIELD, CheckVariable18, CheckVariable19, CheckVariable11, CheckVariable20, CheckVariable12, &
        & CheckVariable5, CheckVariable7, CheckVariable8, CheckVariable1, Variable2, CheckVariable3, CheckVariable22, &
        & CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: " // &
      & "PARAMETERS_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "CELLML_GENERATED:                                ", &
    & Variable%CELLML_GENERATED

  
END SUBROUTINE Print_CELLML_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable7

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr0
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr2
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr4
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(SOLVER_MATRIX_TYPE), POINTER :: NullPtr6
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr11
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACE_MATRICES_TYPE), POINTER :: NullPtr14
  TYPE(FIELDS_TYPE), POINTER :: NullPtr15
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr16
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: NullPtr17
  TYPE(INTERFACE_MAPPING_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACE_PENALTY_TYPE), POINTER :: NullPtr19
  TYPE(FIELD_TYPE), POINTER :: NullPtr20
  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: NullPtr21
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr22
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr23

  TYPE(SOLVER_MAPPING_TYPE), POINTER :: Ptr0
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: Ptr1

  TYPE(INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INTERFACE_CONDITION_INDEX:       ", &
    & Variable%INTERFACE_CONDITION_INDEX
  
  ! Variable%SOLVER_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MAPPING_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, DAE_SOLVER_TYPE, EQUATIONS_SET_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, EQUATIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, INTERFACE_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, SOLVER_MATRIX_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MATRIX_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRIX_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE

    ! if variable was already followed
    Ptr0 => Variable%SOLVER_MAPPING
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MAPPING"
      CALL Print_SOLVER_MAPPING_TYPE(Variable% &
        & SOLVER_MAPPING, NullPtr0, NullPtr1, NullPtr2, NullPtr3, CheckVariable0, NullPtr4, NullPtr5, CheckVariable2, &
        & CheckVariable3, CheckVariable1, CheckVariable4, CheckVariable5, NullPtr6, NullPtr7, CheckVariable6, NullPtr8, &
        & CheckVariable7, NullPtr9, NullPtr10, NullPtr11, NullPtr12, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE_EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_EQUATIONS_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_LAGRANGE_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_MATRICES_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, INTERFACE_MAPPING_TYPE, INTERFACE_PENALTY_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_EQUATIONS_INTERPOLATION_TYPE, INTERFACE_CONDITION_PTR_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type INTERFACE_LAGRANGE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_LAGRANGE_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type INTERFACE_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MATRICES_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_DEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_DEPENDENT_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACE_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MAPPING_TYPE
! - signature type INTERFACE_PENALTY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PENALTY_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACE_EQUATIONS_INTERPOLATION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_INTERPOLATION_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE

    ! if variable was already followed
    Ptr1 => Variable%INTERFACE_EQUATIONS
    IF (ASSOCIATED(Ptr1, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_EQUATIONS"
      CALL Print_INTERFACE_EQUATIONS_TYPE(Variable% &
        & INTERFACE_EQUATIONS, NullPtr0, NullPtr13, CheckVariable0, NullPtr14, CheckVariable1, NullPtr15, NullPtr16, &
        & CheckVariable3, NullPtr17, CheckVariable4, NullPtr18, NullPtr19, CheckVariable6, NullPtr20, NullPtr21, NullPtr22, &
        & NullPtr23, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_EQUATIONS_SETS:        ", &
    & Variable%NUMBER_OF_EQUATIONS_SETS
  
  ! Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS,1), MIN(LBOUND(Variable% &
      & INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS_TYPE has the following CheckVariable types: SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, BOUNDARY_CONDITIONS_TYPE, SOLVER_MAPPING_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS_TYPE(Variable% &
          & INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS(I0), CheckVariable3, CheckVariable6, CheckVariable0, CheckVariable4, &
          & Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_SM)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_SM),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_SM, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_SM,1), MIN(LBOUND(Variable% &
      & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_SM,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_TO_SOLVER_MATRIX_MAPS_SM("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE(Variable% &
          & INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_IM)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_IM),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_IM, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_IM,1), MIN(LBOUND(Variable% &
      & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS_IM,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_TO_SOLVER_MATRIX_MAPS_IM("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE(Variable% &
          & INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS,1), MIN(LBOUND(Variable% &
      & INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP_TYPE(Variable% &
          & INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_COLUMN_TO_SOLVER_ROWS_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_ADJACENT_DOMAIN_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_ADJACENT_DOMAIN_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(DOMAIN_ADJACENT_DOMAIN_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DOMAIN_NUMBER:                   ", &
    & Variable%DOMAIN_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SEND_GHOSTS:           ", &
    & Variable%NUMBER_OF_SEND_GHOSTS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_RECEIVE_GHOSTS:        ", &
    & Variable%NUMBER_OF_RECEIVE_GHOSTS
  
  ! Variable%LOCAL_GHOST_SEND_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LOCAL_GHOST_SEND_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LOCAL_GHOST_SEND_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_GHOST_SEND_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LOCAL_GHOST_SEND_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LOCAL_GHOST_SEND_INDICES,1), MIN(LBOUND(Variable% &
      & LOCAL_GHOST_SEND_INDICES,1)+MaxArrayLength, UBOUND(Variable%LOCAL_GHOST_SEND_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LOCAL_GHOST_SEND_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_GHOST_SEND_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LOCAL_GHOST_RECEIVE_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LOCAL_GHOST_RECEIVE_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LOCAL_GHOST_RECEIVE_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_GHOST_RECEIVE_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LOCAL_GHOST_RECEIVE_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LOCAL_GHOST_RECEIVE_INDICES,1), MIN(LBOUND(Variable% &
      & LOCAL_GHOST_RECEIVE_INDICES,1)+MaxArrayLength, UBOUND(Variable%LOCAL_GHOST_RECEIVE_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LOCAL_GHOST_RECEIVE_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_GHOST_RECEIVE_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DOMAIN_ADJACENT_DOMAIN_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DISTRIBUTED_MATRIX_CMISS_TYPE(Variable, CheckVariable0, Depth, MaxDepth, MaxArrayLength)
  TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER, INTENT(IN) :: CheckVariable0

  ! iterator variables

  ! null pointers
  TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER :: NullPtr0

  TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: Ptr0

  TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)

  
  ! Variable%DISTRIBUTED_MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DISTRIBUTED_MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "DISTRIBUTED_MATRIX " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_MATRIX_TYPE has the following CheckVariable types: DISTRIBUTED_MATRIX_CMISS_TYPE, DISTRIBUTED_MATRIX_PETSC_TYPE, 
! The type to handle in this routine is: DISTRIBUTED_MATRIX_CMISS_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_MATRIX_TYPE (CheckVariable0), 
! - signature type DISTRIBUTED_MATRIX_CMISS_TYPE
!   is type of this print routine, use Variable2
! - signature type DISTRIBUTED_MATRIX_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_PETSC_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DISTRIBUTED_MATRIX
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DISTRIBUTED_MATRIX"
      CALL Print_DISTRIBUTED_MATRIX_TYPE(Variable%DISTRIBUTED_MATRIX, Variable2, NullPtr0, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "DISTRIBUTED_MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "BASE_TAG_NUMBER:                 ", &
    & Variable%BASE_TAG_NUMBER
  
  ! Variable%MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MATRIX_TYPE), POINTER :: " // &
      & "MATRIX " // &
      & "(associated): " 
  
! Signature of Print_MATRIX_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DISTRIBUTED_MATRIX_CMISS_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_MATRIX_TYPE (CheckVariable0), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATRIX"
      CALL Print_MATRIX_TYPE(Variable%MATRIX, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MATRIX_TYPE), POINTER :: " // &
      & "MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DISTRIBUTED_MATRIX_CMISS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CONTROL_LOOP_LOAD_INCREMENT_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, Depth, MaxDepth, MaxArrayLength)
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable11

  ! iterator variables

  ! null pointers
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr3
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr9

  TYPE(CONTROL_LOOP_TYPE), POINTER :: Ptr0

  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable10)) THEN
    Variable2 => CheckVariable10
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  
  ! Variable%CONTROL_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CONTROL_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, PROBLEMS_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_LOAD_INCREMENT_TYPE (Variable)
! Available CheckVariables are: HISTORY_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), PROBLEM_PTR_TYPE (CheckVariable7), CONTROL_LOOP_WHILE_TYPE (CheckVariable8), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable9), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable10), PROBLEM_TYPE (CheckVariable11), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is type of this print routine, use Variable2
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr0 => Variable%CONTROL_LOOP
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CONTROL_LOOP"
      CALL Print_CONTROL_LOOP_TYPE(Variable% &
        & CONTROL_LOOP, CheckVariable8, CheckVariable1, CheckVariable5, CheckVariable6, NullPtr0, CheckVariable4, NullPtr1, &
        & NullPtr2, NullPtr3, NullPtr4, NullPtr5, CheckVariable9, NullPtr6, NullPtr7, Variable2, CheckVariable0, NullPtr8, &
        & CheckVariable2, CheckVariable3, CheckVariable7, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ITERATION_NUMBER:                ", &
    & Variable%ITERATION_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_ITERATIONS:    ", &
    & Variable%MAXIMUM_NUMBER_OF_ITERATIONS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "OUTPUT_NUMBER:                   ", &
    & Variable%OUTPUT_NUMBER

  
END SUBROUTINE Print_CONTROL_LOOP_LOAD_INCREMENT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_MATRIX_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_MATRIX_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(SOLVER_MATRIX_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable5

  ! iterator variables

  ! null pointers

  TYPE(SOLVER_MATRIX_TYPE), POINTER :: Ptr0

  TYPE(SOLVER_MATRIX_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MATRIX_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MATRIX_TYPE has the following CheckVariable types: SOLVER_MATRICES_TYPE, SOLVERS_TYPE, SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, 
! The type to handle in this routine is: SOLVER_MATRIX_PTR_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRIX_TYPE (CheckVariable0), SOLVER_MATRICES_TYPE (CheckVariable1), SOLVER_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), SOLVERS_TYPE (CheckVariable4), SOLVER_EQUATIONS_TYPE (CheckVariable5), 
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable3

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_SOLVER_MATRIX_TYPE(Variable% &
        & PTR, CheckVariable1, CheckVariable4, CheckVariable2, CheckVariable5, CheckVariable3, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MATRIX_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_SOLVER_MATRIX_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SOLVER_ROWS:           ", &
    & Variable%NUMBER_OF_SOLVER_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_ROW:                      ", &
    & Variable%SOLVER_ROW
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "COUPLING_COEFFICIENT:        ", &
    & Variable%COUPLING_COEFFICIENT

  
END SUBROUTINE Print_INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DECOMPOSITION_FACES_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, Depth, MaxDepth, MaxArrayLength)
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DecompositionDataPointsType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable11

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr3
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr4
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr5
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr7
  TYPE(FIELDS_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: NullPtr11
  TYPE(REGION_TYPE), POINTER :: NullPtr12

  TYPE(DECOMPOSITION_TYPE), POINTER :: Ptr0

  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)

  
  ! Variable%DECOMPOSITION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DECOMPOSITION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "DECOMPOSITION " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_FACES_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DecompositionDataPointsType (CheckVariable6), DECOMPOSITION_FACES_TYPE (CheckVariable7), DECOMPOSITION_LINES_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITIONS_TYPE (CheckVariable10), DOMAIN_PTR_TYPE (CheckVariable11), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type DOMAIN_MAPPINGS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_MAPPINGS_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TOPOLOGY_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable6
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DECOMPOSITION
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DECOMPOSITION"
      CALL Print_DECOMPOSITION_TYPE(Variable% &
        & DECOMPOSITION, NullPtr0, NullPtr1, NullPtr2, CheckVariable5, NullPtr3, NullPtr4, CheckVariable9, NullPtr5, &
        & NullPtr6, CheckVariable3, NullPtr7, Variable2, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr8, &
        & CheckVariable10, CheckVariable11, NullPtr9, NullPtr10, NullPtr11, CheckVariable4, CheckVariable6, CheckVariable8, &
        & NullPtr12, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "DECOMPOSITION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_FACES:                 ", &
    & Variable%NUMBER_OF_FACES
  
  ! Variable%FACES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%FACES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%FACES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_FACE_TYPE), ALLOCATABLE :: " // &
      & "FACES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%FACES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%FACES,1), MIN(LBOUND(Variable%FACES,1)+MaxArrayLength, UBOUND(Variable%FACES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DECOMPOSITION_FACE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DECOMPOSITION_FACES_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DecompositionDataPointsType (CheckVariable6), DECOMPOSITION_FACES_TYPE (CheckVariable7), DECOMPOSITION_LINES_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITIONS_TYPE (CheckVariable10), DOMAIN_PTR_TYPE (CheckVariable11), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FACES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DECOMPOSITION_FACE_TYPE(Variable%FACES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_FACE_TYPE), ALLOCATABLE :: " // &
      & "FACES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DECOMPOSITION_FACES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MESH_ADJACENT_ELEMENT_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(MESH_ADJACENT_ELEMENT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(MESH_ADJACENT_ELEMENT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ADJACENT_ELEMENTS:     ", &
    & Variable%NUMBER_OF_ADJACENT_ELEMENTS
  
  ! Variable%ADJACENT_ELEMENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ADJACENT_ELEMENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ADJACENT_ELEMENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ADJACENT_ELEMENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ADJACENT_ELEMENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ADJACENT_ELEMENTS,1), MIN(LBOUND(Variable%ADJACENT_ELEMENTS,1)+MaxArrayLength, UBOUND(Variable% &
      & ADJACENT_ELEMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ADJACENT_ELEMENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ADJACENT_ELEMENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_MESH_ADJACENT_ELEMENT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_EQUATIONS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
  & CheckVariable32, CheckVariable33, CheckVariable34, CheckVariable35, CheckVariable36, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable31
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable32
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable33
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable34
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable35
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable36

  ! iterator variables

  ! null pointers
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr1
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr5
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(SOLVER_MATRIX_TYPE), POINTER :: NullPtr8
  TYPE(REGION_TYPE), POINTER :: NullPtr9
  TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER :: NullPtr10

  TYPE(SOLVER_TYPE), POINTER :: Ptr0
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: Ptr1
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: Ptr2
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: Ptr3

  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable26)) THEN
    Variable2 => CheckVariable26
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)

  
  ! Variable%SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: SOLVER_EQUATIONS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), BDF_DAE_SOLVER_TYPE (CheckVariable1), CONTROL_LOOP_WHILE_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable4), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable5), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), EULER_DAE_SOLVER_TYPE (CheckVariable9), NEWTON_SOLVER_TYPE (CheckVariable10), CONTROL_LOOP_FIXED_TYPE (CheckVariable11), CONTROL_LOOP_TIME_TYPE (CheckVariable12), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable13), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), PROBLEM_TYPE (CheckVariable20), EQUATIONS_SET_TYPE (CheckVariable21), BOUNDARY_CONDITIONS_TYPE (CheckVariable22), CELLML_EQUATIONS_TYPE (CheckVariable23), CONTROL_LOOP_TYPE (CheckVariable24), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), HISTORY_TYPE (CheckVariable28), DAE_SOLVER_TYPE (CheckVariable29), SOLVERS_TYPE (CheckVariable30), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable31), SOLVER_TYPE (CheckVariable32), SOLVER_MAPPING_TYPE (CheckVariable33), SOLVER_MATRICES_TYPE (CheckVariable34), LINEAR_SOLVER_TYPE (CheckVariable35), EIGENPROBLEM_SOLVER_TYPE (CheckVariable36), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable19
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable32
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable35
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable20

    ! if variable was already followed
    Ptr0 => Variable%SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable32)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & SOLVER, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, NullPtr0, &
        & CheckVariable7, CheckVariable8, CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, &
        & CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, &
        & CheckVariable36, CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, NullPtr1, Variable2, &
        & NullPtr2, CheckVariable27, CheckVariable34, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
        & CheckVariable32, NullPtr3, NullPtr4, CheckVariable33, CheckVariable9, NullPtr5, CheckVariable35, CheckVariable20, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "SOLVER_EQUATIONS_FINISHED:                       ", &
    & Variable%SOLVER_EQUATIONS_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LINEARITY:                       ", &
    & Variable%LINEARITY
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TIME_DEPENDENCE:                 ", &
    & Variable%TIME_DEPENDENCE
  Comment = ""
  IF (Variable%SPARSITY_TYPE == 1) THEN
    Comment = "SOLVER_SPARSE_MATRICES " // & 
      & "!Use sparse solver matrices"
  ENDIF
  IF (Variable%SPARSITY_TYPE == 2) THEN
    Comment = "SOLVER_FULL_MATRICES " // & 
      & "!Use fully populated solver matrices"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SPARSITY_TYPE:                   ", &
    & Variable%SPARSITY_TYPE, " ", TRIM(Comment)
  
  ! Variable%SOLVER_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MAPPING_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, DAE_SOLVER_TYPE, EQUATIONS_SET_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, EQUATIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, INTERFACE_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, SOLVER_MATRIX_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_EQUATIONS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), BDF_DAE_SOLVER_TYPE (CheckVariable1), CONTROL_LOOP_WHILE_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable4), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable5), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), EULER_DAE_SOLVER_TYPE (CheckVariable9), NEWTON_SOLVER_TYPE (CheckVariable10), CONTROL_LOOP_FIXED_TYPE (CheckVariable11), CONTROL_LOOP_TIME_TYPE (CheckVariable12), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable13), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), PROBLEM_TYPE (CheckVariable20), EQUATIONS_SET_TYPE (CheckVariable21), BOUNDARY_CONDITIONS_TYPE (CheckVariable22), CELLML_EQUATIONS_TYPE (CheckVariable23), CONTROL_LOOP_TYPE (CheckVariable24), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), HISTORY_TYPE (CheckVariable28), DAE_SOLVER_TYPE (CheckVariable29), SOLVERS_TYPE (CheckVariable30), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable31), SOLVER_TYPE (CheckVariable32), SOLVER_MAPPING_TYPE (CheckVariable33), SOLVER_MATRICES_TYPE (CheckVariable34), LINEAR_SOLVER_TYPE (CheckVariable35), EIGENPROBLEM_SOLVER_TYPE (CheckVariable36), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type INTERFACE_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable33
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type SOLVER_MATRIX_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRIX_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable35
! - signature type SOLVER_EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable19
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable36

    ! if variable was already followed
    Ptr1 => Variable%SOLVER_MAPPING
    IF (ASSOCIATED(Ptr1, CheckVariable33)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MAPPING"
      CALL Print_SOLVER_MAPPING_TYPE(Variable% &
        & SOLVER_MAPPING, CheckVariable0, CheckVariable29, CheckVariable21, CheckVariable8, CheckVariable22, &
        & CheckVariable23, NullPtr6, CheckVariable30, CheckVariable32, NullPtr7, CheckVariable33, CheckVariable34, &
        & NullPtr8, CheckVariable35, Variable2, CheckVariable15, CheckVariable24, CheckVariable17, CheckVariable18, &
        & CheckVariable19, CheckVariable36, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOLVER_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MATRICES_TYPE), POINTER :: " // &
      & "SOLVER_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MATRICES_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, SOLVER_MATRIX_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_EQUATIONS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), BDF_DAE_SOLVER_TYPE (CheckVariable1), CONTROL_LOOP_WHILE_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable4), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable5), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), EULER_DAE_SOLVER_TYPE (CheckVariable9), NEWTON_SOLVER_TYPE (CheckVariable10), CONTROL_LOOP_FIXED_TYPE (CheckVariable11), CONTROL_LOOP_TIME_TYPE (CheckVariable12), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable13), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), PROBLEM_TYPE (CheckVariable20), EQUATIONS_SET_TYPE (CheckVariable21), BOUNDARY_CONDITIONS_TYPE (CheckVariable22), CELLML_EQUATIONS_TYPE (CheckVariable23), CONTROL_LOOP_TYPE (CheckVariable24), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), HISTORY_TYPE (CheckVariable28), DAE_SOLVER_TYPE (CheckVariable29), SOLVERS_TYPE (CheckVariable30), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable31), SOLVER_TYPE (CheckVariable32), SOLVER_MAPPING_TYPE (CheckVariable33), SOLVER_MATRICES_TYPE (CheckVariable34), LINEAR_SOLVER_TYPE (CheckVariable35), EIGENPROBLEM_SOLVER_TYPE (CheckVariable36), 
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable34
! - signature type SOLVER_MATRIX_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRIX_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable35
! - signature type SOLVER_EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable19
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable36

    ! if variable was already followed
    Ptr2 => Variable%SOLVER_MATRICES
    IF (ASSOCIATED(Ptr2, CheckVariable34)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MATRICES"
      CALL Print_SOLVER_MATRICES_TYPE(Variable% &
        & SOLVER_MATRICES, CheckVariable29, CheckVariable8, CheckVariable22, CheckVariable23, CheckVariable30, &
        & CheckVariable32, CheckVariable33, CheckVariable34, NullPtr8, CheckVariable35, Variable2, CheckVariable15, &
        & CheckVariable24, CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable36, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MATRICES_TYPE), POINTER :: " // &
      & "SOLVER_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%BOUNDARY_CONDITIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%BOUNDARY_CONDITIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: " // &
      & "BOUNDARY_CONDITIONS " // &
      & "(associated): " 
  
! Signature of Print_BOUNDARY_CONDITIONS_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, EQUATIONS_SET_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, INTERFACE_CONDITION_TYPE, SOLVERS_TYPE, REGION_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, FIELD_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, BOUNDARY_CONDITIONS_VARIABLE_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_EQUATIONS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), BDF_DAE_SOLVER_TYPE (CheckVariable1), CONTROL_LOOP_WHILE_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable4), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable5), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), EULER_DAE_SOLVER_TYPE (CheckVariable9), NEWTON_SOLVER_TYPE (CheckVariable10), CONTROL_LOOP_FIXED_TYPE (CheckVariable11), CONTROL_LOOP_TIME_TYPE (CheckVariable12), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable13), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), PROBLEM_TYPE (CheckVariable20), EQUATIONS_SET_TYPE (CheckVariable21), BOUNDARY_CONDITIONS_TYPE (CheckVariable22), CELLML_EQUATIONS_TYPE (CheckVariable23), CONTROL_LOOP_TYPE (CheckVariable24), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), HISTORY_TYPE (CheckVariable28), DAE_SOLVER_TYPE (CheckVariable29), SOLVERS_TYPE (CheckVariable30), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable31), SOLVER_TYPE (CheckVariable32), SOLVER_MAPPING_TYPE (CheckVariable33), SOLVER_MATRICES_TYPE (CheckVariable34), LINEAR_SOLVER_TYPE (CheckVariable35), EIGENPROBLEM_SOLVER_TYPE (CheckVariable36), 
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable22
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable35
! - signature type SOLVER_EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type BOUNDARY_CONDITIONS_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_VARIABLE_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable19
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable36

    ! if variable was already followed
    Ptr3 => Variable%BOUNDARY_CONDITIONS
    IF (ASSOCIATED(Ptr3, CheckVariable22)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BOUNDARY_CONDITIONS"
      CALL Print_BOUNDARY_CONDITIONS_TYPE(Variable% &
        & BOUNDARY_CONDITIONS, CheckVariable29, CheckVariable21, CheckVariable8, CheckVariable22, CheckVariable23, &
        & CheckVariable0, CheckVariable30, NullPtr9, CheckVariable32, CheckVariable33, CheckVariable34, CheckVariable35, &
        & Variable2, CheckVariable15, CheckVariable3, CheckVariable24, CheckVariable17, NullPtr10, CheckVariable18, &
        & CheckVariable19, CheckVariable36, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: " // &
      & "BOUNDARY_CONDITIONS (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_SOLVER_EQUATIONS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELDS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable29

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr2
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr3
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr4

  TYPE(REGION_TYPE), POINTER :: Ptr0
  TYPE(INTERFACE_TYPE), POINTER :: Ptr1
  TYPE(FIELD_PTR_TYPE), POINTER :: Ptr2

  TYPE(FIELDS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable16)) THEN
    Variable2 => CheckVariable16
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)

  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELDS_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), DOMAIN_PTR_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable25), DECOMPOSITION_TYPE (CheckVariable26), EQUATIONS_SET_PTR_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FIELDS_TYPE
!   is type of this print routine, use Variable2
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable29

    ! if variable was already followed
    Ptr0 => Variable%REGION
    IF (ASSOCIATED(Ptr0, CheckVariable29)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr0, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, NullPtr1, CheckVariable10, CheckVariable11, &
        & CheckVariable12, NullPtr2, CheckVariable13, CheckVariable15, Variable2, CheckVariable17, CheckVariable18, &
        & CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
        & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELDS_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), DOMAIN_PTR_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable25), DECOMPOSITION_TYPE (CheckVariable26), EQUATIONS_SET_PTR_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   is type of this print routine, use Variable2
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

    ! if variable was already followed
    Ptr1 => Variable%INTERFACE
    IF (ASSOCIATED(Ptr1, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE"
      CALL Print_INTERFACE_TYPE(Variable% &
        & INTERFACE, NullPtr3, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, NullPtr2, CheckVariable14, CheckVariable15, NullPtr4, Variable2, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
        & CheckVariable25, CheckVariable26, CheckVariable28, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_FIELDS:                ", &
    & Variable%NUMBER_OF_FIELDS
  
  ! Variable%FIELDS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%FIELDS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_PTR_TYPE), POINTER :: " // &
      & "FIELDS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%FIELDS,1), "): "
  
    DO I0 = LBOUND(Variable%FIELDS,1), MIN(LBOUND(Variable%FIELDS,1)+MaxArrayLength, UBOUND(Variable%FIELDS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_PTR_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELDS_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), DOMAIN_PTR_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable25), DECOMPOSITION_TYPE (CheckVariable26), EQUATIONS_SET_PTR_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FIELDS_TYPE
!   is type of this print routine, use Variable2
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

      ! if variable was already followed
      Ptr2 => Variable%FIELDS(I0)
      IF (ASSOCIATED(Ptr2, CheckVariable3)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELDS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_PTR_TYPE(Variable% &
          & FIELDS(I0), CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable5, CheckVariable6, &
          & CheckVariable7, CheckVariable9, CheckVariable11, CheckVariable12, CheckVariable15, Variable2, CheckVariable17, &
          & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable24, &
          & CheckVariable25, CheckVariable26, CheckVariable28, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_PTR_TYPE), POINTER :: " // &
      & "FIELDS(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELDS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_FACE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_FACE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1, I2
  CHARACTER(LEN=30) :: I0_STR, I1_STR, I2_STR

  ! null pointers
  TYPE(BASIS_TYPE), POINTER :: NullPtr0
  TYPE(BASIS_PTR_TYPE), POINTER :: NullPtr1


  TYPE(DOMAIN_FACE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER:                          ", &
    & Variable%NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "XI_DIRECTION1:                   ", &
    & Variable%XI_DIRECTION1
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "XI_DIRECTION2:                   ", &
    & Variable%XI_DIRECTION2
  
  ! Variable%BASIS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%BASIS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_TYPE), POINTER :: " // &
      & "BASIS " // &
      & "(associated): " 
  
! Signature of Print_BASIS_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: DOMAIN_FACE_TYPE (Variable)
! Available CheckVariables are: 
! - signature type BASIS_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_TYPE
! - signature type BASIS_PTR_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_PTR_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BASIS"
      CALL Print_BASIS_TYPE(Variable%BASIS, NullPtr0, NullPtr1, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_TYPE), POINTER :: " // &
      & "BASIS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%NODES_IN_FACE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODES_IN_FACE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODES_IN_FACE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODES_IN_FACE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODES_IN_FACE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NODES_IN_FACE,1), MIN(LBOUND(Variable%NODES_IN_FACE,1)+MaxArrayLength, UBOUND(Variable%NODES_IN_FACE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NODES_IN_FACE(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODES_IN_FACE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DERIVATIVES_IN_FACE(:,:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DERIVATIVES_IN_FACE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DERIVATIVES_IN_FACE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DERIVATIVES_IN_FACE(:,:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DERIVATIVES_IN_FACE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DERIVATIVES_IN_FACE,1), MIN(LBOUND(Variable% &
      & DERIVATIVES_IN_FACE,1)+MaxArrayLength, UBOUND(Variable%DERIVATIVES_IN_FACE,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%DERIVATIVES_IN_FACE,2), MIN(LBOUND(Variable% &
        & DERIVATIVES_IN_FACE,2)+MaxArrayLength, UBOUND(Variable%DERIVATIVES_IN_FACE,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//","//TRIM(ADJUSTL(I1_STR))//",*): "
        DO I2 = LBOUND(Variable%DERIVATIVES_IN_FACE,3), MIN(LBOUND(Variable% &
          & DERIVATIVES_IN_FACE,3)+MaxArrayLength, UBOUND(Variable%DERIVATIVES_IN_FACE,3))
          WRITE(I2_STR,"(I4)") I2 

          PRINT*, TRIM(PrintIndent), Variable%DERIVATIVES_IN_FACE(I0,I1,I2)

        ENDDO  ! I2
      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DERIVATIVES_IN_FACE(:,:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "BOUNDARY_FACE:                                   ", &
    & Variable%BOUNDARY_FACE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ELEMENT_NUMBER:                  ", &
    & Variable%ELEMENT_NUMBER

  
END SUBROUTINE Print_DOMAIN_FACE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_NODE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_NODE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(DOMAIN_NODE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LOCAL_NUMBER:                    ", &
    & Variable%LOCAL_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MESH_NUMBER:                     ", &
    & Variable%MESH_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DERIVATIVES:           ", &
    & Variable%NUMBER_OF_DERIVATIVES
  
  ! Variable%DERIVATIVES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DERIVATIVES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DERIVATIVES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_NODE_DERIVATIVE_TYPE), ALLOCATABLE :: " // &
      & "DERIVATIVES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DERIVATIVES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%DERIVATIVES,1), MIN(LBOUND(Variable%DERIVATIVES,1)+MaxArrayLength, UBOUND(Variable%DERIVATIVES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DOMAIN_NODE_DERIVATIVE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DOMAIN_NODE_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DERIVATIVES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DOMAIN_NODE_DERIVATIVE_TYPE(Variable%DERIVATIVES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_NODE_DERIVATIVE_TYPE), ALLOCATABLE :: " // &
      & "DERIVATIVES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SURROUNDING_ELEMENTS:  ", &
    & Variable%NUMBER_OF_SURROUNDING_ELEMENTS
  
  ! Variable%SURROUNDING_ELEMENTS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%SURROUNDING_ELEMENTS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), POINTER :: " // &
      & "SURROUNDING_ELEMENTS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%SURROUNDING_ELEMENTS,1), "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SURROUNDING_ELEMENTS,1), MIN(LBOUND(Variable% &
      & SURROUNDING_ELEMENTS,1)+MaxArrayLength, UBOUND(Variable%SURROUNDING_ELEMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SURROUNDING_ELEMENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), POINTER :: " // &
      & "SURROUNDING_ELEMENTS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_NODE_LINES:            ", &
    & Variable%NUMBER_OF_NODE_LINES
  
  ! Variable%NODE_LINES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODE_LINES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODE_LINES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_LINES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODE_LINES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NODE_LINES,1), MIN(LBOUND(Variable%NODE_LINES,1)+MaxArrayLength, UBOUND(Variable%NODE_LINES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NODE_LINES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_LINES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_NODE_FACES:            ", &
    & Variable%NUMBER_OF_NODE_FACES
  
  ! Variable%NODE_FACES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODE_FACES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODE_FACES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_FACES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODE_FACES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NODE_FACES,1), MIN(LBOUND(Variable%NODE_FACES,1)+MaxArrayLength, UBOUND(Variable%NODE_FACES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NODE_FACES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_FACES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "BOUNDARY_NODE:                                   ", &
    & Variable%BOUNDARY_NODE

  
END SUBROUTINE Print_DOMAIN_NODE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_DEPENDENT_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(INTERFACE_PENALTY_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable10

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr2
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr3
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr4
  TYPE(MESH_TYPE), POINTER :: NullPtr5
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr6
  TYPE(NODES_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr10
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr11
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr12
  TYPE(SOLVER_TYPE), POINTER :: NullPtr13
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr14
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr15
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr16
  TYPE(REGION_TYPE), POINTER :: NullPtr17
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr18
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr19
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr20
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr21
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr23
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr24
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr25

  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: Ptr0

  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable4)) THEN
    Variable2 => CheckVariable4
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)

  
  ! Variable%INTERFACE_CONDITION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_CONDITION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITION " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_CONDITION_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, SOLVER_EQUATIONS_TYPE, INTERFACE_LAGRANGE_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, INTERFACE_PENALTY_TYPE, GENERATED_MESHES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_DEPENDENT_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), INTERFACE_DEPENDENT_TYPE (CheckVariable4), INTERFACE_PENALTY_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), INTERFACE_LAGRANGE_TYPE (CheckVariable8), INTERFACE_CONDITION_PTR_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_LAGRANGE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type INTERFACE_DEPENDENT_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type INTERFACE_PENALTY_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_CONDITION
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_CONDITION"
      CALL Print_INTERFACE_CONDITION_TYPE(Variable% &
        & INTERFACE_CONDITION, CheckVariable0, NullPtr0, NullPtr1, CheckVariable3, CheckVariable7, NullPtr2, &
        & CheckVariable10, NullPtr3, NullPtr4, CheckVariable9, NullPtr5, NullPtr6, CheckVariable1, CheckVariable2, &
        & CheckVariable6, CheckVariable8, NullPtr7, NullPtr8, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, &
        & Variable2, NullPtr14, NullPtr15, CheckVariable5, NullPtr16, NullPtr17, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DEPENDENT_VARIABLES:   ", &
    & Variable%NUMBER_OF_DEPENDENT_VARIABLES
  
  ! Variable%EQUATIONS_SETS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SETS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: " // &
      & "EQUATIONS_SETS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%EQUATIONS_SETS,1), "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_SETS,1), MIN(LBOUND(Variable%EQUATIONS_SETS,1)+MaxArrayLength, UBOUND(Variable% &
      & EQUATIONS_SETS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_SET_PTR_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, SOLVER_EQUATIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, GENERATED_MESHES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_DEPENDENT_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), INTERFACE_DEPENDENT_TYPE (CheckVariable4), INTERFACE_PENALTY_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), INTERFACE_LAGRANGE_TYPE (CheckVariable8), INTERFACE_CONDITION_PTR_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SETS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_SET_PTR_TYPE(Variable% &
          & EQUATIONS_SETS(I0), NullPtr0, CheckVariable7, NullPtr18, NullPtr19, CheckVariable10, NullPtr20, NullPtr4, &
          & NullPtr21, NullPtr6, CheckVariable2, CheckVariable6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, NullPtr11, &
          & NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr22, NullPtr16, NullPtr17, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: " // &
      & "EQUATIONS_SETS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%FIELD_VARIABLES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%FIELD_VARIABLES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_PTR_TYPE), POINTER :: " // &
      & "FIELD_VARIABLES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%FIELD_VARIABLES,1), "): "
  
    DO I0 = LBOUND(Variable%FIELD_VARIABLES,1), MIN(LBOUND(Variable%FIELD_VARIABLES,1)+MaxArrayLength, UBOUND(Variable% &
      & FIELD_VARIABLES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_VARIABLE_PTR_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, FIELDS_TYPE, FIELD_PTR_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACE_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: INTERFACE_DEPENDENT_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), INTERFACE_DEPENDENT_TYPE (CheckVariable4), INTERFACE_PENALTY_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), INTERFACE_LAGRANGE_TYPE (CheckVariable8), INTERFACE_CONDITION_PTR_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELD_VARIABLES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_VARIABLE_PTR_TYPE(Variable% &
          & FIELD_VARIABLES(I0), NullPtr10, NullPtr23, CheckVariable2, NullPtr24, NullPtr25, CheckVariable7, &
          & CheckVariable10, NullPtr17, NullPtr9, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_PTR_TYPE), POINTER :: " // &
      & "FIELD_VARIABLES(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%VARIABLE_MESH_INDICES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%VARIABLE_MESH_INDICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), POINTER :: " // &
      & "VARIABLE_MESH_INDICES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%VARIABLE_MESH_INDICES,1), "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%VARIABLE_MESH_INDICES,1), MIN(LBOUND(Variable% &
      & VARIABLE_MESH_INDICES,1)+MaxArrayLength, UBOUND(Variable%VARIABLE_MESH_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%VARIABLE_MESH_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), POINTER :: " // &
      & "VARIABLE_MESH_INDICES(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_DEPENDENT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_NODE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(NODE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(NODE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER

  
END SUBROUTINE Print_NODE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_GRID_POINT_PARAM_TO_DOF_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_GRID_POINT_PARAM_TO_DOF_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(FIELD_GRID_POINT_PARAM_TO_DOF_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GRID_POINT_PARAMETERS: ", &
    & Variable%NUMBER_OF_GRID_POINT_PARAMETERS
  
  ! Variable%GRID_POINTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GRID_POINTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GRID_POINTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "GRID_POINTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GRID_POINTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%GRID_POINTS,1), MIN(LBOUND(Variable%GRID_POINTS,1)+MaxArrayLength, UBOUND(Variable%GRID_POINTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%GRID_POINTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "GRID_POINTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_GRID_POINT_PARAM_TO_DOF_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DecompositionElementDataPointsType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DecompositionElementDataPointsType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(DecompositionElementDataPointsType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfProjectedData:           ", &
    & Variable%numberOfProjectedData
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "globalElementNumber:             ", &
    & Variable%globalElementNumber
  
  ! Variable%dataIndices(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%dataIndices)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%dataIndices),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DecompositionElementDataPointType), ALLOCATABLE :: " // &
      & "dataIndices(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%dataIndices, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%dataIndices,1), MIN(LBOUND(Variable%dataIndices,1)+MaxArrayLength, UBOUND(Variable%dataIndices,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DecompositionElementDataPointType has the following CheckVariable types: 
! The type to handle in this routine is: DecompositionElementDataPointsType (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"dataIndices("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DecompositionElementDataPointType(Variable%dataIndices(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DecompositionElementDataPointType), ALLOCATABLE :: " // &
      & "dataIndices(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DecompositionElementDataPointsType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_CREATE_VALUES_CACHE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_CREATE_VALUES_CACHE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers


  TYPE(FIELD_CREATE_VALUES_CACHE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "LABEL_LOCKED:                                    ", &
    & Variable%LABEL_LOCKED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "DECOMPOSITION_LOCKED:                            ", &
    & Variable%DECOMPOSITION_LOCKED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "DataProjectionLocked:                            ", &
    & Variable%DataProjectionLocked
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "DEPENDENT_TYPE_LOCKED:                           ", &
    & Variable%DEPENDENT_TYPE_LOCKED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "NUMBER_OF_VARIABLES_LOCKED:                      ", &
    & Variable%NUMBER_OF_VARIABLES_LOCKED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "GEOMETRIC_FIELD_LOCKED:                          ", &
    & Variable%GEOMETRIC_FIELD_LOCKED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "SCALING_TYPE_LOCKED:                             ", &
    & Variable%SCALING_TYPE_LOCKED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "TYPE_LOCKED:                                     ", &
    & Variable%TYPE_LOCKED
  
  ! Variable%VARIABLE_TYPES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLE_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLE_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "VARIABLE_TYPES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLE_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%VARIABLE_TYPES,1), MIN(LBOUND(Variable%VARIABLE_TYPES,1)+MaxArrayLength, UBOUND(Variable% &
      & VARIABLE_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%VARIABLE_TYPES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "VARIABLE_TYPES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "VARIABLE_TYPES_LOCKED:                           ", &
    & Variable%VARIABLE_TYPES_LOCKED
  
  ! Variable%VARIABLE_LABELS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLE_LABELS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLE_LABELS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(VARYING_STRING), ALLOCATABLE :: " // &
      & "VARIABLE_LABELS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLE_LABELS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(VARYING_STRING) :: Variable%" // &
        & "VARIABLE_LABELS (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(VARYING_STRING), ALLOCATABLE :: " // &
      & "VARIABLE_LABELS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%VARIABLE_LABELS_LOCKED(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLE_LABELS_LOCKED)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLE_LABELS_LOCKED),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "VARIABLE_LABELS_LOCKED(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLE_LABELS_LOCKED, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%VARIABLE_LABELS_LOCKED,1), MIN(LBOUND(Variable% &
      & VARIABLE_LABELS_LOCKED,1)+MaxArrayLength, UBOUND(Variable%VARIABLE_LABELS_LOCKED,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%VARIABLE_LABELS_LOCKED(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "VARIABLE_LABELS_LOCKED(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DIMENSION(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DIMENSION)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DIMENSION),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DIMENSION(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DIMENSION, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DIMENSION,1), MIN(LBOUND(Variable%DIMENSION,1)+MaxArrayLength, UBOUND(Variable%DIMENSION,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DIMENSION(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DIMENSION(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DIMENSION_LOCKED(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DIMENSION_LOCKED)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DIMENSION_LOCKED),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "DIMENSION_LOCKED(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DIMENSION_LOCKED, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DIMENSION_LOCKED,1), MIN(LBOUND(Variable%DIMENSION_LOCKED,1)+MaxArrayLength, UBOUND(Variable% &
      & DIMENSION_LOCKED,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DIMENSION_LOCKED(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "DIMENSION_LOCKED(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_TYPES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DATA_TYPES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_TYPES,1), MIN(LBOUND(Variable%DATA_TYPES,1)+MaxArrayLength, UBOUND(Variable%DATA_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_TYPES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DATA_TYPES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_TYPES_LOCKED(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_TYPES_LOCKED)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_TYPES_LOCKED),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "DATA_TYPES_LOCKED(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_TYPES_LOCKED, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_TYPES_LOCKED,1), MIN(LBOUND(Variable%DATA_TYPES_LOCKED,1)+MaxArrayLength, UBOUND(Variable% &
      & DATA_TYPES_LOCKED,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_TYPES_LOCKED(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "DATA_TYPES_LOCKED(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DOF_ORDER_TYPES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOF_ORDER_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOF_ORDER_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_ORDER_TYPES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOF_ORDER_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DOF_ORDER_TYPES,1), MIN(LBOUND(Variable%DOF_ORDER_TYPES,1)+MaxArrayLength, UBOUND(Variable% &
      & DOF_ORDER_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DOF_ORDER_TYPES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_ORDER_TYPES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DOF_ORDER_TYPES_LOCKED(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOF_ORDER_TYPES_LOCKED)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOF_ORDER_TYPES_LOCKED),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "DOF_ORDER_TYPES_LOCKED(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOF_ORDER_TYPES_LOCKED, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DOF_ORDER_TYPES_LOCKED,1), MIN(LBOUND(Variable% &
      & DOF_ORDER_TYPES_LOCKED,1)+MaxArrayLength, UBOUND(Variable%DOF_ORDER_TYPES_LOCKED,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DOF_ORDER_TYPES_LOCKED(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "DOF_ORDER_TYPES_LOCKED(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NUMBER_OF_COMPONENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_COMPONENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_COMPONENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_COMPONENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_COMPONENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_COMPONENTS,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_COMPONENTS,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_COMPONENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_COMPONENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_COMPONENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NUMBER_OF_COMPONENTS_LOCKED(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_COMPONENTS_LOCKED)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_COMPONENTS_LOCKED),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "NUMBER_OF_COMPONENTS_LOCKED(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_COMPONENTS_LOCKED, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_COMPONENTS_LOCKED,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_COMPONENTS_LOCKED,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_COMPONENTS_LOCKED,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_COMPONENTS_LOCKED(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "NUMBER_OF_COMPONENTS_LOCKED(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COMPONENT_LABELS(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COMPONENT_LABELS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COMPONENT_LABELS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(VARYING_STRING), ALLOCATABLE :: " // &
      & "COMPONENT_LABELS(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COMPONENT_LABELS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(VARYING_STRING) :: Variable%" // &
        & "COMPONENT_LABELS (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(VARYING_STRING), ALLOCATABLE :: " // &
      & "COMPONENT_LABELS(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COMPONENT_LABELS_LOCKED(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COMPONENT_LABELS_LOCKED)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COMPONENT_LABELS_LOCKED),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "COMPONENT_LABELS_LOCKED(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COMPONENT_LABELS_LOCKED, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COMPONENT_LABELS_LOCKED,1), MIN(LBOUND(Variable% &
      & COMPONENT_LABELS_LOCKED,1)+MaxArrayLength, UBOUND(Variable%COMPONENT_LABELS_LOCKED,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%COMPONENT_LABELS_LOCKED,2), MIN(LBOUND(Variable% &
        & COMPONENT_LABELS_LOCKED,2)+MaxArrayLength, UBOUND(Variable%COMPONENT_LABELS_LOCKED,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%COMPONENT_LABELS_LOCKED(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "COMPONENT_LABELS_LOCKED(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERPOLATION_TYPE(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERPOLATION_TYPE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERPOLATION_TYPE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERPOLATION_TYPE(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERPOLATION_TYPE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%INTERPOLATION_TYPE,1), MIN(LBOUND(Variable% &
      & INTERPOLATION_TYPE,1)+MaxArrayLength, UBOUND(Variable%INTERPOLATION_TYPE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%INTERPOLATION_TYPE,2), MIN(LBOUND(Variable% &
        & INTERPOLATION_TYPE,2)+MaxArrayLength, UBOUND(Variable%INTERPOLATION_TYPE,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%INTERPOLATION_TYPE(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERPOLATION_TYPE(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERPOLATION_TYPE_LOCKED(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERPOLATION_TYPE_LOCKED)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERPOLATION_TYPE_LOCKED),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "INTERPOLATION_TYPE_LOCKED(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERPOLATION_TYPE_LOCKED, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%INTERPOLATION_TYPE_LOCKED,1), MIN(LBOUND(Variable% &
      & INTERPOLATION_TYPE_LOCKED,1)+MaxArrayLength, UBOUND(Variable%INTERPOLATION_TYPE_LOCKED,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%INTERPOLATION_TYPE_LOCKED,2), MIN(LBOUND(Variable% &
        & INTERPOLATION_TYPE_LOCKED,2)+MaxArrayLength, UBOUND(Variable%INTERPOLATION_TYPE_LOCKED,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%INTERPOLATION_TYPE_LOCKED(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "INTERPOLATION_TYPE_LOCKED(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%MESH_COMPONENT_NUMBER(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MESH_COMPONENT_NUMBER)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MESH_COMPONENT_NUMBER),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "MESH_COMPONENT_NUMBER(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MESH_COMPONENT_NUMBER, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%MESH_COMPONENT_NUMBER,1), MIN(LBOUND(Variable% &
      & MESH_COMPONENT_NUMBER,1)+MaxArrayLength, UBOUND(Variable%MESH_COMPONENT_NUMBER,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%MESH_COMPONENT_NUMBER,2), MIN(LBOUND(Variable% &
        & MESH_COMPONENT_NUMBER,2)+MaxArrayLength, UBOUND(Variable%MESH_COMPONENT_NUMBER,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%MESH_COMPONENT_NUMBER(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "MESH_COMPONENT_NUMBER(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%MESH_COMPONENT_NUMBER_LOCKED(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MESH_COMPONENT_NUMBER_LOCKED)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MESH_COMPONENT_NUMBER_LOCKED),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "MESH_COMPONENT_NUMBER_LOCKED(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MESH_COMPONENT_NUMBER_LOCKED, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%MESH_COMPONENT_NUMBER_LOCKED,1), MIN(LBOUND(Variable% &
      & MESH_COMPONENT_NUMBER_LOCKED,1)+MaxArrayLength, UBOUND(Variable%MESH_COMPONENT_NUMBER_LOCKED,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%MESH_COMPONENT_NUMBER_LOCKED,2), MIN(LBOUND(Variable% &
        & MESH_COMPONENT_NUMBER_LOCKED,2)+MaxArrayLength, UBOUND(Variable%MESH_COMPONENT_NUMBER_LOCKED,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%MESH_COMPONENT_NUMBER_LOCKED(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "MESH_COMPONENT_NUMBER_LOCKED(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_CREATE_VALUES_CACHE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVERS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable23

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr6
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr8
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr10
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr11


  TYPE(SOLVERS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable19)) THEN
    Variable2 => CheckVariable19
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)

  
  ! Variable%CONTROL_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CONTROL_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP " // &
      & "(associated): " 
  
    WRITE(*,*) "(manually (hardcoded) excluded because of potential loop)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "SOLVERS_FINISHED:                                ", &
    & Variable%SOLVERS_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SOLVERS:               ", &
    & Variable%NUMBER_OF_SOLVERS
  
  ! Variable%SOLVERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOLVERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOLVERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_PTR_TYPE), ALLOCATABLE :: " // &
      & "SOLVERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOLVERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%SOLVERS,1), MIN(LBOUND(Variable%SOLVERS,1)+MaxArrayLength, UBOUND(Variable%SOLVERS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_PTR_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, PROBLEMS_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: SOLVERS_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), QUASI_NEWTON_SOLVER_TYPE (CheckVariable1), PROBLEMS_TYPE (CheckVariable2), NEWTON_SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_FIXED_TYPE (CheckVariable4), CONTROL_LOOP_TIME_TYPE (CheckVariable5), OPTIMISER_SOLVER_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), DYNAMIC_SOLVER_TYPE (CheckVariable8), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable9), GeometricTransformationSolverType (CheckVariable10), EIGENPROBLEM_SOLVER_TYPE (CheckVariable11), CELLML_EQUATIONS_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), NONLINEAR_SOLVER_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable16), HISTORY_TYPE (CheckVariable17), DAE_SOLVER_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), SOLVER_TYPE (CheckVariable20), PROBLEM_PTR_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), PROBLEM_TYPE (CheckVariable23), 
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable10
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type SOLVERS_TYPE
!   is type of this print routine, use Variable2
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable23
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVERS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_PTR_TYPE(Variable% &
          & SOLVERS(I0), NullPtr0, CheckVariable0, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, CheckVariable2, &
          & CheckVariable3, CheckVariable4, CheckVariable5, NullPtr4, NullPtr5, CheckVariable6, CheckVariable7, &
          & CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, NullPtr6, CheckVariable12, CheckVariable13, &
          & NullPtr7, CheckVariable14, CheckVariable15, CheckVariable16, NullPtr8, CheckVariable17, CheckVariable18, &
          & Variable2, NullPtr9, CheckVariable20, NullPtr10, NullPtr11, CheckVariable21, CheckVariable22, CheckVariable23, &
          & Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_PTR_TYPE), ALLOCATABLE :: " // &
      & "SOLVERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_SOLVERS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_OPTIMISER_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
  & CheckVariable32, CheckVariable33, Depth, MaxDepth, MaxArrayLength)
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable31
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable32
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable33

  ! iterator variables

  ! null pointers
  TYPE(FIELD_TYPE), POINTER :: NullPtr0
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr2
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr6

  TYPE(SOLVER_TYPE), POINTER :: Ptr0

  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable12)) THEN
    Variable2 => CheckVariable12
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: OPTIMISER_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), PROBLEM_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), SOLVER_EQUATIONS_TYPE (CheckVariable22), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), HISTORY_TYPE (CheckVariable25), DAE_SOLVER_TYPE (CheckVariable26), SOLVERS_TYPE (CheckVariable27), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable28), SOLVER_TYPE (CheckVariable29), SOLVER_MAPPING_TYPE (CheckVariable30), EULER_DAE_SOLVER_TYPE (CheckVariable31), LINEAR_SOLVER_TYPE (CheckVariable32), EIGENPROBLEM_SOLVER_TYPE (CheckVariable33), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type OPTIMISER_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable16
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable29
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable17

    ! if variable was already followed
    Ptr0 => Variable%SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable29)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & SOLVER, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, CheckVariable3, CheckVariable4, NullPtr1, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & Variable2, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable33, CheckVariable18, &
        & CheckVariable19, CheckVariable20, CheckVariable21, NullPtr2, CheckVariable22, NullPtr3, CheckVariable23, &
        & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, NullPtr4, &
        & NullPtr5, CheckVariable30, CheckVariable31, NullPtr6, CheckVariable32, CheckVariable17, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRICES_LIBRARY:         ", &
    & Variable%SOLVER_MATRICES_LIBRARY

  
END SUBROUTINE Print_OPTIMISER_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_SET_GEOMETRY_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(EQUATIONS_SET_GEOMETRY_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(EquationsSetDerivedType), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable15

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr3
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr9
  TYPE(SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr16
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr19
  TYPE(MESH_TYPE), POINTER :: NullPtr20
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr21
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr23
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr24

  TYPE(EQUATIONS_SET_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(EQUATIONS_SET_GEOMETRY_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  
  ! Variable%EQUATIONS_SET
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SET)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_TYPE has the following CheckVariable types: EQUATIONS_TYPE, MESHES_TYPE, EquationsSetDerivedType, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_GEOMETRY_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable15

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_SET
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SET"
      CALL Print_EQUATIONS_SET_TYPE(Variable% &
        & EQUATIONS_SET, CheckVariable1, NullPtr0, CheckVariable3, CheckVariable12, NullPtr1, CheckVariable13, &
        & CheckVariable8, CheckVariable9, NullPtr2, NullPtr3, CheckVariable2, NullPtr4, CheckVariable5, NullPtr5, NullPtr6, &
        & NullPtr7, NullPtr8, CheckVariable0, CheckVariable4, NullPtr9, CheckVariable6, NullPtr10, CheckVariable7, &
        & NullPtr11, NullPtr12, CheckVariable10, CheckVariable11, CheckVariable14, CheckVariable15, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%GEOMETRIC_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GEOMETRIC_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "GEOMETRIC_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_GEOMETRY_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr1 => Variable%GEOMETRIC_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GEOMETRIC_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & GEOMETRIC_FIELD, NullPtr0, NullPtr13, NullPtr14, NullPtr15, CheckVariable12, NullPtr1, NullPtr16, &
        & CheckVariable13, CheckVariable9, NullPtr17, NullPtr2, NullPtr3, NullPtr18, NullPtr19, NullPtr20, CheckVariable5, &
        & NullPtr5, NullPtr21, NullPtr6, NullPtr22, NullPtr7, NullPtr8, CheckVariable0, NullPtr23, CheckVariable6, &
        & CheckVariable10, NullPtr24, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "GEOMETRIC_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%FIBRE_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIBRE_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIBRE_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_GEOMETRY_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr1 => Variable%FIBRE_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIBRE_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & FIBRE_FIELD, NullPtr0, NullPtr13, NullPtr14, NullPtr15, CheckVariable12, NullPtr1, NullPtr16, CheckVariable13, &
        & CheckVariable9, NullPtr17, NullPtr2, NullPtr3, NullPtr18, NullPtr19, NullPtr20, CheckVariable5, NullPtr5, &
        & NullPtr21, NullPtr6, NullPtr22, NullPtr7, NullPtr8, CheckVariable0, NullPtr23, CheckVariable6, CheckVariable10, &
        & NullPtr24, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIBRE_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_SET_GEOMETRY_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_JACOBIAN_TO_SOLVER_MAP_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(JACOBIAN_TO_SOLVER_MAP_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable2

  ! iterator variables

  ! null pointers


  TYPE(JACOBIAN_TO_SOLVER_MAP_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(JACOBIAN_TO_SOLVER_MAP_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_JACOBIAN_TO_SOLVER_MAP_TYPE has the following CheckVariable types: SOLVER_MATRICES_TYPE, SOLVER_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, 
! The type to handle in this routine is: JACOBIAN_TO_SOLVER_MAP_PTR_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRICES_TYPE (CheckVariable0), SOLVER_EQUATIONS_TYPE (CheckVariable1), SOLVER_MAPPING_TYPE (CheckVariable2), 
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable2
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_JACOBIAN_TO_SOLVER_MAP_TYPE(Variable% &
        & PTR, CheckVariable0, CheckVariable1, CheckVariable2, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(JACOBIAN_TO_SOLVER_MAP_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_JACOBIAN_TO_SOLVER_MAP_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_MATRIX_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_MATRIX_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable4

  ! iterator variables

  ! null pointers
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr2
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr3
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr6
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr9
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: NullPtr11
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr12
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: NullPtr13
  TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER :: NullPtr14
  TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER :: NullPtr15

  TYPE(SOLVER_MATRICES_TYPE), POINTER :: Ptr0

  TYPE(SOLVER_MATRIX_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MATRIX_NUMBER:                   ", &
    & Variable%MATRIX_NUMBER
  
  ! Variable%SOLVER_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MATRICES_TYPE), POINTER :: " // &
      & "SOLVER_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MATRICES_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, SOLVER_MATRIX_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_MATRIX_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRICES_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), SOLVER_TYPE (CheckVariable2), SOLVER_EQUATIONS_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), 
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type SOLVER_MATRIX_TYPE
!   is type of this print routine, use Variable2
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE

    ! if variable was already followed
    Ptr0 => Variable%SOLVER_MATRICES
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MATRICES"
      CALL Print_SOLVER_MATRICES_TYPE(Variable% &
        & SOLVER_MATRICES, NullPtr0, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, CheckVariable2, CheckVariable4, &
        & CheckVariable0, Variable2, NullPtr4, CheckVariable3, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MATRICES_TYPE), POINTER :: " // &
      & "SOLVER_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "UPDATE_MATRIX:                                   ", &
    & Variable%UPDATE_MATRIX
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "STORAGE_TYPE:                    ", &
    & Variable%STORAGE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COLUMNS:               ", &
    & Variable%NUMBER_OF_COLUMNS
  
  ! Variable%SOLVER_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "SOLVER_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: SOLVER_MATRIX_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRICES_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), SOLVER_TYPE (CheckVariable2), SOLVER_EQUATIONS_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_VECTOR"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%SOLVER_VECTOR, NullPtr11, NullPtr12, NullPtr13, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "SOLVER_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "MATRIX " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_MATRIX_TYPE has the following CheckVariable types: DISTRIBUTED_MATRIX_CMISS_TYPE, DISTRIBUTED_MATRIX_PETSC_TYPE, 
! The type to handle in this routine is: SOLVER_MATRIX_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRICES_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), SOLVER_TYPE (CheckVariable2), SOLVER_EQUATIONS_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), 
! - signature type DISTRIBUTED_MATRIX_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_CMISS_TYPE
! - signature type DISTRIBUTED_MATRIX_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_PETSC_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATRIX"
      CALL Print_DISTRIBUTED_MATRIX_TYPE(Variable%MATRIX, NullPtr14, NullPtr15, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_SOLVER_MATRIX_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_GENERATED_MESHES_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, Depth, MaxDepth, MaxArrayLength)
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable29

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr2
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr4
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr6
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr7

  TYPE(REGION_TYPE), POINTER :: Ptr0
  TYPE(INTERFACE_TYPE), POINTER :: Ptr1
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: Ptr2

  TYPE(GENERATED_MESHES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable19)) THEN
    Variable2 => CheckVariable19
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)

  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: GENERATED_MESHES_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), GENERATED_MESH_CYLINDER_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable4), FIELD_PTR_TYPE (CheckVariable5), GENERATED_MESH_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), REGION_PTR_TYPE (CheckVariable8), InterfacePointsConnectivityType (CheckVariable9), EQUATIONS_SETS_TYPE (CheckVariable10), INTERFACE_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CELLML_TYPE (CheckVariable15), INTERFACE_CONDITION_PTR_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), GENERATED_MESH_REGULAR_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), EQUATIONS_SET_PTR_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable9
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable29

    ! if variable was already followed
    Ptr0 => Variable%REGION
    IF (ASSOCIATED(Ptr0, CheckVariable29)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, CheckVariable0, CheckVariable2, CheckVariable3, NullPtr0, CheckVariable5, CheckVariable6, CheckVariable7, &
        & CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, NullPtr1, CheckVariable12, CheckVariable13, &
        & CheckVariable14, NullPtr2, CheckVariable15, CheckVariable17, CheckVariable18, Variable2, CheckVariable20, &
        & CheckVariable21, NullPtr3, CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, NullPtr4, &
        & CheckVariable27, CheckVariable28, NullPtr5, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: GENERATED_MESHES_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), GENERATED_MESH_CYLINDER_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable4), FIELD_PTR_TYPE (CheckVariable5), GENERATED_MESH_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), REGION_PTR_TYPE (CheckVariable8), InterfacePointsConnectivityType (CheckVariable9), EQUATIONS_SETS_TYPE (CheckVariable10), INTERFACE_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CELLML_TYPE (CheckVariable15), INTERFACE_CONDITION_PTR_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), GENERATED_MESH_REGULAR_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), EQUATIONS_SET_PTR_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable9
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable11
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

    ! if variable was already followed
    Ptr1 => Variable%INTERFACE
    IF (ASSOCIATED(Ptr1, CheckVariable11)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE"
      CALL Print_INTERFACE_TYPE(Variable% &
        & INTERFACE, NullPtr6, CheckVariable0, CheckVariable2, CheckVariable3, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, &
        & CheckVariable13, CheckVariable14, NullPtr2, CheckVariable16, CheckVariable17, NullPtr7, CheckVariable18, &
        & Variable2, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, &
        & NullPtr4, CheckVariable27, NullPtr5, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GENERATED_MESHES:      ", &
    & Variable%NUMBER_OF_GENERATED_MESHES
  
  ! Variable%GENERATED_MESHES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%GENERATED_MESHES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: " // &
      & "GENERATED_MESHES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%GENERATED_MESHES,1), "): "
  
    DO I0 = LBOUND(Variable%GENERATED_MESHES,1), MIN(LBOUND(Variable%GENERATED_MESHES,1)+MaxArrayLength, UBOUND(Variable% &
      & GENERATED_MESHES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_GENERATED_MESH_PTR_TYPE has the following CheckVariable types: MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, GENERATED_MESH_REGULAR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: GENERATED_MESHES_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), GENERATED_MESH_CYLINDER_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable4), FIELD_PTR_TYPE (CheckVariable5), GENERATED_MESH_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), REGION_PTR_TYPE (CheckVariable8), InterfacePointsConnectivityType (CheckVariable9), EQUATIONS_SETS_TYPE (CheckVariable10), INTERFACE_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CELLML_TYPE (CheckVariable15), INTERFACE_CONDITION_PTR_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), GENERATED_MESH_REGULAR_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), EQUATIONS_SET_PTR_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable24
! - signature type GENERATED_MESH_REGULAR_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

      ! if variable was already followed
      Ptr2 => Variable%GENERATED_MESHES(I0)
      IF (ASSOCIATED(Ptr2, CheckVariable24)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GENERATED_MESHES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_GENERATED_MESH_PTR_TYPE(Variable% &
          & GENERATED_MESHES(I0), CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, &
          & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable11, CheckVariable13, &
          & CheckVariable14, CheckVariable17, CheckVariable18, Variable2, CheckVariable20, CheckVariable21, &
          & CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable26, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: " // &
      & "GENERATED_MESHES(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_GENERATED_MESHES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_EQUATIONS_INTERPOLATION_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable5

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: NullPtr0
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(INTERFACE_MATRICES_TYPE), POINTER :: NullPtr2
  TYPE(FIELDS_TYPE), POINTER :: NullPtr3
  TYPE(SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_MAPPING_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_PENALTY_TYPE), POINTER :: NullPtr7
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr8
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr9

  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: Ptr0

  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  
  ! Variable%INTERFACE_EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_EQUATIONS_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_LAGRANGE_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_MATRICES_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, INTERFACE_MAPPING_TYPE, INTERFACE_PENALTY_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_EQUATIONS_INTERPOLATION_TYPE, INTERFACE_CONDITION_PTR_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type INTERFACE_LAGRANGE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_LAGRANGE_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type INTERFACE_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MATRICES_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type INTERFACE_DEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_DEPENDENT_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MAPPING_TYPE
! - signature type INTERFACE_PENALTY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PENALTY_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACE_EQUATIONS_INTERPOLATION_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_EQUATIONS
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_EQUATIONS"
      CALL Print_INTERFACE_EQUATIONS_TYPE(Variable% &
        & INTERFACE_EQUATIONS, CheckVariable0, NullPtr0, NullPtr1, NullPtr2, CheckVariable1, NullPtr3, CheckVariable2, &
        & NullPtr4, NullPtr5, CheckVariable3, NullPtr6, NullPtr7, NullPtr8, CheckVariable4, Variable2, NullPtr9, &
        & CheckVariable5, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%VARIABLE_INTERPOLATION(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLE_INTERPOLATION)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLE_INTERPOLATION),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE), ALLOCATABLE :: " // &
      & "VARIABLE_INTERPOLATION(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLE_INTERPOLATION, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%VARIABLE_INTERPOLATION,1), MIN(LBOUND(Variable% &
      & VARIABLE_INTERPOLATION,1)+MaxArrayLength, UBOUND(Variable%VARIABLE_INTERPOLATION,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE has the following CheckVariable types: INTERFACE_EQUATIONS_INTERPOLATION_TYPE, INTERFACE_TYPE, FIELD_TYPE, INTERFACE_EQUATIONS_TYPE, 
! The type to handle in this routine is: INTERFACE_EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), 
! - signature type INTERFACE_EQUATIONS_INTERPOLATION_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLE_INTERPOLATION("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE(Variable% &
          & VARIABLE_INTERPOLATION(I0), Variable2, CheckVariable5, CheckVariable4, CheckVariable1, Depth+1, MaxDepth, &
          & MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE), ALLOCATABLE :: " // &
      & "VARIABLE_INTERPOLATION(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_INTERFACE_EQUATIONS_INTERPOLATION_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr1
  TYPE(MESHES_TYPE), POINTER :: NullPtr2
  TYPE(FIELDS_TYPE), POINTER :: NullPtr3
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr4
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr6
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr11
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr12
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr13
  TYPE(NODES_TYPE), POINTER :: NullPtr14
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr15
  TYPE(REGION_TYPE), POINTER :: NullPtr16
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr17


  TYPE(EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "JACOBIAN_NUMBER:                 ", &
    & Variable%JACOBIAN_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "VARIABLE_TYPE:                   ", &
    & Variable%VARIABLE_TYPE
  
  ! Variable%VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & VARIABLE, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%JACOBIAN
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%JACOBIAN)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_JACOBIAN_TYPE), POINTER :: " // &
      & "JACOBIAN " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_JACOBIAN_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"JACOBIAN"
      CALL Print_EQUATIONS_JACOBIAN_TYPE(Variable%JACOBIAN, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_JACOBIAN_TYPE), POINTER :: " // &
      & "JACOBIAN (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COLUMNS:               ", &
    & Variable%NUMBER_OF_COLUMNS
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "JACOBIAN_COEFFICIENT:        ", &
    & Variable%JACOBIAN_COEFFICIENT
  
  ! Variable%EQUATIONS_COLUMN_TO_DOF_VARIABLE_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_COLUMN_TO_DOF_VARIABLE_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_COLUMN_TO_DOF_VARIABLE_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_COLUMN_TO_DOF_VARIABLE_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_COLUMN_TO_DOF_VARIABLE_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_COLUMN_TO_DOF_VARIABLE_MAP,1), MIN(LBOUND(Variable% &
      & EQUATIONS_COLUMN_TO_DOF_VARIABLE_MAP,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_COLUMN_TO_DOF_VARIABLE_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_COLUMN_TO_DOF_VARIABLE_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_COLUMN_TO_DOF_VARIABLE_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COLUMN_DOFS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%COLUMN_DOFS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "COLUMN_DOFS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"COLUMN_DOFS_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%COLUMN_DOFS_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "COLUMN_DOFS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MeshNodeDerivativeType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(MeshNodeDerivativeType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(MeshNodeDerivativeType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfVersions:                ", &
    & Variable%numberOfVersions
  
  ! Variable%userVersionNumbers(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%userVersionNumbers)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%userVersionNumbers),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "userVersionNumbers(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%userVersionNumbers, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%userVersionNumbers,1), MIN(LBOUND(Variable% &
      & userVersionNumbers,1)+MaxArrayLength, UBOUND(Variable%userVersionNumbers,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%userVersionNumbers(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "userVersionNumbers(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%dofIndex(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%dofIndex)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%dofIndex),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "dofIndex(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%dofIndex, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%dofIndex,1), MIN(LBOUND(Variable%dofIndex,1)+MaxArrayLength, UBOUND(Variable%dofIndex,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%dofIndex(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "dofIndex(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "globalDerivativeIndex:           ", &
    & Variable%globalDerivativeIndex
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "partialDerivativeIndex:          ", &
    & Variable%partialDerivativeIndex

  
END SUBROUTINE Print_MeshNodeDerivativeType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_NewtonSolverConvergenceTest(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(NewtonSolverConvergenceTest), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(NewtonSolverConvergenceTest), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "energyFirstIter:             ", &
    & Variable%energyFirstIter
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "normalisedEnergy:            ", &
    & Variable%normalisedEnergy

  
END SUBROUTINE Print_NewtonSolverConvergenceTest
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BOUNDARY_CONDITIONS_VARIABLE_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, Depth, MaxDepth, MaxArrayLength)
  TYPE(BOUNDARY_CONDITIONS_VARIABLE_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable6

  ! iterator variables

  ! null pointers

  TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER :: Ptr0

  TYPE(BOUNDARY_CONDITIONS_VARIABLE_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_BOUNDARY_CONDITIONS_VARIABLE_TYPE has the following CheckVariable types: BOUNDARY_CONDITIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, REGION_TYPE, 
! The type to handle in this routine is: BOUNDARY_CONDITIONS_VARIABLE_PTR_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), SOLVER_TYPE (CheckVariable2), REGION_TYPE (CheckVariable3), SOLVER_EQUATIONS_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), BOUNDARY_CONDITIONS_VARIABLE_TYPE (CheckVariable6), 
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable3

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_BOUNDARY_CONDITIONS_VARIABLE_TYPE(Variable% &
        & PTR, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable4, CheckVariable5, CheckVariable3, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_BOUNDARY_CONDITIONS_VARIABLE_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_TOPOLOGY_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DOMAIN_NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DOMAIN_LINES_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(DOMAIN_DOFS_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(DOMAIN_FACES_TYPE), POINTER, INTENT(IN) :: CheckVariable12

  ! iterator variables

  ! null pointers
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr1
  TYPE(FIELDS_TYPE), POINTER :: NullPtr2
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr4
  TYPE(CELLML_TYPE), POINTER :: NullPtr5
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: NullPtr6
  TYPE(MESH_TYPE), POINTER :: NullPtr7
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr8
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr9
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr10
  TYPE(DecompositionDataPointsType), POINTER :: NullPtr11
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: NullPtr12

  TYPE(DOMAIN_TYPE), POINTER :: Ptr0
  TYPE(DOMAIN_NODES_TYPE), POINTER :: Ptr1
  TYPE(DOMAIN_DOFS_TYPE), POINTER :: Ptr2
  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: Ptr3
  TYPE(DOMAIN_FACES_TYPE), POINTER :: Ptr4
  TYPE(DOMAIN_LINES_TYPE), POINTER :: Ptr5

  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable2)) THEN
    Variable2 => CheckVariable2
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)

  
  ! Variable%DOMAIN
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DOMAIN)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_TYPE has the following CheckVariable types: DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, DOMAIN_LINES_TYPE, FIELD_TYPE, DOMAIN_DOFS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_FACES_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_ELEMENTS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_FACES_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DOMAIN_NODES_TYPE, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DOMAIN_TOPOLOGY_TYPE (Variable)
! Available CheckVariables are: DOMAIN_ELEMENTS_TYPE (CheckVariable0), DOMAIN_TYPE (CheckVariable1), DOMAIN_TOPOLOGY_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), DOMAIN_MAPPINGS_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DOMAIN_NODES_TYPE (CheckVariable6), DOMAIN_LINES_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), DOMAIN_DOFS_TYPE (CheckVariable9), DOMAIN_PTR_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), DOMAIN_FACES_TYPE (CheckVariable12), 
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type DOMAIN_LINES_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DOMAIN_DOFS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_FACES_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_ELEMENTS_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type DOMAIN_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_FACES_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DecompositionDataPointsType
!   is not available in passing variables, use NullPtr of type DecompositionDataPointsType
! - signature type DOMAIN_NODES_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type DECOMPOSITION_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_LINES_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr0 => Variable%DOMAIN
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOMAIN"
      CALL Print_DOMAIN_TYPE(Variable% &
        & DOMAIN, CheckVariable4, CheckVariable5, NullPtr0, CheckVariable7, CheckVariable8, CheckVariable9, NullPtr1, &
        & CheckVariable1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, CheckVariable0, NullPtr9, &
        & CheckVariable10, CheckVariable12, NullPtr10, Variable2, CheckVariable3, NullPtr11, CheckVariable6, NullPtr12, &
        & CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%NODES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NODES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_NODES_TYPE), POINTER :: " // &
      & "NODES " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_NODES_TYPE has the following CheckVariable types: DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DOMAIN_MAPPINGS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_TYPE, 
! The type to handle in this routine is: DOMAIN_TOPOLOGY_TYPE (Variable)
! Available CheckVariables are: DOMAIN_ELEMENTS_TYPE (CheckVariable0), DOMAIN_TYPE (CheckVariable1), DOMAIN_TOPOLOGY_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), DOMAIN_MAPPINGS_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DOMAIN_NODES_TYPE (CheckVariable6), DOMAIN_LINES_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), DOMAIN_DOFS_TYPE (CheckVariable9), DOMAIN_PTR_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), DOMAIN_FACES_TYPE (CheckVariable12), 
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable1

    ! if variable was already followed
    Ptr1 => Variable%NODES
    IF (ASSOCIATED(Ptr1, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NODES"
      CALL Print_DOMAIN_NODES_TYPE(Variable% &
        & NODES, Variable2, CheckVariable3, CheckVariable4, CheckVariable10, CheckVariable1, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_NODES_TYPE), POINTER :: " // &
      & "NODES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DOFS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DOFS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_DOFS_TYPE), POINTER :: " // &
      & "DOFS " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_DOFS_TYPE has the following CheckVariable types: DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DOMAIN_MAPPINGS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_TYPE, 
! The type to handle in this routine is: DOMAIN_TOPOLOGY_TYPE (Variable)
! Available CheckVariables are: DOMAIN_ELEMENTS_TYPE (CheckVariable0), DOMAIN_TYPE (CheckVariable1), DOMAIN_TOPOLOGY_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), DOMAIN_MAPPINGS_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DOMAIN_NODES_TYPE (CheckVariable6), DOMAIN_LINES_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), DOMAIN_DOFS_TYPE (CheckVariable9), DOMAIN_PTR_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), DOMAIN_FACES_TYPE (CheckVariable12), 
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable1

    ! if variable was already followed
    Ptr2 => Variable%DOFS
    IF (ASSOCIATED(Ptr2, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOFS"
      CALL Print_DOMAIN_DOFS_TYPE(Variable% &
        & DOFS, Variable2, CheckVariable3, CheckVariable4, CheckVariable10, CheckVariable1, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_DOFS_TYPE), POINTER :: " // &
      & "DOFS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%ELEMENTS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ELEMENTS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: " // &
      & "ELEMENTS " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_ELEMENTS_TYPE has the following CheckVariable types: DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DOMAIN_MAPPINGS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_TYPE, 
! The type to handle in this routine is: DOMAIN_TOPOLOGY_TYPE (Variable)
! Available CheckVariables are: DOMAIN_ELEMENTS_TYPE (CheckVariable0), DOMAIN_TYPE (CheckVariable1), DOMAIN_TOPOLOGY_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), DOMAIN_MAPPINGS_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DOMAIN_NODES_TYPE (CheckVariable6), DOMAIN_LINES_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), DOMAIN_DOFS_TYPE (CheckVariable9), DOMAIN_PTR_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), DOMAIN_FACES_TYPE (CheckVariable12), 
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable1

    ! if variable was already followed
    Ptr3 => Variable%ELEMENTS
    IF (ASSOCIATED(Ptr3, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ELEMENTS"
      CALL Print_DOMAIN_ELEMENTS_TYPE(Variable% &
        & ELEMENTS, Variable2, CheckVariable3, CheckVariable4, CheckVariable10, CheckVariable1, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: " // &
      & "ELEMENTS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%FACES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FACES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_FACES_TYPE), POINTER :: " // &
      & "FACES " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_FACES_TYPE has the following CheckVariable types: DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DOMAIN_MAPPINGS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_TYPE, 
! The type to handle in this routine is: DOMAIN_TOPOLOGY_TYPE (Variable)
! Available CheckVariables are: DOMAIN_ELEMENTS_TYPE (CheckVariable0), DOMAIN_TYPE (CheckVariable1), DOMAIN_TOPOLOGY_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), DOMAIN_MAPPINGS_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DOMAIN_NODES_TYPE (CheckVariable6), DOMAIN_LINES_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), DOMAIN_DOFS_TYPE (CheckVariable9), DOMAIN_PTR_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), DOMAIN_FACES_TYPE (CheckVariable12), 
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable1

    ! if variable was already followed
    Ptr4 => Variable%FACES
    IF (ASSOCIATED(Ptr4, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FACES"
      CALL Print_DOMAIN_FACES_TYPE(Variable% &
        & FACES, Variable2, CheckVariable3, CheckVariable4, CheckVariable10, CheckVariable1, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_FACES_TYPE), POINTER :: " // &
      & "FACES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%LINES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_LINES_TYPE), POINTER :: " // &
      & "LINES " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_LINES_TYPE has the following CheckVariable types: DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DOMAIN_MAPPINGS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_TYPE, 
! The type to handle in this routine is: DOMAIN_TOPOLOGY_TYPE (Variable)
! Available CheckVariables are: DOMAIN_ELEMENTS_TYPE (CheckVariable0), DOMAIN_TYPE (CheckVariable1), DOMAIN_TOPOLOGY_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), DOMAIN_MAPPINGS_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DOMAIN_NODES_TYPE (CheckVariable6), DOMAIN_LINES_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), DOMAIN_DOFS_TYPE (CheckVariable9), DOMAIN_PTR_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), DOMAIN_FACES_TYPE (CheckVariable12), 
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable1

    ! if variable was already followed
    Ptr5 => Variable%LINES
    IF (ASSOCIATED(Ptr5, CheckVariable7)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINES"
      CALL Print_DOMAIN_LINES_TYPE(Variable% &
        & LINES, Variable2, CheckVariable3, CheckVariable4, CheckVariable10, CheckVariable1, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_LINES_TYPE), POINTER :: " // &
      & "LINES (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DOMAIN_TOPOLOGY_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CONTROL_LOOP_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, Depth, MaxDepth, MaxArrayLength)
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable21

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr1

  TYPE(PROBLEM_TYPE), POINTER :: Ptr0
  TYPE(CONTROL_LOOP_TYPE), POINTER :: Ptr1
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: Ptr2
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: Ptr3
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: Ptr4
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: Ptr5
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: Ptr6
  TYPE(SOLVERS_TYPE), POINTER :: Ptr7
  TYPE(HISTORY_TYPE), POINTER :: Ptr8

  TYPE(CONTROL_LOOP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable5)) THEN
    Variable2 => CheckVariable5
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)

  
  ! Variable%PROBLEM
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PROBLEM)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(PROBLEM_TYPE), POINTER :: " // &
      & "PROBLEM " // &
      & "(associated): " 
  
! Signature of Print_PROBLEM_TYPE has the following CheckVariable types: HISTORY_TYPE, PROBLEMS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, CONTROL_LOOP_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, PROBLEM_PTR_TYPE, CONTROL_LOOP_WHILE_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), CONTROL_LOOP_FIXED_TYPE (CheckVariable2), CONTROL_LOOP_TIME_TYPE (CheckVariable3), OPTIMISER_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_TYPE (CheckVariable5), DYNAMIC_SOLVER_TYPE (CheckVariable6), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable7), GeometricTransformationSolverType (CheckVariable8), EIGENPROBLEM_SOLVER_TYPE (CheckVariable9), CELLML_EQUATIONS_TYPE (CheckVariable10), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable11), NONLINEAR_SOLVER_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable14), HISTORY_TYPE (CheckVariable15), DAE_SOLVER_TYPE (CheckVariable16), SOLVERS_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), PROBLEM_PTR_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), PROBLEM_TYPE (CheckVariable21), 
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CONTROL_LOOP_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type PROBLEM_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable21

    ! if variable was already followed
    Ptr0 => Variable%PROBLEM
    IF (ASSOCIATED(Ptr0, CheckVariable21)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PROBLEM"
      CALL Print_PROBLEM_TYPE(Variable% &
        & PROBLEM, CheckVariable15, CheckVariable1, CheckVariable17, CheckVariable18, Variable2, CheckVariable2, &
        & CheckVariable3, CheckVariable19, CheckVariable0, CheckVariable11, CheckVariable14, CheckVariable21, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(PROBLEM_TYPE), POINTER :: " // &
      & "PROBLEM (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%PARENT_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PARENT_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "PARENT_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, PROBLEMS_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), CONTROL_LOOP_FIXED_TYPE (CheckVariable2), CONTROL_LOOP_TIME_TYPE (CheckVariable3), OPTIMISER_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_TYPE (CheckVariable5), DYNAMIC_SOLVER_TYPE (CheckVariable6), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable7), GeometricTransformationSolverType (CheckVariable8), EIGENPROBLEM_SOLVER_TYPE (CheckVariable9), CELLML_EQUATIONS_TYPE (CheckVariable10), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable11), NONLINEAR_SOLVER_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable14), HISTORY_TYPE (CheckVariable15), DAE_SOLVER_TYPE (CheckVariable16), SOLVERS_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), PROBLEM_PTR_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), PROBLEM_TYPE (CheckVariable21), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CONTROL_LOOP_TYPE
!   is type of this print routine, use Variable2
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable8
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable21

    ! if variable was already followed
    Ptr1 => Variable%PARENT_LOOP
    IF (ASSOCIATED(Ptr1, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PARENT_LOOP"
      CALL Print_CONTROL_LOOP_TYPE(Variable% &
        & PARENT_LOOP, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, Variable2, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "PARENT_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "CONTROL_LOOP_FINISHED:                           ", &
    & Variable%CONTROL_LOOP_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LOOP_TYPE:                       ", &
    & Variable%LOOP_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "CONTROL_LOOP_LEVEL:              ", &
    & Variable%CONTROL_LOOP_LEVEL
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SUB_LOOP_INDEX:                  ", &
    & Variable%SUB_LOOP_INDEX
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "OUTPUT_TYPE:                     ", &
    & Variable%OUTPUT_TYPE
  
  ! Variable%SIMPLE_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SIMPLE_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: " // &
      & "SIMPLE_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_SIMPLE_TYPE has the following CheckVariable types: HISTORY_TYPE, PROBLEMS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, CONTROL_LOOP_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, PROBLEM_PTR_TYPE, CONTROL_LOOP_WHILE_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), CONTROL_LOOP_FIXED_TYPE (CheckVariable2), CONTROL_LOOP_TIME_TYPE (CheckVariable3), OPTIMISER_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_TYPE (CheckVariable5), DYNAMIC_SOLVER_TYPE (CheckVariable6), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable7), GeometricTransformationSolverType (CheckVariable8), EIGENPROBLEM_SOLVER_TYPE (CheckVariable9), CELLML_EQUATIONS_TYPE (CheckVariable10), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable11), NONLINEAR_SOLVER_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable14), HISTORY_TYPE (CheckVariable15), DAE_SOLVER_TYPE (CheckVariable16), SOLVERS_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), PROBLEM_PTR_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), PROBLEM_TYPE (CheckVariable21), 
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CONTROL_LOOP_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable21

    ! if variable was already followed
    Ptr2 => Variable%SIMPLE_LOOP
    IF (ASSOCIATED(Ptr2, CheckVariable11)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SIMPLE_LOOP"
      CALL Print_CONTROL_LOOP_SIMPLE_TYPE(Variable% &
        & SIMPLE_LOOP, CheckVariable15, CheckVariable1, CheckVariable17, CheckVariable18, Variable2, CheckVariable2, &
        & CheckVariable3, CheckVariable19, CheckVariable0, CheckVariable11, CheckVariable14, CheckVariable21, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: " // &
      & "SIMPLE_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%FIXED_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIXED_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: " // &
      & "FIXED_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_FIXED_TYPE has the following CheckVariable types: HISTORY_TYPE, PROBLEMS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, CONTROL_LOOP_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, PROBLEM_PTR_TYPE, CONTROL_LOOP_WHILE_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), CONTROL_LOOP_FIXED_TYPE (CheckVariable2), CONTROL_LOOP_TIME_TYPE (CheckVariable3), OPTIMISER_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_TYPE (CheckVariable5), DYNAMIC_SOLVER_TYPE (CheckVariable6), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable7), GeometricTransformationSolverType (CheckVariable8), EIGENPROBLEM_SOLVER_TYPE (CheckVariable9), CELLML_EQUATIONS_TYPE (CheckVariable10), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable11), NONLINEAR_SOLVER_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable14), HISTORY_TYPE (CheckVariable15), DAE_SOLVER_TYPE (CheckVariable16), SOLVERS_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), PROBLEM_PTR_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), PROBLEM_TYPE (CheckVariable21), 
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CONTROL_LOOP_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable21

    ! if variable was already followed
    Ptr3 => Variable%FIXED_LOOP
    IF (ASSOCIATED(Ptr3, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIXED_LOOP"
      CALL Print_CONTROL_LOOP_FIXED_TYPE(Variable% &
        & FIXED_LOOP, CheckVariable15, CheckVariable1, CheckVariable17, CheckVariable18, Variable2, CheckVariable2, &
        & CheckVariable3, CheckVariable19, CheckVariable0, CheckVariable11, CheckVariable14, CheckVariable21, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: " // &
      & "FIXED_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%TIME_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%TIME_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: " // &
      & "TIME_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_TIME_TYPE has the following CheckVariable types: HISTORY_TYPE, PROBLEMS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, CONTROL_LOOP_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, PROBLEM_PTR_TYPE, CONTROL_LOOP_WHILE_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), CONTROL_LOOP_FIXED_TYPE (CheckVariable2), CONTROL_LOOP_TIME_TYPE (CheckVariable3), OPTIMISER_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_TYPE (CheckVariable5), DYNAMIC_SOLVER_TYPE (CheckVariable6), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable7), GeometricTransformationSolverType (CheckVariable8), EIGENPROBLEM_SOLVER_TYPE (CheckVariable9), CELLML_EQUATIONS_TYPE (CheckVariable10), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable11), NONLINEAR_SOLVER_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable14), HISTORY_TYPE (CheckVariable15), DAE_SOLVER_TYPE (CheckVariable16), SOLVERS_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), PROBLEM_PTR_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), PROBLEM_TYPE (CheckVariable21), 
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CONTROL_LOOP_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable21

    ! if variable was already followed
    Ptr4 => Variable%TIME_LOOP
    IF (ASSOCIATED(Ptr4, CheckVariable3)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TIME_LOOP"
      CALL Print_CONTROL_LOOP_TIME_TYPE(Variable% &
        & TIME_LOOP, CheckVariable15, CheckVariable1, CheckVariable17, CheckVariable18, Variable2, CheckVariable2, &
        & CheckVariable3, CheckVariable19, CheckVariable0, CheckVariable11, CheckVariable14, CheckVariable21, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: " // &
      & "TIME_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%WHILE_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%WHILE_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: " // &
      & "WHILE_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_WHILE_TYPE has the following CheckVariable types: HISTORY_TYPE, PROBLEMS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, CONTROL_LOOP_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, PROBLEM_PTR_TYPE, CONTROL_LOOP_WHILE_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), CONTROL_LOOP_FIXED_TYPE (CheckVariable2), CONTROL_LOOP_TIME_TYPE (CheckVariable3), OPTIMISER_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_TYPE (CheckVariable5), DYNAMIC_SOLVER_TYPE (CheckVariable6), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable7), GeometricTransformationSolverType (CheckVariable8), EIGENPROBLEM_SOLVER_TYPE (CheckVariable9), CELLML_EQUATIONS_TYPE (CheckVariable10), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable11), NONLINEAR_SOLVER_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable14), HISTORY_TYPE (CheckVariable15), DAE_SOLVER_TYPE (CheckVariable16), SOLVERS_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), PROBLEM_PTR_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), PROBLEM_TYPE (CheckVariable21), 
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CONTROL_LOOP_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable21

    ! if variable was already followed
    Ptr5 => Variable%WHILE_LOOP
    IF (ASSOCIATED(Ptr5, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"WHILE_LOOP"
      CALL Print_CONTROL_LOOP_WHILE_TYPE(Variable% &
        & WHILE_LOOP, CheckVariable15, CheckVariable1, CheckVariable17, CheckVariable18, Variable2, CheckVariable2, &
        & CheckVariable3, CheckVariable19, CheckVariable0, CheckVariable11, CheckVariable14, CheckVariable21, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: " // &
      & "WHILE_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%LOAD_INCREMENT_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LOAD_INCREMENT_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: " // &
      & "LOAD_INCREMENT_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_LOAD_INCREMENT_TYPE has the following CheckVariable types: HISTORY_TYPE, PROBLEMS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, CONTROL_LOOP_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, PROBLEM_PTR_TYPE, CONTROL_LOOP_WHILE_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), CONTROL_LOOP_FIXED_TYPE (CheckVariable2), CONTROL_LOOP_TIME_TYPE (CheckVariable3), OPTIMISER_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_TYPE (CheckVariable5), DYNAMIC_SOLVER_TYPE (CheckVariable6), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable7), GeometricTransformationSolverType (CheckVariable8), EIGENPROBLEM_SOLVER_TYPE (CheckVariable9), CELLML_EQUATIONS_TYPE (CheckVariable10), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable11), NONLINEAR_SOLVER_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable14), HISTORY_TYPE (CheckVariable15), DAE_SOLVER_TYPE (CheckVariable16), SOLVERS_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), PROBLEM_PTR_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), PROBLEM_TYPE (CheckVariable21), 
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CONTROL_LOOP_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable14
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable21

    ! if variable was already followed
    Ptr6 => Variable%LOAD_INCREMENT_LOOP
    IF (ASSOCIATED(Ptr6, CheckVariable14)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LOAD_INCREMENT_LOOP"
      CALL Print_CONTROL_LOOP_LOAD_INCREMENT_TYPE(Variable% &
        & LOAD_INCREMENT_LOOP, CheckVariable15, CheckVariable1, CheckVariable17, CheckVariable18, Variable2, &
        & CheckVariable2, CheckVariable3, CheckVariable19, CheckVariable0, CheckVariable11, CheckVariable14, &
        & CheckVariable21, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: " // &
      & "LOAD_INCREMENT_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SUB_LOOPS:             ", &
    & Variable%NUMBER_OF_SUB_LOOPS
  
  ! Variable%SUB_LOOPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SUB_LOOPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SUB_LOOPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_PTR_TYPE), ALLOCATABLE :: " // &
      & "SUB_LOOPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SUB_LOOPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%SUB_LOOPS,1), MIN(LBOUND(Variable%SUB_LOOPS,1)+MaxArrayLength, UBOUND(Variable%SUB_LOOPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_CONTROL_LOOP_PTR_TYPE has the following CheckVariable types: HISTORY_TYPE, PROBLEMS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, CONTROL_LOOP_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, PROBLEM_PTR_TYPE, CONTROL_LOOP_WHILE_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), CONTROL_LOOP_FIXED_TYPE (CheckVariable2), CONTROL_LOOP_TIME_TYPE (CheckVariable3), OPTIMISER_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_TYPE (CheckVariable5), DYNAMIC_SOLVER_TYPE (CheckVariable6), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable7), GeometricTransformationSolverType (CheckVariable8), EIGENPROBLEM_SOLVER_TYPE (CheckVariable9), CELLML_EQUATIONS_TYPE (CheckVariable10), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable11), NONLINEAR_SOLVER_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable14), HISTORY_TYPE (CheckVariable15), DAE_SOLVER_TYPE (CheckVariable16), SOLVERS_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), PROBLEM_PTR_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), PROBLEM_TYPE (CheckVariable21), 
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CONTROL_LOOP_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable21
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SUB_LOOPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_CONTROL_LOOP_PTR_TYPE(Variable% &
          & SUB_LOOPS(I0), CheckVariable15, CheckVariable1, CheckVariable17, CheckVariable18, Variable2, CheckVariable2, &
          & CheckVariable3, CheckVariable19, CheckVariable0, CheckVariable11, CheckVariable14, CheckVariable21, Depth+1, &
          & MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_PTR_TYPE), ALLOCATABLE :: " // &
      & "SUB_LOOPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%SOLVERS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVERS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVERS_TYPE), POINTER :: " // &
      & "SOLVERS " // &
      & "(associated): " 
  
! Signature of Print_SOLVERS_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, QUASI_NEWTON_SOLVER_TYPE, PROBLEMS_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), CONTROL_LOOP_FIXED_TYPE (CheckVariable2), CONTROL_LOOP_TIME_TYPE (CheckVariable3), OPTIMISER_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_TYPE (CheckVariable5), DYNAMIC_SOLVER_TYPE (CheckVariable6), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable7), GeometricTransformationSolverType (CheckVariable8), EIGENPROBLEM_SOLVER_TYPE (CheckVariable9), CELLML_EQUATIONS_TYPE (CheckVariable10), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable11), NONLINEAR_SOLVER_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable14), HISTORY_TYPE (CheckVariable15), DAE_SOLVER_TYPE (CheckVariable16), SOLVERS_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), PROBLEM_PTR_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), PROBLEM_TYPE (CheckVariable21), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CONTROL_LOOP_TYPE
!   is type of this print routine, use Variable2
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable8
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type SOLVERS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable21

    ! if variable was already followed
    Ptr7 => Variable%SOLVERS
    IF (ASSOCIATED(Ptr7, CheckVariable17)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVERS"
      CALL Print_SOLVERS_TYPE(Variable% &
        & SOLVERS, CheckVariable0, NullPtr0, CheckVariable1, NullPtr1, CheckVariable2, CheckVariable3, CheckVariable4, &
        & Variable2, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVERS_TYPE), POINTER :: " // &
      & "SOLVERS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%HISTORY
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%HISTORY)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(HISTORY_TYPE), POINTER :: " // &
      & "HISTORY " // &
      & "(associated): " 
  
! Signature of Print_HISTORY_TYPE has the following CheckVariable types: HISTORY_TYPE, PROBLEMS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, CONTROL_LOOP_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, PROBLEM_PTR_TYPE, CONTROL_LOOP_WHILE_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), CONTROL_LOOP_FIXED_TYPE (CheckVariable2), CONTROL_LOOP_TIME_TYPE (CheckVariable3), OPTIMISER_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_TYPE (CheckVariable5), DYNAMIC_SOLVER_TYPE (CheckVariable6), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable7), GeometricTransformationSolverType (CheckVariable8), EIGENPROBLEM_SOLVER_TYPE (CheckVariable9), CELLML_EQUATIONS_TYPE (CheckVariable10), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable11), NONLINEAR_SOLVER_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable14), HISTORY_TYPE (CheckVariable15), DAE_SOLVER_TYPE (CheckVariable16), SOLVERS_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), PROBLEM_PTR_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), PROBLEM_TYPE (CheckVariable21), 
! - signature type HISTORY_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable15
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CONTROL_LOOP_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable21

    ! if variable was already followed
    Ptr8 => Variable%HISTORY
    IF (ASSOCIATED(Ptr8, CheckVariable15)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"HISTORY"
      CALL Print_HISTORY_TYPE(Variable% &
        & HISTORY, CheckVariable15, CheckVariable1, CheckVariable17, CheckVariable18, Variable2, CheckVariable2, &
        & CheckVariable3, CheckVariable19, CheckVariable0, CheckVariable11, CheckVariable14, CheckVariable21, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(HISTORY_TYPE), POINTER :: " // &
      & "HISTORY (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_CONTROL_LOOP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_MAPPINGS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable7

  ! iterator variables

  ! null pointers
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr0
  TYPE(DOMAIN_LINES_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_DOFS_TYPE), POINTER :: NullPtr2
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr3
  TYPE(FIELDS_TYPE), POINTER :: NullPtr4
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: NullPtr5
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr6
  TYPE(CELLML_TYPE), POINTER :: NullPtr7
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: NullPtr8
  TYPE(MESH_TYPE), POINTER :: NullPtr9
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: NullPtr11
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr12
  TYPE(DOMAIN_FACES_TYPE), POINTER :: NullPtr13
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr14
  TYPE(DecompositionDataPointsType), POINTER :: NullPtr15
  TYPE(DOMAIN_NODES_TYPE), POINTER :: NullPtr16
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: NullPtr17

  TYPE(DOMAIN_TYPE), POINTER :: Ptr0

  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable3)) THEN
    Variable2 => CheckVariable3
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)

  
  ! Variable%DOMAIN
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DOMAIN)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_TYPE has the following CheckVariable types: DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, DOMAIN_LINES_TYPE, FIELD_TYPE, DOMAIN_DOFS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_FACES_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_ELEMENTS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_FACES_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DOMAIN_NODES_TYPE, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DOMAIN_MAPPINGS_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TYPE (CheckVariable0), DOMAIN_TOPOLOGY_TYPE (CheckVariable1), DECOMPOSITION_TYPE (CheckVariable2), DOMAIN_MAPPINGS_TYPE (CheckVariable3), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), DOMAIN_PTR_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type DOMAIN_MAPPINGS_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type DOMAIN_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_LINES_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DOMAIN_DOFS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_DOFS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_FACES_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_ELEMENTS_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type DOMAIN_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_ELEMENTS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type DOMAIN_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_FACES_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DecompositionDataPointsType
!   is not available in passing variables, use NullPtr of type DecompositionDataPointsType
! - signature type DOMAIN_NODES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_NODES_TYPE
! - signature type DECOMPOSITION_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_LINES_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7

    ! if variable was already followed
    Ptr0 => Variable%DOMAIN
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOMAIN"
      CALL Print_DOMAIN_TYPE(Variable% &
        & DOMAIN, Variable2, CheckVariable4, NullPtr0, NullPtr1, CheckVariable5, NullPtr2, NullPtr3, CheckVariable0, &
        & NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, NullPtr11, NullPtr12, CheckVariable6, &
        & NullPtr13, NullPtr14, CheckVariable1, CheckVariable2, NullPtr15, NullPtr16, NullPtr17, CheckVariable7, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%ELEMENTS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ELEMENTS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "ELEMENTS " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DOMAIN_MAPPINGS_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TYPE (CheckVariable0), DOMAIN_TOPOLOGY_TYPE (CheckVariable1), DECOMPOSITION_TYPE (CheckVariable2), DOMAIN_MAPPINGS_TYPE (CheckVariable3), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), DOMAIN_PTR_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ELEMENTS"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%ELEMENTS, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "ELEMENTS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%NODES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NODES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "NODES " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DOMAIN_MAPPINGS_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TYPE (CheckVariable0), DOMAIN_TOPOLOGY_TYPE (CheckVariable1), DECOMPOSITION_TYPE (CheckVariable2), DOMAIN_MAPPINGS_TYPE (CheckVariable3), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), DOMAIN_PTR_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NODES"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%NODES, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "NODES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DOFS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DOFS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "DOFS " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DOMAIN_MAPPINGS_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TYPE (CheckVariable0), DOMAIN_TOPOLOGY_TYPE (CheckVariable1), DECOMPOSITION_TYPE (CheckVariable2), DOMAIN_MAPPINGS_TYPE (CheckVariable3), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), DOMAIN_PTR_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOFS"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%DOFS, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "DOFS (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DOMAIN_MAPPINGS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_ADAMS_MOULTON_DAE_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, Depth, MaxDepth, MaxArrayLength)
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable19

  ! iterator variables

  ! null pointers
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr0
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr6
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr8
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr10
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(HISTORY_TYPE), POINTER :: NullPtr13
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr14
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr15
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr16

  TYPE(DAE_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable4)) THEN
    Variable2 => CheckVariable4
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)

  
  ! Variable%DAE_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DAE_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_DAE_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: ADAMS_MOULTON_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), CELLML_EQUATIONS_TYPE (CheckVariable2), SOLVERS_TYPE (CheckVariable3), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable4), SOLVER_TYPE (CheckVariable5), GeometricTransformationSolverType (CheckVariable6), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable7), EULER_DAE_SOLVER_TYPE (CheckVariable8), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable9), LINEAR_SOLVER_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), BDF_DAE_SOLVER_TYPE (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable18), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable19), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BACKWARD_EULER_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type FORWARD_EULER_DAE_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable6
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type IMPROVED_EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DAE_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DAE_SOLVER"
      CALL Print_DAE_SOLVER_TYPE(Variable% &
        & DAE_SOLVER, CheckVariable16, NullPtr0, CheckVariable18, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, NullPtr4, &
        & NullPtr5, NullPtr6, CheckVariable7, CheckVariable19, CheckVariable12, NullPtr7, NullPtr8, CheckVariable14, &
        & CheckVariable15, NullPtr9, CheckVariable6, CheckVariable17, NullPtr10, CheckVariable2, CheckVariable13, &
        & CheckVariable9, CheckVariable11, NullPtr11, NullPtr12, NullPtr13, CheckVariable0, CheckVariable3, Variable2, &
        & CheckVariable5, NullPtr14, CheckVariable8, CheckVariable10, NullPtr15, NullPtr16, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)

  
END SUBROUTINE Print_ADAMS_MOULTON_DAE_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DISTRIBUTED_VECTOR_PETSC_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER, INTENT(IN) :: CheckVariable2

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers

  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: Ptr0

  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable1)) THEN
    Variable2 => CheckVariable1
  ELSE
    Variable2 => Variable
  END IF 


  
  ! Variable%DISTRIBUTED_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DISTRIBUTED_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "DISTRIBUTED_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: DISTRIBUTED_VECTOR_PETSC_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_VECTOR_CMISS_TYPE (CheckVariable0), DISTRIBUTED_VECTOR_PETSC_TYPE (CheckVariable1), DISTRIBUTED_VECTOR_TYPE (CheckVariable2), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is type of this print routine, use Variable2
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   matches available passing type, use it as CheckVariable0

    ! if variable was already followed
    Ptr0 => Variable%DISTRIBUTED_VECTOR
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DISTRIBUTED_VECTOR"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable% &
        & DISTRIBUTED_VECTOR, CheckVariable2, Variable2, CheckVariable0, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "DISTRIBUTED_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "N:                               ", &
    & Variable%N
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_N:                        ", &
    & Variable%GLOBAL_N
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DATA_SIZE:                       ", &
    & Variable%DATA_SIZE
  
  ! Variable%GLOBAL_NUMBERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GLOBAL_NUMBERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GLOBAL_NUMBERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "GLOBAL_NUMBERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GLOBAL_NUMBERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%GLOBAL_NUMBERS,1), MIN(LBOUND(Variable%GLOBAL_NUMBERS,1)+MaxArrayLength, UBOUND(Variable% &
      & GLOBAL_NUMBERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%GLOBAL_NUMBERS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "GLOBAL_NUMBERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "USE_OVERRIDE_VECTOR:                             ", &
    & Variable%USE_OVERRIDE_VECTOR

  
END SUBROUTINE Print_DISTRIBUTED_VECTOR_PETSC_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MATRICES_RHS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2

  ! iterator variables

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: NullPtr1
  TYPE(SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: NullPtr4
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_TYPE), POINTER :: NullPtr6
  TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr8
  TYPE(REGION_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: NullPtr10
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: NullPtr11
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr12
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: NullPtr13

  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: Ptr0

  TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)

  
  ! Variable%EQUATIONS_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MATRICES_DYNAMIC_TYPE, SOLVER_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_MATRICES_RHS_TYPE, EQUATIONS_MATRICES_LINEAR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_MATRICES_SOURCE_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_MATRICES_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_RHS_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_MATRICES_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), EQUATIONS_TYPE (CheckVariable2), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EQUATIONS_MATRICES_DYNAMIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_DYNAMIC_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EQUATIONS_MATRICES_RHS_TYPE
!   is type of this print routine, use Variable2
! - signature type EQUATIONS_MATRICES_LINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_LINEAR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type EQUATIONS_MATRICES_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_SOURCE_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type EQUATIONS_MATRICES_NONLINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_NONLINEAR_TYPE

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_MATRICES
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MATRICES"
      CALL Print_EQUATIONS_MATRICES_TYPE(Variable% &
        & EQUATIONS_MATRICES, CheckVariable2, NullPtr0, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, Variable2, NullPtr4, &
        & NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "UPDATE_VECTOR:                                   ", &
    & Variable%UPDATE_VECTOR
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "FIRST_ASSEMBLY:                                  ", &
    & Variable%FIRST_ASSEMBLY
  
  ! Variable%VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "VECTOR " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_RHS_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_MATRICES_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), EQUATIONS_TYPE (CheckVariable2), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VECTOR"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%VECTOR, NullPtr11, NullPtr12, NullPtr13, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_MATRICES_RHS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EquationsSetDerivedType(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(EquationsSetDerivedType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(EquationsSetDerivedType), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable15

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr3
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr9
  TYPE(SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr16
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr19
  TYPE(MESH_TYPE), POINTER :: NullPtr20
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr21
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr23
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr24

  TYPE(EQUATIONS_SET_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(EquationsSetDerivedType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable3)) THEN
    Variable2 => CheckVariable3
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  
  ! Variable%equationsSet
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%equationsSet)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "equationsSet " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_TYPE has the following CheckVariable types: EQUATIONS_TYPE, MESHES_TYPE, EquationsSetDerivedType, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EquationsSetDerivedType (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type EquationsSetDerivedType
!   is type of this print routine, use Variable2
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable15

    ! if variable was already followed
    Ptr0 => Variable%equationsSet
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"equationsSet"
      CALL Print_EQUATIONS_SET_TYPE(Variable% &
        & equationsSet, CheckVariable1, NullPtr0, Variable2, CheckVariable12, NullPtr1, CheckVariable13, CheckVariable8, &
        & CheckVariable9, NullPtr2, NullPtr3, CheckVariable2, NullPtr4, CheckVariable5, NullPtr5, NullPtr6, NullPtr7, &
        & NullPtr8, CheckVariable0, CheckVariable4, NullPtr9, CheckVariable6, NullPtr10, CheckVariable7, NullPtr11, &
        & NullPtr12, CheckVariable10, CheckVariable11, CheckVariable14, CheckVariable15, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "equationsSet (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "derivedFinished:                                 ", &
    & Variable%derivedFinished
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "derivedFieldAutoCreated:                         ", &
    & Variable%derivedFieldAutoCreated
  
  ! Variable%derivedField
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%derivedField)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "derivedField " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EquationsSetDerivedType (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr1 => Variable%derivedField
    IF (ASSOCIATED(Ptr1, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"derivedField"
      CALL Print_FIELD_TYPE(Variable% &
        & derivedField, NullPtr0, NullPtr13, NullPtr14, NullPtr15, CheckVariable12, NullPtr1, NullPtr16, CheckVariable13, &
        & CheckVariable9, NullPtr17, NullPtr2, NullPtr3, NullPtr18, NullPtr19, NullPtr20, CheckVariable5, NullPtr5, &
        & NullPtr21, NullPtr6, NullPtr22, NullPtr7, NullPtr8, CheckVariable0, NullPtr23, CheckVariable6, CheckVariable10, &
        & NullPtr24, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "derivedField (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfVariables:               ", &
    & Variable%numberOfVariables
  
  ! Variable%variableTypes(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%variableTypes)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%variableTypes),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "variableTypes(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%variableTypes, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%variableTypes,1), MIN(LBOUND(Variable%variableTypes,1)+MaxArrayLength, UBOUND(Variable%variableTypes,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%variableTypes(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "variableTypes(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EquationsSetDerivedType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_QUASI_NEWTON_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable23

  ! iterator variables

  ! null pointers
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr7
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr9
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr12
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr13
  TYPE(FIELD_TYPE), POINTER :: NullPtr14
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr15
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr16

  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: Ptr0
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: Ptr1
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: Ptr2
  TYPE(SOLVER_TYPE), POINTER :: Ptr3

  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable1)) THEN
    Variable2 => CheckVariable1
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)

  
  ! Variable%NONLINEAR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NONLINEAR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: " // &
      & "NONLINEAR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_NONLINEAR_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: QUASI_NEWTON_SOLVER_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), QUASI_NEWTON_SOLVER_TYPE (CheckVariable1), NONLINEAR_SOLVER_TYPE (CheckVariable2), NEWTON_SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_FIXED_TYPE (CheckVariable4), CONTROL_LOOP_TIME_TYPE (CheckVariable5), OPTIMISER_SOLVER_TYPE (CheckVariable6), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable7), DYNAMIC_SOLVER_TYPE (CheckVariable8), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable9), GeometricTransformationSolverType (CheckVariable10), EIGENPROBLEM_SOLVER_TYPE (CheckVariable11), CELLML_EQUATIONS_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable16), HISTORY_TYPE (CheckVariable17), DAE_SOLVER_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), SOLVER_TYPE (CheckVariable20), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), PROBLEM_TYPE (CheckVariable23), 
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable10
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable23

    ! if variable was already followed
    Ptr0 => Variable%NONLINEAR_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NONLINEAR_SOLVER"
      CALL Print_NONLINEAR_SOLVER_TYPE(Variable% &
        & NONLINEAR_SOLVER, NullPtr0, CheckVariable0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, Variable2, CheckVariable2, &
        & CheckVariable3, CheckVariable4, CheckVariable5, NullPtr5, NullPtr6, CheckVariable6, CheckVariable7, &
        & CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, NullPtr7, CheckVariable12, CheckVariable13, &
        & CheckVariable14, CheckVariable15, NullPtr8, CheckVariable16, NullPtr9, CheckVariable17, CheckVariable18, &
        & CheckVariable19, NullPtr10, CheckVariable20, CheckVariable21, NullPtr11, NullPtr12, NullPtr13, CheckVariable22, &
        & CheckVariable23, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: " // &
      & "NONLINEAR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "QUASI_NEWTON_SOLVE_TYPE:         ", &
    & Variable%QUASI_NEWTON_SOLVE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "QUASI_NEWTON_TYPE:               ", &
    & Variable%QUASI_NEWTON_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "RESTART_TYPE:                    ", &
    & Variable%RESTART_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "RESTART:                         ", &
    & Variable%RESTART
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SCALE_TYPE:                      ", &
    & Variable%SCALE_TYPE
  Comment = ""
  IF (Variable%SOLUTION_INITIALISE_TYPE == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%SOLUTION_INITIALISE_TYPE == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%SOLUTION_INITIALISE_TYPE == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLUTION_INITIALISE_TYPE:        ", &
    & Variable%SOLUTION_INITIALISE_TYPE, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS: ", &
    & Variable%TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS: ", &
    & Variable%TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%MAXIMUM_NUMBER_OF_ITERATIONS == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%MAXIMUM_NUMBER_OF_ITERATIONS == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%MAXIMUM_NUMBER_OF_ITERATIONS == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_ITERATIONS:    ", &
    & Variable%MAXIMUM_NUMBER_OF_ITERATIONS, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS: ", &
    & Variable%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%JACOBIAN_CALCULATION_TYPE == 1) THEN
    Comment = "SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED " // & 
      & "!The Jacobian values will not be calculated for the nonlinear equations set"
  ENDIF
  IF (Variable%JACOBIAN_CALCULATION_TYPE == 2) THEN
    Comment = "SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED " // & 
      & "!The Jacobian values will be calculated analytically for the nonlinear equations set"
  ENDIF
  IF (Variable%JACOBIAN_CALCULATION_TYPE == 3) THEN
    Comment = "SOLVER_NEWTON_JACOBIAN_FD_CALCULATED " // & 
      & "!The Jacobian values will be calculated using finite differences for the nonlinear equations set"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "JACOBIAN_CALCULATION_TYPE:       ", &
    & Variable%JACOBIAN_CALCULATION_TYPE, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%convergenceTestType == 1) THEN
    Comment = "SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT " // & 
      & "!Petsc default convergence test"
  ENDIF
  IF (Variable%convergenceTestType == 2) THEN
    Comment = "SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM " // & 
      & "!Energy norm convergence test"
  ENDIF
  IF (Variable%convergenceTestType == 3) THEN
    Comment = "SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO " // & 
      & "!Sum of differentiated ratios of unconstrained to constrained residuals convergence test"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "convergenceTestType:             ", &
    & Variable%convergenceTestType, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "ABSOLUTE_TOLERANCE:          ", &
    & Variable%ABSOLUTE_TOLERANCE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "RELATIVE_TOLERANCE:          ", &
    & Variable%RELATIVE_TOLERANCE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "SOLUTION_TOLERANCE:          ", &
    & Variable%SOLUTION_TOLERANCE
  
  ! Variable%convergenceTest
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%convergenceTest)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NewtonSolverConvergenceTest), POINTER :: " // &
      & "convergenceTest " // &
      & "(associated): " 
  
! Signature of Print_NewtonSolverConvergenceTest has the following CheckVariable types: 
! The type to handle in this routine is: QUASI_NEWTON_SOLVER_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), QUASI_NEWTON_SOLVER_TYPE (CheckVariable1), NONLINEAR_SOLVER_TYPE (CheckVariable2), NEWTON_SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_FIXED_TYPE (CheckVariable4), CONTROL_LOOP_TIME_TYPE (CheckVariable5), OPTIMISER_SOLVER_TYPE (CheckVariable6), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable7), DYNAMIC_SOLVER_TYPE (CheckVariable8), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable9), GeometricTransformationSolverType (CheckVariable10), EIGENPROBLEM_SOLVER_TYPE (CheckVariable11), CELLML_EQUATIONS_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable16), HISTORY_TYPE (CheckVariable17), DAE_SOLVER_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), SOLVER_TYPE (CheckVariable20), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), PROBLEM_TYPE (CheckVariable23), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"convergenceTest"
      CALL Print_NewtonSolverConvergenceTest(Variable%convergenceTest, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NewtonSolverConvergenceTest), POINTER :: " // &
      & "convergenceTest (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%LINESEARCH_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINESEARCH_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: " // &
      & "LINESEARCH_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_QUASI_NEWTON_LINESEARCH_SOLVER_TYPE has the following CheckVariable types: QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, NEWTON_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: QUASI_NEWTON_SOLVER_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), QUASI_NEWTON_SOLVER_TYPE (CheckVariable1), NONLINEAR_SOLVER_TYPE (CheckVariable2), NEWTON_SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_FIXED_TYPE (CheckVariable4), CONTROL_LOOP_TIME_TYPE (CheckVariable5), OPTIMISER_SOLVER_TYPE (CheckVariable6), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable7), DYNAMIC_SOLVER_TYPE (CheckVariable8), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable9), GeometricTransformationSolverType (CheckVariable10), EIGENPROBLEM_SOLVER_TYPE (CheckVariable11), CELLML_EQUATIONS_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable16), HISTORY_TYPE (CheckVariable17), DAE_SOLVER_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), SOLVER_TYPE (CheckVariable20), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), PROBLEM_TYPE (CheckVariable23), 
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable21
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable10
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr1 => Variable%LINESEARCH_SOLVER
    IF (ASSOCIATED(Ptr1, CheckVariable21)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINESEARCH_SOLVER"
      CALL Print_QUASI_NEWTON_LINESEARCH_SOLVER_TYPE(Variable% &
        & LINESEARCH_SOLVER, Variable2, CheckVariable2, CheckVariable12, CheckVariable18, CheckVariable19, CheckVariable3, &
        & CheckVariable20, CheckVariable21, CheckVariable14, CheckVariable22, CheckVariable15, CheckVariable6, &
        & CheckVariable13, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: " // &
      & "LINESEARCH_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%TRUSTREGION_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%TRUSTREGION_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: " // &
      & "TRUSTREGION_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE has the following CheckVariable types: QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, NEWTON_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: QUASI_NEWTON_SOLVER_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), QUASI_NEWTON_SOLVER_TYPE (CheckVariable1), NONLINEAR_SOLVER_TYPE (CheckVariable2), NEWTON_SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_FIXED_TYPE (CheckVariable4), CONTROL_LOOP_TIME_TYPE (CheckVariable5), OPTIMISER_SOLVER_TYPE (CheckVariable6), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable7), DYNAMIC_SOLVER_TYPE (CheckVariable8), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable9), GeometricTransformationSolverType (CheckVariable10), EIGENPROBLEM_SOLVER_TYPE (CheckVariable11), CELLML_EQUATIONS_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable16), HISTORY_TYPE (CheckVariable17), DAE_SOLVER_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), SOLVER_TYPE (CheckVariable20), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), PROBLEM_TYPE (CheckVariable23), 
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable14
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable10
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr2 => Variable%TRUSTREGION_SOLVER
    IF (ASSOCIATED(Ptr2, CheckVariable14)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TRUSTREGION_SOLVER"
      CALL Print_QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE(Variable% &
        & TRUSTREGION_SOLVER, Variable2, CheckVariable2, CheckVariable12, CheckVariable18, CheckVariable19, CheckVariable3, &
        & CheckVariable20, CheckVariable21, CheckVariable14, CheckVariable22, CheckVariable15, CheckVariable6, &
        & CheckVariable13, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: " // &
      & "TRUSTREGION_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%LINEAR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINEAR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "LINEAR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: QUASI_NEWTON_SOLVER_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), QUASI_NEWTON_SOLVER_TYPE (CheckVariable1), NONLINEAR_SOLVER_TYPE (CheckVariable2), NEWTON_SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_FIXED_TYPE (CheckVariable4), CONTROL_LOOP_TIME_TYPE (CheckVariable5), OPTIMISER_SOLVER_TYPE (CheckVariable6), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable7), DYNAMIC_SOLVER_TYPE (CheckVariable8), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable9), GeometricTransformationSolverType (CheckVariable10), EIGENPROBLEM_SOLVER_TYPE (CheckVariable11), CELLML_EQUATIONS_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable16), HISTORY_TYPE (CheckVariable17), DAE_SOLVER_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), SOLVER_TYPE (CheckVariable20), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), PROBLEM_TYPE (CheckVariable23), 
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable10
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable20
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable23

    ! if variable was already followed
    Ptr3 => Variable%LINEAR_SOLVER
    IF (ASSOCIATED(Ptr3, CheckVariable20)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINEAR_SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & LINEAR_SOLVER, NullPtr0, CheckVariable0, NullPtr14, NullPtr1, NullPtr2, NullPtr3, NullPtr4, Variable2, &
        & CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, NullPtr5, NullPtr6, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, NullPtr7, CheckVariable12, &
        & CheckVariable13, NullPtr11, NullPtr15, CheckVariable15, NullPtr8, CheckVariable16, NullPtr9, CheckVariable17, &
        & CheckVariable18, CheckVariable19, NullPtr10, CheckVariable20, CheckVariable21, CheckVariable14, NullPtr12, &
        & NullPtr13, NullPtr16, CheckVariable22, CheckVariable23, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "LINEAR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CELLML_EVALUATOR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CELLML_EVALUATOR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "CELLML_EVALUATOR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: QUASI_NEWTON_SOLVER_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), QUASI_NEWTON_SOLVER_TYPE (CheckVariable1), NONLINEAR_SOLVER_TYPE (CheckVariable2), NEWTON_SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_FIXED_TYPE (CheckVariable4), CONTROL_LOOP_TIME_TYPE (CheckVariable5), OPTIMISER_SOLVER_TYPE (CheckVariable6), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable7), DYNAMIC_SOLVER_TYPE (CheckVariable8), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable9), GeometricTransformationSolverType (CheckVariable10), EIGENPROBLEM_SOLVER_TYPE (CheckVariable11), CELLML_EQUATIONS_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable16), HISTORY_TYPE (CheckVariable17), DAE_SOLVER_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), SOLVER_TYPE (CheckVariable20), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), PROBLEM_TYPE (CheckVariable23), 
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable10
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable20
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable23

    ! if variable was already followed
    Ptr3 => Variable%CELLML_EVALUATOR_SOLVER
    IF (ASSOCIATED(Ptr3, CheckVariable20)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML_EVALUATOR_SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & CELLML_EVALUATOR_SOLVER, NullPtr0, CheckVariable0, NullPtr14, NullPtr1, NullPtr2, NullPtr3, NullPtr4, Variable2, &
        & CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, NullPtr5, NullPtr6, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, NullPtr7, CheckVariable12, &
        & CheckVariable13, NullPtr11, NullPtr15, CheckVariable15, NullPtr8, CheckVariable16, NullPtr9, CheckVariable17, &
        & CheckVariable18, CheckVariable19, NullPtr10, CheckVariable20, CheckVariable21, CheckVariable14, NullPtr12, &
        & NullPtr13, NullPtr16, CheckVariable22, CheckVariable23, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "CELLML_EVALUATOR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_QUASI_NEWTON_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_INTERPOLATED_POINT_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_FIELD_INTERPOLATED_POINT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_INTERPOLATED_POINT_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_FIELD_INTERPOLATED_POINT_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELD_INTERPOLATED_POINT_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable29

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(CELLML_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr2
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr3
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr4
  TYPE(MeshComponentTopologyType), POINTER :: NullPtr5
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr6
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: NullPtr7
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: NullPtr8
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: NullPtr9

  TYPE(INTERFACES_TYPE), POINTER :: Ptr0
  TYPE(REGION_TYPE), POINTER :: Ptr1
  TYPE(MESH_PTR_TYPE), POINTER :: Ptr2
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: Ptr3
  TYPE(InterfacePointsConnectivityType), POINTER :: Ptr4
  TYPE(DATA_POINTS_TYPE), POINTER :: Ptr5
  TYPE(NODES_TYPE), POINTER :: Ptr6
  TYPE(MESHES_TYPE), POINTER :: Ptr7
  TYPE(GENERATED_MESHES_TYPE), POINTER :: Ptr8
  TYPE(FIELDS_TYPE), POINTER :: Ptr9
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: Ptr10

  TYPE(INTERFACE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable10)) THEN
    Variable2 => CheckVariable10
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "INTERFACE_FINISHED:                              ", &
    & Variable%INTERFACE_FINISHED
  
  ! Variable%COORDINATE_SYSTEM
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%COORDINATE_SYSTEM)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: " // &
      & "COORDINATE_SYSTEM " // &
      & "(associated): " 
  
! Signature of Print_COORDINATE_SYSTEM_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), MESH_TYPE (CheckVariable16), MeshComponentTopologyPtrType (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"COORDINATE_SYSTEM"
      CALL Print_COORDINATE_SYSTEM_TYPE(Variable%COORDINATE_SYSTEM, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: " // &
      & "COORDINATE_SYSTEM (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACES_TYPE), POINTER :: " // &
      & "INTERFACES " // &
      & "(associated): " 
  
! Signature of Print_INTERFACES_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), MESH_TYPE (CheckVariable16), MeshComponentTopologyPtrType (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

    ! if variable was already followed
    Ptr0 => Variable%INTERFACES
    IF (ASSOCIATED(Ptr0, CheckVariable22)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACES"
      CALL Print_INTERFACES_TYPE(Variable% &
        & INTERFACES, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, Variable2, CheckVariable11, CheckVariable12, CheckVariable13, &
        & NullPtr0, CheckVariable16, CheckVariable18, CheckVariable19, CheckVariable21, CheckVariable22, CheckVariable23, &
        & CheckVariable24, CheckVariable25, CheckVariable27, NullPtr1, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACES_TYPE), POINTER :: " // &
      & "INTERFACES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%PARENT_REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PARENT_REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "PARENT_REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), MESH_TYPE (CheckVariable16), MeshComponentTopologyPtrType (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   is type of this print routine, use Variable2
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable29

    ! if variable was already followed
    Ptr1 => Variable%PARENT_REGION
    IF (ASSOCIATED(Ptr1, CheckVariable29)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PARENT_REGION"
      CALL Print_REGION_TYPE(Variable% &
        & PARENT_REGION, CheckVariable1, CheckVariable2, CheckVariable3, NullPtr2, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, Variable2, NullPtr3, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, NullPtr0, CheckVariable16, CheckVariable18, CheckVariable19, &
        & CheckVariable20, CheckVariable21, NullPtr4, CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, &
        & CheckVariable26, CheckVariable27, NullPtr1, CheckVariable28, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "PARENT_REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COUPLED_MESHES:        ", &
    & Variable%NUMBER_OF_COUPLED_MESHES
  
  ! Variable%COUPLED_MESHES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%COUPLED_MESHES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_PTR_TYPE), POINTER :: " // &
      & "COUPLED_MESHES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%COUPLED_MESHES,1), "): "
  
    DO I0 = LBOUND(Variable%COUPLED_MESHES,1), MIN(LBOUND(Variable%COUPLED_MESHES,1)+MaxArrayLength, UBOUND(Variable% &
      & COUPLED_MESHES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_MESH_PTR_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, DECOMPOSITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), MESH_TYPE (CheckVariable16), MeshComponentTopologyPtrType (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

      ! if variable was already followed
      Ptr2 => Variable%COUPLED_MESHES(I0)
      IF (ASSOCIATED(Ptr2, CheckVariable2)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"COUPLED_MESHES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_MESH_PTR_TYPE(Variable% &
          & COUPLED_MESHES(I0), NullPtr5, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, &
          & CheckVariable6, CheckVariable7, CheckVariable8, Variable2, CheckVariable11, CheckVariable12, CheckVariable13, &
          & NullPtr6, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, &
          & CheckVariable22, CheckVariable23, CheckVariable25, CheckVariable27, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_PTR_TYPE), POINTER :: " // &
      & "COUPLED_MESHES(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MESH_CONNECTIVITY
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MESH_CONNECTIVITY)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: " // &
      & "MESH_CONNECTIVITY " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_MESH_CONNECTIVITY_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), MESH_TYPE (CheckVariable16), MeshComponentTopologyPtrType (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

    ! if variable was already followed
    Ptr3 => Variable%MESH_CONNECTIVITY
    IF (ASSOCIATED(Ptr3, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MESH_CONNECTIVITY"
      CALL Print_INTERFACE_MESH_CONNECTIVITY_TYPE(Variable% &
        & MESH_CONNECTIVITY, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, Variable2, CheckVariable11, CheckVariable12, CheckVariable13, &
        & CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, &
        & CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable27, &
        & CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: " // &
      & "MESH_CONNECTIVITY (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%pointsConnectivity
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%pointsConnectivity)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(InterfacePointsConnectivityType), POINTER :: " // &
      & "pointsConnectivity " // &
      & "(associated): " 
  
! Signature of Print_InterfacePointsConnectivityType has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), MESH_TYPE (CheckVariable16), MeshComponentTopologyPtrType (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

    ! if variable was already followed
    Ptr4 => Variable%pointsConnectivity
    IF (ASSOCIATED(Ptr4, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"pointsConnectivity"
      CALL Print_InterfacePointsConnectivityType(Variable% &
        & pointsConnectivity, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, Variable2, CheckVariable11, CheckVariable12, CheckVariable13, &
        & CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, &
        & CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable27, &
        & CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(InterfacePointsConnectivityType), POINTER :: " // &
      & "pointsConnectivity (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DATA_POINTS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DATA_POINTS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DATA_POINTS_TYPE), POINTER :: " // &
      & "DATA_POINTS " // &
      & "(associated): " 
  
! Signature of Print_DATA_POINTS_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), MESH_TYPE (CheckVariable16), MeshComponentTopologyPtrType (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

    ! if variable was already followed
    Ptr5 => Variable%DATA_POINTS
    IF (ASSOCIATED(Ptr5, CheckVariable23)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DATA_POINTS"
      CALL Print_DATA_POINTS_TYPE(Variable% &
        & DATA_POINTS, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, Variable2, CheckVariable11, CheckVariable12, CheckVariable13, &
        & NullPtr0, CheckVariable15, CheckVariable16, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, &
        & CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, NullPtr1, &
        & CheckVariable28, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DATA_POINTS_TYPE), POINTER :: " // &
      & "DATA_POINTS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%NODES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NODES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NODES_TYPE), POINTER :: " // &
      & "NODES " // &
      & "(associated): " 
  
! Signature of Print_NODES_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), MESH_TYPE (CheckVariable16), MeshComponentTopologyPtrType (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

    ! if variable was already followed
    Ptr6 => Variable%NODES
    IF (ASSOCIATED(Ptr6, CheckVariable21)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NODES"
      CALL Print_NODES_TYPE(Variable% &
        & NODES, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, Variable2, CheckVariable11, CheckVariable12, CheckVariable13, &
        & NullPtr0, CheckVariable15, CheckVariable16, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, &
        & CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable27, NullPtr1, CheckVariable29, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NODES_TYPE), POINTER :: " // &
      & "NODES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MESHES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MESHES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESHES_TYPE), POINTER :: " // &
      & "MESHES " // &
      & "(associated): " 
  
! Signature of Print_MESHES_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), MESH_TYPE (CheckVariable16), MeshComponentTopologyPtrType (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

    ! if variable was already followed
    Ptr7 => Variable%MESHES
    IF (ASSOCIATED(Ptr7, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MESHES"
      CALL Print_MESHES_TYPE(Variable% &
        & MESHES, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, Variable2, CheckVariable11, CheckVariable12, CheckVariable13, &
        & NullPtr0, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, &
        & CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable27, NullPtr1, &
        & CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESHES_TYPE), POINTER :: " // &
      & "MESHES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%GENERATED_MESHES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GENERATED_MESHES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GENERATED_MESHES_TYPE), POINTER :: " // &
      & "GENERATED_MESHES " // &
      & "(associated): " 
  
! Signature of Print_GENERATED_MESHES_TYPE has the following CheckVariable types: MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), MESH_TYPE (CheckVariable16), MeshComponentTopologyPtrType (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_CYLINDER_TYPE
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_ELLIPSOID_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_REGULAR_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

    ! if variable was already followed
    Ptr8 => Variable%GENERATED_MESHES
    IF (ASSOCIATED(Ptr8, CheckVariable19)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GENERATED_MESHES"
      CALL Print_GENERATED_MESHES_TYPE(Variable% &
        & GENERATED_MESHES, CheckVariable1, NullPtr7, CheckVariable2, CheckVariable3, NullPtr8, CheckVariable4, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, Variable2, CheckVariable11, &
        & CheckVariable12, CheckVariable13, NullPtr0, CheckVariable15, CheckVariable16, CheckVariable18, CheckVariable19, &
        & CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, NullPtr9, &
        & CheckVariable27, NullPtr1, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GENERATED_MESHES_TYPE), POINTER :: " // &
      & "GENERATED_MESHES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%FIELDS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELDS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELDS_TYPE), POINTER :: " // &
      & "FIELDS " // &
      & "(associated): " 
  
! Signature of Print_FIELDS_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), MESH_TYPE (CheckVariable16), MeshComponentTopologyPtrType (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type FIELDS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

    ! if variable was already followed
    Ptr9 => Variable%FIELDS
    IF (ASSOCIATED(Ptr9, CheckVariable18)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELDS"
      CALL Print_FIELDS_TYPE(Variable% &
        & FIELDS, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, Variable2, CheckVariable11, CheckVariable12, CheckVariable13, &
        & NullPtr0, CheckVariable15, CheckVariable16, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, &
        & NullPtr4, CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, &
        & NullPtr1, CheckVariable28, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELDS_TYPE), POINTER :: " // &
      & "FIELDS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE_CONDITIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_CONDITIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITIONS " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_CONDITIONS_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), INTERFACE_CONDITION_PTR_TYPE (CheckVariable15), MESH_TYPE (CheckVariable16), MeshComponentTopologyPtrType (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), INTERFACES_TYPE (CheckVariable22), DATA_POINTS_TYPE (CheckVariable23), GENERATED_MESH_PTR_TYPE (CheckVariable24), DATA_PROJECTION_TYPE (CheckVariable25), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable26), DECOMPOSITION_TYPE (CheckVariable27), FIELD_VARIABLE_TYPE (CheckVariable28), REGION_TYPE (CheckVariable29), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable29

    ! if variable was already followed
    Ptr10 => Variable%INTERFACE_CONDITIONS
    IF (ASSOCIATED(Ptr10, CheckVariable3)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_CONDITIONS"
      CALL Print_INTERFACE_CONDITIONS_TYPE(Variable% &
        & INTERFACE_CONDITIONS, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, Variable2, CheckVariable11, CheckVariable12, &
        & CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable18, CheckVariable19, &
        & CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, &
        & CheckVariable27, CheckVariable29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITIONS (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_SET_ANALYTIC_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(EquationsSetDerivedType), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable15

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr3
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr9
  TYPE(SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr16
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr19
  TYPE(MESH_TYPE), POINTER :: NullPtr20
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr21
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr23
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr24

  TYPE(EQUATIONS_SET_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable4)) THEN
    Variable2 => CheckVariable4
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  
  ! Variable%EQUATIONS_SET
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SET)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_TYPE has the following CheckVariable types: EQUATIONS_TYPE, MESHES_TYPE, EquationsSetDerivedType, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_ANALYTIC_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable15

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_SET
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SET"
      CALL Print_EQUATIONS_SET_TYPE(Variable% &
        & EQUATIONS_SET, CheckVariable1, NullPtr0, CheckVariable3, CheckVariable12, NullPtr1, CheckVariable13, &
        & CheckVariable8, CheckVariable9, NullPtr2, NullPtr3, CheckVariable2, NullPtr4, CheckVariable5, NullPtr5, NullPtr6, &
        & NullPtr7, NullPtr8, CheckVariable0, Variable2, NullPtr9, CheckVariable6, NullPtr10, CheckVariable7, NullPtr11, &
        & NullPtr12, CheckVariable10, CheckVariable11, CheckVariable14, CheckVariable15, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ANALYTIC_FUNCTION_TYPE:          ", &
    & Variable%ANALYTIC_FUNCTION_TYPE
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "ANALYTIC_FINISHED:                               ", &
    & Variable%ANALYTIC_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "ANALYTIC_FIELD_AUTO_CREATED:                     ", &
    & Variable%ANALYTIC_FIELD_AUTO_CREATED
  
  ! Variable%ANALYTIC_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ANALYTIC_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "ANALYTIC_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_ANALYTIC_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr1 => Variable%ANALYTIC_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ANALYTIC_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & ANALYTIC_FIELD, NullPtr0, NullPtr13, NullPtr14, NullPtr15, CheckVariable12, NullPtr1, NullPtr16, CheckVariable13, &
        & CheckVariable9, NullPtr17, NullPtr2, NullPtr3, NullPtr18, NullPtr19, NullPtr20, CheckVariable5, NullPtr5, &
        & NullPtr21, NullPtr6, NullPtr22, NullPtr7, NullPtr8, CheckVariable0, NullPtr23, CheckVariable6, CheckVariable10, &
        & NullPtr24, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "ANALYTIC_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "ANALYTIC_TIME:               ", &
    & Variable%ANALYTIC_TIME
    PRINT*," "
    DO I0 = LBOUND(Variable%ANALYTIC_USER_PARAMS,1), 20
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ANALYTIC_USER_PARAMS(I0)

    ENDDO  ! I0

  
END SUBROUTINE Print_EQUATIONS_SET_ANALYTIC_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MAPPING_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER, INTENT(IN) :: CheckVariable12

  ! iterator variables

  ! null pointers
  TYPE(EquationsSetDerivedType), POINTER :: NullPtr0
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: NullPtr2
  TYPE(FIELDS_TYPE), POINTER :: NullPtr3
  TYPE(SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: NullPtr5
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: NullPtr6
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr8
  TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: NullPtr10
  TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: NullPtr11
  TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: NullPtr12
  TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: NullPtr13
  TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER :: NullPtr14
  TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: NullPtr15

  TYPE(EQUATIONS_TYPE), POINTER :: Ptr0
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: Ptr1
  TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER :: Ptr2
  TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER :: Ptr3
  TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER :: Ptr4
  TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER :: Ptr5
  TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER :: Ptr6

  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)

  
  ! Variable%EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, BOUNDARY_CONDITIONS_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_SET_MATERIALS_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_TYPE, EQUATIONS_INTERPOLATION_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MAPPING_LINEAR_TYPE (CheckVariable2), EQUATIONS_MAPPING_DYNAMIC_TYPE (CheckVariable3), EQUATIONS_MAPPING_RHS_TYPE (CheckVariable4), EQUATIONS_MATRICES_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_SETS_TYPE (CheckVariable10), EQUATIONS_MAPPING_SOURCE_TYPE (CheckVariable11), EQUATIONS_MAPPING_NONLINEAR_TYPE (CheckVariable12), 
! - signature type EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EquationsSetDerivedType
!   is not available in passing variables, use NullPtr of type EquationsSetDerivedType
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_ANALYTIC_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type EQUATIONS_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_MATERIALS_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type EQUATIONS_INTERPOLATION_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_INTERPOLATION_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_INDEPENDENT_TYPE

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS"
      CALL Print_EQUATIONS_TYPE(Variable% &
        & EQUATIONS, CheckVariable0, CheckVariable1, NullPtr0, NullPtr1, NullPtr2, NullPtr3, CheckVariable5, NullPtr4, &
        & NullPtr5, Variable2, CheckVariable6, NullPtr6, NullPtr7, CheckVariable8, CheckVariable9, NullPtr8, NullPtr9, &
        & CheckVariable10, CheckVariable7, NullPtr10, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "EQUATIONS_MAPPING_FINISHED:                      ", &
    & Variable%EQUATIONS_MAPPING_FINISHED
  
  ! Variable%EQUATIONS_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MATRICES_DYNAMIC_TYPE, SOLVER_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_MATRICES_RHS_TYPE, EQUATIONS_MATRICES_LINEAR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_MATRICES_SOURCE_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_MATRICES_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MAPPING_LINEAR_TYPE (CheckVariable2), EQUATIONS_MAPPING_DYNAMIC_TYPE (CheckVariable3), EQUATIONS_MAPPING_RHS_TYPE (CheckVariable4), EQUATIONS_MATRICES_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_SETS_TYPE (CheckVariable10), EQUATIONS_MAPPING_SOURCE_TYPE (CheckVariable11), EQUATIONS_MAPPING_NONLINEAR_TYPE (CheckVariable12), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EQUATIONS_MATRICES_DYNAMIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_DYNAMIC_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_MATRICES_RHS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_RHS_TYPE
! - signature type EQUATIONS_MATRICES_LINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_LINEAR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EQUATIONS_MATRICES_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_SOURCE_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_MATRICES_NONLINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_NONLINEAR_TYPE

    ! if variable was already followed
    Ptr1 => Variable%EQUATIONS_MATRICES
    IF (ASSOCIATED(Ptr1, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MATRICES"
      CALL Print_EQUATIONS_MATRICES_TYPE(Variable% &
        & EQUATIONS_MATRICES, CheckVariable0, CheckVariable1, NullPtr11, NullPtr4, Variable2, CheckVariable6, NullPtr12, &
        & NullPtr13, CheckVariable8, CheckVariable9, NullPtr14, CheckVariable10, CheckVariable7, NullPtr15, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ROWS:                  ", &
    & Variable%NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_ROWS:            ", &
    & Variable%TOTAL_NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_ROWS:           ", &
    & Variable%NUMBER_OF_GLOBAL_ROWS
  
  ! Variable%ROW_DOFS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ROW_DOFS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "ROW_DOFS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MAPPING_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MAPPING_LINEAR_TYPE (CheckVariable2), EQUATIONS_MAPPING_DYNAMIC_TYPE (CheckVariable3), EQUATIONS_MAPPING_RHS_TYPE (CheckVariable4), EQUATIONS_MATRICES_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_SETS_TYPE (CheckVariable10), EQUATIONS_MAPPING_SOURCE_TYPE (CheckVariable11), EQUATIONS_MAPPING_NONLINEAR_TYPE (CheckVariable12), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ROW_DOFS_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%ROW_DOFS_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "ROW_DOFS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DYNAMIC_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DYNAMIC_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER :: " // &
      & "DYNAMIC_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_DYNAMIC_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_MAPPING_TYPE, REGION_TYPE, FIELD_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MAPPING_LINEAR_TYPE (CheckVariable2), EQUATIONS_MAPPING_DYNAMIC_TYPE (CheckVariable3), EQUATIONS_MAPPING_RHS_TYPE (CheckVariable4), EQUATIONS_MATRICES_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_SETS_TYPE (CheckVariable10), EQUATIONS_MAPPING_SOURCE_TYPE (CheckVariable11), EQUATIONS_MAPPING_NONLINEAR_TYPE (CheckVariable12), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9

    ! if variable was already followed
    Ptr2 => Variable%DYNAMIC_MAPPING
    IF (ASSOCIATED(Ptr2, CheckVariable3)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DYNAMIC_MAPPING"
      CALL Print_EQUATIONS_MAPPING_DYNAMIC_TYPE(Variable% &
        & DYNAMIC_MAPPING, CheckVariable0, Variable2, CheckVariable7, CheckVariable9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER :: " // &
      & "DYNAMIC_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%LINEAR_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINEAR_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER :: " // &
      & "LINEAR_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_LINEAR_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_MAPPING_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MAPPING_LINEAR_TYPE (CheckVariable2), EQUATIONS_MAPPING_DYNAMIC_TYPE (CheckVariable3), EQUATIONS_MAPPING_RHS_TYPE (CheckVariable4), EQUATIONS_MATRICES_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_SETS_TYPE (CheckVariable10), EQUATIONS_MAPPING_SOURCE_TYPE (CheckVariable11), EQUATIONS_MAPPING_NONLINEAR_TYPE (CheckVariable12), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_MAPPING_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr3 => Variable%LINEAR_MAPPING
    IF (ASSOCIATED(Ptr3, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINEAR_MAPPING"
      CALL Print_EQUATIONS_MAPPING_LINEAR_TYPE(Variable% &
        & LINEAR_MAPPING, CheckVariable0, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER :: " // &
      & "LINEAR_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%NONLINEAR_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NONLINEAR_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER :: " // &
      & "NONLINEAR_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_NONLINEAR_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_MAPPING_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MAPPING_LINEAR_TYPE (CheckVariable2), EQUATIONS_MAPPING_DYNAMIC_TYPE (CheckVariable3), EQUATIONS_MAPPING_RHS_TYPE (CheckVariable4), EQUATIONS_MATRICES_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_SETS_TYPE (CheckVariable10), EQUATIONS_MAPPING_SOURCE_TYPE (CheckVariable11), EQUATIONS_MAPPING_NONLINEAR_TYPE (CheckVariable12), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_MAPPING_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr4 => Variable%NONLINEAR_MAPPING
    IF (ASSOCIATED(Ptr4, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NONLINEAR_MAPPING"
      CALL Print_EQUATIONS_MAPPING_NONLINEAR_TYPE(Variable% &
        & NONLINEAR_MAPPING, CheckVariable0, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER :: " // &
      & "NONLINEAR_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%RHS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RHS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER :: " // &
      & "RHS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_RHS_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_MAPPING_TYPE, REGION_TYPE, FIELD_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MAPPING_LINEAR_TYPE (CheckVariable2), EQUATIONS_MAPPING_DYNAMIC_TYPE (CheckVariable3), EQUATIONS_MAPPING_RHS_TYPE (CheckVariable4), EQUATIONS_MATRICES_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_SETS_TYPE (CheckVariable10), EQUATIONS_MAPPING_SOURCE_TYPE (CheckVariable11), EQUATIONS_MAPPING_NONLINEAR_TYPE (CheckVariable12), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9

    ! if variable was already followed
    Ptr5 => Variable%RHS_MAPPING
    IF (ASSOCIATED(Ptr5, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RHS_MAPPING"
      CALL Print_EQUATIONS_MAPPING_RHS_TYPE(Variable% &
        & RHS_MAPPING, CheckVariable0, Variable2, CheckVariable7, CheckVariable9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER :: " // &
      & "RHS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOURCE_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOURCE_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER :: " // &
      & "SOURCE_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_SOURCE_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_MAPPING_TYPE, REGION_TYPE, FIELD_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MAPPING_LINEAR_TYPE (CheckVariable2), EQUATIONS_MAPPING_DYNAMIC_TYPE (CheckVariable3), EQUATIONS_MAPPING_RHS_TYPE (CheckVariable4), EQUATIONS_MATRICES_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_SETS_TYPE (CheckVariable10), EQUATIONS_MAPPING_SOURCE_TYPE (CheckVariable11), EQUATIONS_MAPPING_NONLINEAR_TYPE (CheckVariable12), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9

    ! if variable was already followed
    Ptr6 => Variable%SOURCE_MAPPING
    IF (ASSOCIATED(Ptr6, CheckVariable11)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOURCE_MAPPING"
      CALL Print_EQUATIONS_MAPPING_SOURCE_TYPE(Variable% &
        & SOURCE_MAPPING, CheckVariable0, Variable2, CheckVariable7, CheckVariable9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER :: " // &
      & "SOURCE_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CREATE_VALUES_CACHE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CREATE_VALUES_CACHE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER :: " // &
      & "CREATE_VALUES_CACHE " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_CREATE_VALUES_CACHE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MAPPING_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MAPPING_LINEAR_TYPE (CheckVariable2), EQUATIONS_MAPPING_DYNAMIC_TYPE (CheckVariable3), EQUATIONS_MAPPING_RHS_TYPE (CheckVariable4), EQUATIONS_MATRICES_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_SETS_TYPE (CheckVariable10), EQUATIONS_MAPPING_SOURCE_TYPE (CheckVariable11), EQUATIONS_MAPPING_NONLINEAR_TYPE (CheckVariable12), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CREATE_VALUES_CACHE"
      CALL Print_EQUATIONS_MAPPING_CREATE_VALUES_CACHE_TYPE(Variable%CREATE_VALUES_CACHE, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER :: " // &
      & "CREATE_VALUES_CACHE (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_MAPPING_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_QUADRATURE_SCHEME_TYPE(Variable, CheckVariable0, CheckVariable1, Depth, MaxDepth, MaxArrayLength)
  TYPE(QUADRATURE_SCHEME_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BASIS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(QUADRATURE_SCHEME_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1, I2, I3
  CHARACTER(LEN=30) :: I0_STR, I1_STR, I2_STR, I3_STR

  ! null pointers
  TYPE(BASIS_PTR_TYPE), POINTER :: NullPtr0


  TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  
  ! Variable%QUADRATURE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%QUADRATURE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(QUADRATURE_TYPE), POINTER :: " // &
      & "QUADRATURE " // &
      & "(associated): " 
  
! Signature of Print_QUADRATURE_TYPE has the following CheckVariable types: BASIS_TYPE, QUADRATURE_SCHEME_PTR_TYPE, QUADRATURE_SCHEME_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: QUADRATURE_SCHEME_TYPE (Variable)
! Available CheckVariables are: BASIS_TYPE (CheckVariable0), QUADRATURE_SCHEME_PTR_TYPE (CheckVariable1), 
! - signature type BASIS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type QUADRATURE_SCHEME_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type QUADRATURE_SCHEME_TYPE
!   is type of this print routine, use Variable2
! - signature type BASIS_PTR_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_PTR_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"QUADRATURE"
      CALL Print_QUADRATURE_TYPE(Variable% &
        & QUADRATURE, CheckVariable0, CheckVariable1, Variable2, NullPtr0, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(QUADRATURE_TYPE), POINTER :: " // &
      & "QUADRATURE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GAUSS:                 ", &
    & Variable%NUMBER_OF_GAUSS
  
  ! Variable%GAUSS_POSITIONS(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GAUSS_POSITIONS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GAUSS_POSITIONS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "GAUSS_POSITIONS(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GAUSS_POSITIONS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%GAUSS_POSITIONS,1), MIN(LBOUND(Variable%GAUSS_POSITIONS,1)+MaxArrayLength, UBOUND(Variable% &
      & GAUSS_POSITIONS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%GAUSS_POSITIONS,2), MIN(LBOUND(Variable%GAUSS_POSITIONS,2)+MaxArrayLength, UBOUND(Variable% &
        & GAUSS_POSITIONS,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%GAUSS_POSITIONS(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "GAUSS_POSITIONS(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%GAUSS_WEIGHTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GAUSS_WEIGHTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GAUSS_WEIGHTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "GAUSS_WEIGHTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GAUSS_WEIGHTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%GAUSS_WEIGHTS,1), MIN(LBOUND(Variable%GAUSS_WEIGHTS,1)+MaxArrayLength, UBOUND(Variable%GAUSS_WEIGHTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%GAUSS_WEIGHTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "GAUSS_WEIGHTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%GAUSS_BASIS_FNS(:,:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GAUSS_BASIS_FNS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GAUSS_BASIS_FNS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "GAUSS_BASIS_FNS(:,:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GAUSS_BASIS_FNS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%GAUSS_BASIS_FNS,1), MIN(LBOUND(Variable%GAUSS_BASIS_FNS,1)+MaxArrayLength, UBOUND(Variable% &
      & GAUSS_BASIS_FNS,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%GAUSS_BASIS_FNS,2), MIN(LBOUND(Variable%GAUSS_BASIS_FNS,2)+MaxArrayLength, UBOUND(Variable% &
        & GAUSS_BASIS_FNS,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//","//TRIM(ADJUSTL(I1_STR))//",*): "
        DO I2 = LBOUND(Variable%GAUSS_BASIS_FNS,3), MIN(LBOUND(Variable%GAUSS_BASIS_FNS,3)+MaxArrayLength, UBOUND(Variable% &
          & GAUSS_BASIS_FNS,3))
          WRITE(I2_STR,"(I4)") I2 

          PRINT*, TRIM(PrintIndent), Variable%GAUSS_BASIS_FNS(I0,I1,I2)

        ENDDO  ! I2
      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "GAUSS_BASIS_FNS(:,:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NUMBER_OF_FACE_GAUSS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_FACE_GAUSS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_FACE_GAUSS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_FACE_GAUSS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_FACE_GAUSS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_FACE_GAUSS,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_FACE_GAUSS,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_FACE_GAUSS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_FACE_GAUSS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_FACE_GAUSS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%FACE_GAUSS_BASIS_FNS(:,:,:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%FACE_GAUSS_BASIS_FNS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%FACE_GAUSS_BASIS_FNS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "FACE_GAUSS_BASIS_FNS(:,:,:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%FACE_GAUSS_BASIS_FNS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%FACE_GAUSS_BASIS_FNS,1), MIN(LBOUND(Variable% &
      & FACE_GAUSS_BASIS_FNS,1)+MaxArrayLength, UBOUND(Variable%FACE_GAUSS_BASIS_FNS,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%FACE_GAUSS_BASIS_FNS,2), MIN(LBOUND(Variable% &
        & FACE_GAUSS_BASIS_FNS,2)+MaxArrayLength, UBOUND(Variable%FACE_GAUSS_BASIS_FNS,2))
        WRITE(I1_STR,"(I4)") I1 

        DO I2 = LBOUND(Variable%FACE_GAUSS_BASIS_FNS,3), MIN(LBOUND(Variable% &
          & FACE_GAUSS_BASIS_FNS,3)+MaxArrayLength, UBOUND(Variable%FACE_GAUSS_BASIS_FNS,3))
          WRITE(I2_STR,"(I4)") I2 

          PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//","//TRIM(ADJUSTL(I1_STR))//","//TRIM(ADJUSTL(I2_STR))//",*): "
          DO I3 = LBOUND(Variable%FACE_GAUSS_BASIS_FNS,4), MIN(LBOUND(Variable% &
            & FACE_GAUSS_BASIS_FNS,4)+MaxArrayLength, UBOUND(Variable%FACE_GAUSS_BASIS_FNS,4))
            WRITE(I3_STR,"(I4)") I3 

            PRINT*, TRIM(PrintIndent), Variable%FACE_GAUSS_BASIS_FNS(I0,I1,I2,I3)

          ENDDO  ! I3
        ENDDO  ! I2
      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "FACE_GAUSS_BASIS_FNS(:,:,:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%FACE_GAUSS_POSITIONS(:,:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%FACE_GAUSS_POSITIONS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%FACE_GAUSS_POSITIONS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "FACE_GAUSS_POSITIONS(:,:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%FACE_GAUSS_POSITIONS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%FACE_GAUSS_POSITIONS,1), MIN(LBOUND(Variable% &
      & FACE_GAUSS_POSITIONS,1)+MaxArrayLength, UBOUND(Variable%FACE_GAUSS_POSITIONS,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%FACE_GAUSS_POSITIONS,2), MIN(LBOUND(Variable% &
        & FACE_GAUSS_POSITIONS,2)+MaxArrayLength, UBOUND(Variable%FACE_GAUSS_POSITIONS,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//","//TRIM(ADJUSTL(I1_STR))//",*): "
        DO I2 = LBOUND(Variable%FACE_GAUSS_POSITIONS,3), MIN(LBOUND(Variable% &
          & FACE_GAUSS_POSITIONS,3)+MaxArrayLength, UBOUND(Variable%FACE_GAUSS_POSITIONS,3))
          WRITE(I2_STR,"(I4)") I2 

          PRINT*, TRIM(PrintIndent), Variable%FACE_GAUSS_POSITIONS(I0,I1,I2)

        ENDDO  ! I2
      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "FACE_GAUSS_POSITIONS(:,:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%FACE_GAUSS_WEIGHTS(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%FACE_GAUSS_WEIGHTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%FACE_GAUSS_WEIGHTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "FACE_GAUSS_WEIGHTS(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%FACE_GAUSS_WEIGHTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%FACE_GAUSS_WEIGHTS,1), MIN(LBOUND(Variable% &
      & FACE_GAUSS_WEIGHTS,1)+MaxArrayLength, UBOUND(Variable%FACE_GAUSS_WEIGHTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%FACE_GAUSS_WEIGHTS,2), MIN(LBOUND(Variable% &
        & FACE_GAUSS_WEIGHTS,2)+MaxArrayLength, UBOUND(Variable%FACE_GAUSS_WEIGHTS,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%FACE_GAUSS_WEIGHTS(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "FACE_GAUSS_WEIGHTS(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_QUADRATURE_SCHEME_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_FIELD_INTERPOLATED_POINT_METRICS_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_FIELD_INTERPOLATED_POINT_METRICS_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE(Variable, CheckVariable0, CheckVariable1, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable1

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr1
  TYPE(EquationsSetDerivedType), POINTER :: NullPtr2
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: NullPtr4
  TYPE(FIELDS_TYPE), POINTER :: NullPtr5
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: NullPtr8
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: NullPtr10
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr11
  TYPE(FIELD_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr13
  TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: NullPtr14
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr15
  TYPE(REGION_TYPE), POINTER :: NullPtr16
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: NullPtr17


  TYPE(SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)

  
  ! Variable%EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, BOUNDARY_CONDITIONS_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_SET_MATERIALS_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_TYPE, EQUATIONS_INTERPOLATION_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE (Variable)
! Available CheckVariables are: SOLVER_EQUATIONS_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), 
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EquationsSetDerivedType
!   is not available in passing variables, use NullPtr of type EquationsSetDerivedType
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_ANALYTIC_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_MATERIALS_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type EQUATIONS_INTERPOLATION_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_INTERPOLATION_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_INDEPENDENT_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS"
      CALL Print_EQUATIONS_TYPE(Variable% &
        & EQUATIONS, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & CheckVariable1, NullPtr10, NullPtr11, CheckVariable0, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, &
        & NullPtr17, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "HAVE_DYNAMIC:                                    ", &
    & Variable%HAVE_DYNAMIC
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "HAVE_STATIC:                                     ", &
    & Variable%HAVE_STATIC
  
  ! Variable%SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAPS,1), MIN(LBOUND(Variable% &
      & SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAPS,1)+MaxArrayLength, UBOUND(Variable%SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE (Variable)
! Available CheckVariables are: SOLVER_EQUATIONS_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP_TYPE(Variable% &
          & SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%SOLVER_COL_TO_STATIC_EQUATIONS_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOLVER_COL_TO_STATIC_EQUATIONS_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOLVER_COL_TO_STATIC_EQUATIONS_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_COL_TO_STATIC_EQUATIONS_MAP_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_COL_TO_STATIC_EQUATIONS_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOLVER_COL_TO_STATIC_EQUATIONS_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%SOLVER_COL_TO_STATIC_EQUATIONS_MAPS,1), MIN(LBOUND(Variable% &
      & SOLVER_COL_TO_STATIC_EQUATIONS_MAPS,1)+MaxArrayLength, UBOUND(Variable%SOLVER_COL_TO_STATIC_EQUATIONS_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_COL_TO_STATIC_EQUATIONS_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE (Variable)
! Available CheckVariables are: SOLVER_EQUATIONS_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_COL_TO_STATIC_EQUATIONS_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_COL_TO_STATIC_EQUATIONS_MAP_TYPE(Variable% &
          & SOLVER_COL_TO_STATIC_EQUATIONS_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_COL_TO_STATIC_EQUATIONS_MAP_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_COL_TO_STATIC_EQUATIONS_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_PENALTY_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_PENALTY_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(INTERFACE_PENALTY_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable13

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr2
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr3
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr4
  TYPE(MESH_TYPE), POINTER :: NullPtr5
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr6
  TYPE(NODES_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr12
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr13
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr16
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr18
  TYPE(CELLML_TYPE), POINTER :: NullPtr19
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr20
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr21
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr22
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr23
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr24

  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(INTERFACE_PENALTY_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  
  ! Variable%INTERFACE_CONDITION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_CONDITION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITION " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_CONDITION_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, SOLVER_EQUATIONS_TYPE, INTERFACE_LAGRANGE_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, INTERFACE_PENALTY_TYPE, GENERATED_MESHES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_PENALTY_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), INTERFACE_CONDITION_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), FIELDS_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), INTERFACE_DEPENDENT_TYPE (CheckVariable5), REGION_TYPE (CheckVariable6), INTERFACE_PENALTY_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITION_TYPE (CheckVariable10), INTERFACE_LAGRANGE_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), INTERFACE_TYPE (CheckVariable13), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_LAGRANGE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type INTERFACE_DEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type INTERFACE_PENALTY_TYPE
!   is type of this print routine, use Variable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable6

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_CONDITION
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_CONDITION"
      CALL Print_INTERFACE_CONDITION_TYPE(Variable% &
        & INTERFACE_CONDITION, CheckVariable1, NullPtr0, NullPtr1, CheckVariable4, CheckVariable9, NullPtr2, &
        & CheckVariable13, NullPtr3, NullPtr4, CheckVariable12, NullPtr5, NullPtr6, CheckVariable2, CheckVariable3, &
        & CheckVariable8, CheckVariable11, NullPtr7, NullPtr8, NullPtr9, CheckVariable0, NullPtr10, CheckVariable10, &
        & NullPtr11, CheckVariable5, NullPtr12, NullPtr13, Variable2, NullPtr14, CheckVariable6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "PENALTY_FINISHED:                                ", &
    & Variable%PENALTY_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "PENALTY_FIELD_AUTO_CREATED:                      ", &
    & Variable%PENALTY_FIELD_AUTO_CREATED
  
  ! Variable%PENALTY_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PENALTY_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "PENALTY_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_PENALTY_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), INTERFACE_CONDITION_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), FIELDS_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), INTERFACE_DEPENDENT_TYPE (CheckVariable5), REGION_TYPE (CheckVariable6), INTERFACE_PENALTY_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITION_TYPE (CheckVariable10), INTERFACE_LAGRANGE_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), INTERFACE_TYPE (CheckVariable13), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable6

    ! if variable was already followed
    Ptr1 => Variable%PENALTY_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PENALTY_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & PENALTY_FIELD, NullPtr0, NullPtr1, CheckVariable4, NullPtr15, CheckVariable9, NullPtr16, NullPtr2, NullPtr17, &
        & CheckVariable13, NullPtr3, NullPtr18, NullPtr4, NullPtr19, CheckVariable12, NullPtr5, CheckVariable3, NullPtr14, &
        & NullPtr20, NullPtr7, NullPtr21, NullPtr8, NullPtr9, CheckVariable0, NullPtr22, CheckVariable10, NullPtr23, &
        & NullPtr24, CheckVariable6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "PENALTY_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_PENALTY_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16

  ! iterator variables

  ! null pointers
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr0
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr3
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr4
  TYPE(HISTORY_TYPE), POINTER :: NullPtr5
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr6

  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable8)) THEN
    Variable2 => CheckVariable8
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%QUASI_NEWTON_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%QUASI_NEWTON_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: " // &
      & "QUASI_NEWTON_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_QUASI_NEWTON_SOLVER_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (Variable)
! Available CheckVariables are: QUASI_NEWTON_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), CELLML_EQUATIONS_TYPE (CheckVariable2), DAE_SOLVER_TYPE (CheckVariable3), SOLVERS_TYPE (CheckVariable4), NEWTON_SOLVER_TYPE (CheckVariable5), SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable7), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable8), LINEAR_SOLVER_TYPE (CheckVariable9), SOLVER_EQUATIONS_TYPE (CheckVariable10), OPTIMISER_SOLVER_TYPE (CheckVariable11), CONTROL_LOOP_TYPE (CheckVariable12), DYNAMIC_SOLVER_TYPE (CheckVariable13), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable14), GeometricTransformationSolverType (CheckVariable15), EIGENPROBLEM_SOLVER_TYPE (CheckVariable16), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable15
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE

    ! if variable was already followed
    Ptr0 => Variable%QUASI_NEWTON_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"QUASI_NEWTON_SOLVER"
      CALL Print_QUASI_NEWTON_SOLVER_TYPE(Variable% &
        & QUASI_NEWTON_SOLVER, NullPtr0, CheckVariable0, CheckVariable1, CheckVariable5, NullPtr1, NullPtr2, &
        & CheckVariable11, NullPtr3, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable2, &
        & CheckVariable12, Variable2, CheckVariable10, NullPtr4, NullPtr5, CheckVariable3, CheckVariable4, CheckVariable6, &
        & CheckVariable7, CheckVariable9, NullPtr6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: " // &
      & "QUASI_NEWTON_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRICES_LIBRARY:         ", &
    & Variable%SOLVER_MATRICES_LIBRARY
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "TRUSTREGION_TOLERANCE:       ", &
    & Variable%TRUSTREGION_TOLERANCE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "TRUSTREGION_DELTA0:          ", &
    & Variable%TRUSTREGION_DELTA0

  
END SUBROUTINE Print_QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_DOFS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_DOFS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable4

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_LINES_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_TYPE), POINTER :: NullPtr3
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr4
  TYPE(FIELDS_TYPE), POINTER :: NullPtr5
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: NullPtr6
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_TYPE), POINTER :: NullPtr8
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: NullPtr9
  TYPE(MESH_TYPE), POINTER :: NullPtr10
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr11
  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: NullPtr12
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr13
  TYPE(DOMAIN_FACES_TYPE), POINTER :: NullPtr14
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr15
  TYPE(DecompositionDataPointsType), POINTER :: NullPtr16
  TYPE(DOMAIN_NODES_TYPE), POINTER :: NullPtr17
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: NullPtr18
  TYPE(REGION_TYPE), POINTER :: NullPtr19

  TYPE(DOMAIN_TYPE), POINTER :: Ptr0

  TYPE(DOMAIN_DOFS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)

  
  ! Variable%DOMAIN
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DOMAIN)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_TYPE has the following CheckVariable types: DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, DOMAIN_LINES_TYPE, FIELD_TYPE, DOMAIN_DOFS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_FACES_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_ELEMENTS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_FACES_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DOMAIN_NODES_TYPE, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DOMAIN_DOFS_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TOPOLOGY_TYPE (CheckVariable0), DECOMPOSITION_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DOMAIN_PTR_TYPE (CheckVariable3), DOMAIN_TYPE (CheckVariable4), 
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type DOMAIN_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_LINES_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type DOMAIN_DOFS_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_FACES_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_ELEMENTS_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type DOMAIN_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_ELEMENTS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DOMAIN_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_FACES_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DecompositionDataPointsType
!   is not available in passing variables, use NullPtr of type DecompositionDataPointsType
! - signature type DOMAIN_NODES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_NODES_TYPE
! - signature type DECOMPOSITION_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_LINES_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DOMAIN
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOMAIN"
      CALL Print_DOMAIN_TYPE(Variable% &
        & DOMAIN, CheckVariable2, NullPtr0, NullPtr1, NullPtr2, NullPtr3, Variable2, NullPtr4, CheckVariable4, NullPtr5, &
        & NullPtr6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, CheckVariable3, NullPtr14, &
        & NullPtr15, CheckVariable0, CheckVariable1, NullPtr16, NullPtr17, NullPtr18, NullPtr19, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DOFS:                  ", &
    & Variable%NUMBER_OF_DOFS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_DOFS:            ", &
    & Variable%TOTAL_NUMBER_OF_DOFS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_DOFS:           ", &
    & Variable%NUMBER_OF_GLOBAL_DOFS
  
  ! Variable%DOF_INDEX(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOF_INDEX)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOF_INDEX),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_INDEX(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOF_INDEX, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DOF_INDEX,1), MIN(LBOUND(Variable%DOF_INDEX,1)+MaxArrayLength, UBOUND(Variable%DOF_INDEX,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%DOF_INDEX,2), MIN(LBOUND(Variable%DOF_INDEX,2)+MaxArrayLength, UBOUND(Variable%DOF_INDEX,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%DOF_INDEX(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_INDEX(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DOMAIN_DOFS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_REAL_DP_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(REAL_DP_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(REAL_DP_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), POINTER :: " // &
      & "PTR(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%PTR,1), "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%PTR,1), MIN(LBOUND(Variable%PTR,1)+MaxArrayLength, UBOUND(Variable%PTR,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%PTR(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), POINTER :: " // &
      & "PTR(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_REAL_DP_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable21

  ! iterator variables

  ! null pointers
  TYPE(CELLML_MODEL_TYPE), POINTER :: NullPtr0

  TYPE(CELLML_TYPE), POINTER :: Ptr0

  TYPE(CELLML_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_CELLML_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, CELLML_MODEL_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_PTR_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), REGION_PTR_TYPE (CheckVariable2), CELLML_MODELS_FIELD_TYPE (CheckVariable3), INTERFACE_TYPE (CheckVariable4), DOMAIN_TYPE (CheckVariable5), CELLML_ENVIRONMENTS_TYPE (CheckVariable6), CELLML_STATE_FIELD_TYPE (CheckVariable7), CELLML_TYPE (CheckVariable8), MESH_TYPE (CheckVariable9), FIELDS_TYPE (CheckVariable10), CELLML_FIELD_MAPS_TYPE (CheckVariable11), GENERATED_MESHES_TYPE (CheckVariable12), NODES_TYPE (CheckVariable13), INTERFACES_TYPE (CheckVariable14), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable15), DATA_PROJECTION_TYPE (CheckVariable16), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable17), DECOMPOSITION_TYPE (CheckVariable18), DATA_POINTS_TYPE (CheckVariable19), FIELD_VARIABLE_TYPE (CheckVariable20), REGION_TYPE (CheckVariable21), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_MODEL_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_MODEL_TYPE
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable21

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_CELLML_TYPE(Variable% &
        & PTR, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable15, CheckVariable4, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & NullPtr0, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable19, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable20, CheckVariable21, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_CELLML_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MATRIX_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MATRIX_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(EQUATIONS_MATRIX_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRIX_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRIX_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MATRIX_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_EQUATIONS_MATRIX_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRIX_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_MATRIX_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE(Variable, CheckVariable0, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable0

  ! iterator variables

  ! null pointers


  TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_FIELD_INTERPOLATION_PARAMETERS_TYPE has the following CheckVariable types: FIELD_TYPE, 
! The type to handle in this routine is: FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE (Variable)
! Available CheckVariables are: FIELD_TYPE (CheckVariable0), 
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable0
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_FIELD_INTERPOLATION_PARAMETERS_TYPE(Variable%PTR, CheckVariable0, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_NODES_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, Depth, MaxDepth, MaxArrayLength)
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable26

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr2
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr4
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr6
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr7

  TYPE(REGION_TYPE), POINTER :: Ptr0
  TYPE(INTERFACE_TYPE), POINTER :: Ptr1

  TYPE(NODES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable19)) THEN
    Variable2 => CheckVariable19
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)

  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: NODES_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), GENERATED_MESH_PTR_TYPE (CheckVariable22), DATA_PROJECTION_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), REGION_TYPE (CheckVariable26), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type NODES_TYPE
!   is type of this print routine, use Variable2
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable26

    ! if variable was already followed
    Ptr0 => Variable%REGION
    IF (ASSOCIATED(Ptr0, CheckVariable26)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr0, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, NullPtr1, CheckVariable10, CheckVariable11, &
        & CheckVariable12, NullPtr2, CheckVariable13, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, &
        & Variable2, NullPtr3, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, NullPtr4, &
        & CheckVariable24, CheckVariable25, NullPtr5, CheckVariable26, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: NODES_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), GENERATED_MESH_PTR_TYPE (CheckVariable22), DATA_PROJECTION_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), REGION_TYPE (CheckVariable26), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type NODES_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable26

    ! if variable was already followed
    Ptr1 => Variable%INTERFACE
    IF (ASSOCIATED(Ptr1, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE"
      CALL Print_INTERFACE_TYPE(Variable% &
        & INTERFACE, NullPtr6, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, NullPtr2, CheckVariable14, CheckVariable15, NullPtr7, CheckVariable16, CheckVariable17, &
        & CheckVariable18, Variable2, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, NullPtr4, &
        & CheckVariable24, NullPtr5, CheckVariable26, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "NODES_FINISHED:                                  ", &
    & Variable%NODES_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_NODES:                 ", &
    & Variable%NUMBER_OF_NODES
  
  ! Variable%NODES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NODE_TYPE), ALLOCATABLE :: " // &
      & "NODES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%NODES,1), MIN(LBOUND(Variable%NODES,1)+MaxArrayLength, UBOUND(Variable%NODES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_NODE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: NODES_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), GENERATED_MESH_PTR_TYPE (CheckVariable22), DATA_PROJECTION_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), REGION_TYPE (CheckVariable26), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NODES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_NODE_TYPE(Variable%NODES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NODE_TYPE), ALLOCATABLE :: " // &
      & "NODES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COUPLED_NODES(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COUPLED_NODES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COUPLED_NODES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "COUPLED_NODES(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COUPLED_NODES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COUPLED_NODES,1), MIN(LBOUND(Variable%COUPLED_NODES,1)+MaxArrayLength, UBOUND(Variable%COUPLED_NODES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%COUPLED_NODES,2), MIN(LBOUND(Variable%COUPLED_NODES,2)+MaxArrayLength, UBOUND(Variable% &
        & COUPLED_NODES,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%COUPLED_NODES(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "COUPLED_NODES(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NODES_TREE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NODES_TREE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(TREE_TYPE), POINTER :: " // &
      & "NODES_TREE " // &
      & "(associated): " 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(TREE_TYPE) :: Variable%" // &
        & "NODES_TREE (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(TREE_TYPE), POINTER :: " // &
      & "NODES_TREE (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_NODES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_QUASI_NEWTON_LINESEARCH_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16

  ! iterator variables

  ! null pointers
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr0
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr3
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr4
  TYPE(HISTORY_TYPE), POINTER :: NullPtr5
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr6

  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%QUASI_NEWTON_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%QUASI_NEWTON_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: " // &
      & "QUASI_NEWTON_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_QUASI_NEWTON_SOLVER_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (Variable)
! Available CheckVariables are: QUASI_NEWTON_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), CELLML_EQUATIONS_TYPE (CheckVariable2), DAE_SOLVER_TYPE (CheckVariable3), SOLVERS_TYPE (CheckVariable4), NEWTON_SOLVER_TYPE (CheckVariable5), SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable7), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable8), LINEAR_SOLVER_TYPE (CheckVariable9), SOLVER_EQUATIONS_TYPE (CheckVariable10), OPTIMISER_SOLVER_TYPE (CheckVariable11), CONTROL_LOOP_TYPE (CheckVariable12), DYNAMIC_SOLVER_TYPE (CheckVariable13), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable14), GeometricTransformationSolverType (CheckVariable15), EIGENPROBLEM_SOLVER_TYPE (CheckVariable16), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable15
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE

    ! if variable was already followed
    Ptr0 => Variable%QUASI_NEWTON_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"QUASI_NEWTON_SOLVER"
      CALL Print_QUASI_NEWTON_SOLVER_TYPE(Variable% &
        & QUASI_NEWTON_SOLVER, NullPtr0, CheckVariable0, CheckVariable1, CheckVariable5, NullPtr1, NullPtr2, &
        & CheckVariable11, NullPtr3, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable2, &
        & CheckVariable12, CheckVariable8, CheckVariable10, NullPtr4, NullPtr5, CheckVariable3, CheckVariable4, &
        & CheckVariable6, Variable2, CheckVariable9, NullPtr6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: " // &
      & "QUASI_NEWTON_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRICES_LIBRARY:         ", &
    & Variable%SOLVER_MATRICES_LIBRARY
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LINESEARCH_TYPE:                 ", &
    & Variable%LINESEARCH_TYPE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "LINESEARCH_MAXSTEP:          ", &
    & Variable%LINESEARCH_MAXSTEP
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "LINESEARCH_STEPTOLERANCE:    ", &
    & Variable%LINESEARCH_STEPTOLERANCE
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "linesearchMonitorOutput:                         ", &
    & Variable%linesearchMonitorOutput

  
END SUBROUTINE Print_QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(DecompositionDataPointsType), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable18

  ! iterator variables

  ! null pointers
  TYPE(DOMAIN_LINES_TYPE), POINTER :: NullPtr0
  TYPE(DOMAIN_DOFS_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr2
  TYPE(CELLML_TYPE), POINTER :: NullPtr3
  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: NullPtr4
  TYPE(DOMAIN_FACES_TYPE), POINTER :: NullPtr5
  TYPE(DOMAIN_NODES_TYPE), POINTER :: NullPtr6

  TYPE(DOMAIN_TYPE), POINTER :: Ptr0

  TYPE(DOMAIN_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable17)) THEN
    Variable2 => CheckVariable17
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_TYPE has the following CheckVariable types: DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, DOMAIN_LINES_TYPE, FIELD_TYPE, DOMAIN_DOFS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_FACES_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_ELEMENTS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_FACES_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DOMAIN_NODES_TYPE, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DOMAIN_PTR_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), DATA_PROJECTION_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), DECOMPOSITION_PTR_TYPE (CheckVariable3), DOMAIN_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), DOMAIN_MAPPINGS_TYPE (CheckVariable7), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable8), DecompositionDataPointsType (CheckVariable9), FIELD_PTR_TYPE (CheckVariable10), DOMAIN_TOPOLOGY_TYPE (CheckVariable11), DECOMPOSITION_FACES_TYPE (CheckVariable12), DECOMPOSITION_LINES_TYPE (CheckVariable13), FIELD_TYPE (CheckVariable14), INTERFACE_TYPE (CheckVariable15), DECOMPOSITIONS_TYPE (CheckVariable16), DOMAIN_PTR_TYPE (CheckVariable17), REGION_TYPE (CheckVariable18), 
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_LINES_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DOMAIN_DOFS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_DOFS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DOMAIN_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DOMAIN_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_ELEMENTS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DOMAIN_PTR_TYPE
!   is type of this print routine, use Variable2
! - signature type DOMAIN_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_FACES_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DOMAIN_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable9
! - signature type DOMAIN_NODES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_NODES_TYPE
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable18

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_DOMAIN_TYPE(Variable% &
        & PTR, CheckVariable7, CheckVariable8, CheckVariable10, NullPtr0, CheckVariable14, NullPtr1, CheckVariable15, &
        & CheckVariable4, CheckVariable5, CheckVariable12, NullPtr2, NullPtr3, CheckVariable0, CheckVariable2, &
        & CheckVariable3, NullPtr4, CheckVariable16, Variable2, NullPtr5, CheckVariable1, CheckVariable11, CheckVariable6, &
        & CheckVariable9, NullPtr6, CheckVariable13, CheckVariable18, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DOMAIN_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_SET_SOURCE_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(EquationsSetDerivedType), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable15

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr3
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr9
  TYPE(SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr16
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr19
  TYPE(MESH_TYPE), POINTER :: NullPtr20
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr21
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr23
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr24

  TYPE(EQUATIONS_SET_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  
  ! Variable%EQUATIONS_SET
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SET)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_TYPE has the following CheckVariable types: EQUATIONS_TYPE, MESHES_TYPE, EquationsSetDerivedType, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_SOURCE_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable15

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_SET
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SET"
      CALL Print_EQUATIONS_SET_TYPE(Variable% &
        & EQUATIONS_SET, CheckVariable1, NullPtr0, CheckVariable3, CheckVariable12, NullPtr1, CheckVariable13, &
        & CheckVariable8, CheckVariable9, NullPtr2, NullPtr3, CheckVariable2, NullPtr4, CheckVariable5, NullPtr5, NullPtr6, &
        & NullPtr7, NullPtr8, CheckVariable0, CheckVariable4, NullPtr9, CheckVariable6, NullPtr10, Variable2, NullPtr11, &
        & NullPtr12, CheckVariable10, CheckVariable11, CheckVariable14, CheckVariable15, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "SOURCE_FINISHED:                                 ", &
    & Variable%SOURCE_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "SOURCE_FIELD_AUTO_CREATED:                       ", &
    & Variable%SOURCE_FIELD_AUTO_CREATED
  
  ! Variable%SOURCE_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOURCE_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "SOURCE_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_SOURCE_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr1 => Variable%SOURCE_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOURCE_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & SOURCE_FIELD, NullPtr0, NullPtr13, NullPtr14, NullPtr15, CheckVariable12, NullPtr1, NullPtr16, CheckVariable13, &
        & CheckVariable9, NullPtr17, NullPtr2, NullPtr3, NullPtr18, NullPtr19, NullPtr20, CheckVariable5, NullPtr5, &
        & NullPtr21, NullPtr6, NullPtr22, NullPtr7, NullPtr8, CheckVariable0, NullPtr23, CheckVariable6, CheckVariable10, &
        & NullPtr24, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "SOURCE_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_SET_SOURCE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EMBEDDING_GAUSSPOINT_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EMBEDDING_GAUSSPOINT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(EMBEDDING_GAUSSPOINT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ELEMENT_NUMBER:                  ", &
    & Variable%ELEMENT_NUMBER
  
  ! Variable%CHILD_XI_COORD(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%CHILD_XI_COORD)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%CHILD_XI_COORD),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "CHILD_XI_COORD(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%CHILD_XI_COORD, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%CHILD_XI_COORD,1), MIN(LBOUND(Variable%CHILD_XI_COORD,1)+MaxArrayLength, UBOUND(Variable% &
      & CHILD_XI_COORD,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%CHILD_XI_COORD(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "CHILD_XI_COORD(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%PARENT_XI_COORD(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%PARENT_XI_COORD)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%PARENT_XI_COORD),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "PARENT_XI_COORD(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%PARENT_XI_COORD, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%PARENT_XI_COORD,1), MIN(LBOUND(Variable%PARENT_XI_COORD,1)+MaxArrayLength, UBOUND(Variable% &
      & PARENT_XI_COORD,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%PARENT_XI_COORD(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "PARENT_XI_COORD(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EMBEDDING_GAUSSPOINT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_NODE_DERIVATIVE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_NODE_DERIVATIVE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(DOMAIN_NODE_DERIVATIVE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfVersions:                ", &
    & Variable%numberOfVersions
  
  ! Variable%userVersionNumbers(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%userVersionNumbers)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%userVersionNumbers),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "userVersionNumbers(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%userVersionNumbers, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%userVersionNumbers,1), MIN(LBOUND(Variable% &
      & userVersionNumbers,1)+MaxArrayLength, UBOUND(Variable%userVersionNumbers,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%userVersionNumbers(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "userVersionNumbers(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DOF_INDEX(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOF_INDEX)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOF_INDEX),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_INDEX(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOF_INDEX, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DOF_INDEX,1), MIN(LBOUND(Variable%DOF_INDEX,1)+MaxArrayLength, UBOUND(Variable%DOF_INDEX,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DOF_INDEX(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_INDEX(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_DERIVATIVE_INDEX:         ", &
    & Variable%GLOBAL_DERIVATIVE_INDEX
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "PARTIAL_DERIVATIVE_INDEX:        ", &
    & Variable%PARTIAL_DERIVATIVE_INDEX

  
END SUBROUTINE Print_DOMAIN_NODE_DERIVATIVE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_LINE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_LINE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1, I2
  CHARACTER(LEN=30) :: I0_STR, I1_STR, I2_STR

  ! null pointers
  TYPE(BASIS_TYPE), POINTER :: NullPtr0
  TYPE(BASIS_PTR_TYPE), POINTER :: NullPtr1


  TYPE(DOMAIN_LINE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER:                          ", &
    & Variable%NUMBER
  
  ! Variable%BASIS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%BASIS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_TYPE), POINTER :: " // &
      & "BASIS " // &
      & "(associated): " 
  
! Signature of Print_BASIS_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: DOMAIN_LINE_TYPE (Variable)
! Available CheckVariables are: 
! - signature type BASIS_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_TYPE
! - signature type BASIS_PTR_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_PTR_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BASIS"
      CALL Print_BASIS_TYPE(Variable%BASIS, NullPtr0, NullPtr1, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_TYPE), POINTER :: " // &
      & "BASIS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%NODES_IN_LINE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODES_IN_LINE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODES_IN_LINE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODES_IN_LINE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODES_IN_LINE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NODES_IN_LINE,1), MIN(LBOUND(Variable%NODES_IN_LINE,1)+MaxArrayLength, UBOUND(Variable%NODES_IN_LINE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NODES_IN_LINE(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODES_IN_LINE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DERIVATIVES_IN_LINE(:,:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DERIVATIVES_IN_LINE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DERIVATIVES_IN_LINE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DERIVATIVES_IN_LINE(:,:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DERIVATIVES_IN_LINE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DERIVATIVES_IN_LINE,1), MIN(LBOUND(Variable% &
      & DERIVATIVES_IN_LINE,1)+MaxArrayLength, UBOUND(Variable%DERIVATIVES_IN_LINE,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%DERIVATIVES_IN_LINE,2), MIN(LBOUND(Variable% &
        & DERIVATIVES_IN_LINE,2)+MaxArrayLength, UBOUND(Variable%DERIVATIVES_IN_LINE,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//","//TRIM(ADJUSTL(I1_STR))//",*): "
        DO I2 = LBOUND(Variable%DERIVATIVES_IN_LINE,3), MIN(LBOUND(Variable% &
          & DERIVATIVES_IN_LINE,3)+MaxArrayLength, UBOUND(Variable%DERIVATIVES_IN_LINE,3))
          WRITE(I2_STR,"(I4)") I2 

          PRINT*, TRIM(PrintIndent), Variable%DERIVATIVES_IN_LINE(I0,I1,I2)

        ENDDO  ! I2
      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DERIVATIVES_IN_LINE(:,:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "BOUNDARY_LINE:                                   ", &
    & Variable%BOUNDARY_LINE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ELEMENT_NUMBER:                  ", &
    & Variable%ELEMENT_NUMBER

  
END SUBROUTINE Print_DOMAIN_LINE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_MAPPING_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_MAPPING_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(DOMAIN_MAPPING_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LOCAL:                 ", &
    & Variable%NUMBER_OF_LOCAL
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_LOCAL:           ", &
    & Variable%TOTAL_NUMBER_OF_LOCAL
  
  ! Variable%NUMBER_OF_DOMAIN_LOCAL(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_DOMAIN_LOCAL)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_DOMAIN_LOCAL),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_DOMAIN_LOCAL(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_DOMAIN_LOCAL, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_DOMAIN_LOCAL,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_DOMAIN_LOCAL,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_DOMAIN_LOCAL,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_DOMAIN_LOCAL(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_DOMAIN_LOCAL(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NUMBER_OF_DOMAIN_GHOST(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_DOMAIN_GHOST)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_DOMAIN_GHOST),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_DOMAIN_GHOST(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_DOMAIN_GHOST, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_DOMAIN_GHOST,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_DOMAIN_GHOST,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_DOMAIN_GHOST,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_DOMAIN_GHOST(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_DOMAIN_GHOST(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL:                ", &
    & Variable%NUMBER_OF_GLOBAL
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DOMAINS:               ", &
    & Variable%NUMBER_OF_DOMAINS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_INTERNAL:              ", &
    & Variable%NUMBER_OF_INTERNAL
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_BOUNDARY:              ", &
    & Variable%NUMBER_OF_BOUNDARY
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GHOST:                 ", &
    & Variable%NUMBER_OF_GHOST
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INTERNAL_START:                  ", &
    & Variable%INTERNAL_START
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INTERNAL_FINISH:                 ", &
    & Variable%INTERNAL_FINISH
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "BOUNDARY_START:                  ", &
    & Variable%BOUNDARY_START
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "BOUNDARY_FINISH:                 ", &
    & Variable%BOUNDARY_FINISH
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GHOST_START:                     ", &
    & Variable%GHOST_START
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GHOST_FINISH:                    ", &
    & Variable%GHOST_FINISH
  
  ! Variable%DOMAIN_LIST(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOMAIN_LIST)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOMAIN_LIST),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOMAIN_LIST(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOMAIN_LIST, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DOMAIN_LIST,1), MIN(LBOUND(Variable%DOMAIN_LIST,1)+MaxArrayLength, UBOUND(Variable%DOMAIN_LIST,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DOMAIN_LIST(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOMAIN_LIST(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LOCAL_TO_GLOBAL_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LOCAL_TO_GLOBAL_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LOCAL_TO_GLOBAL_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_TO_GLOBAL_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LOCAL_TO_GLOBAL_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LOCAL_TO_GLOBAL_MAP,1), MIN(LBOUND(Variable% &
      & LOCAL_TO_GLOBAL_MAP,1)+MaxArrayLength, UBOUND(Variable%LOCAL_TO_GLOBAL_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LOCAL_TO_GLOBAL_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_TO_GLOBAL_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%GLOBAL_TO_LOCAL_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GLOBAL_TO_LOCAL_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GLOBAL_TO_LOCAL_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_GLOBAL_MAPPING_TYPE), ALLOCATABLE :: " // &
      & "GLOBAL_TO_LOCAL_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GLOBAL_TO_LOCAL_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%GLOBAL_TO_LOCAL_MAP,1), MIN(LBOUND(Variable% &
      & GLOBAL_TO_LOCAL_MAP,1)+MaxArrayLength, UBOUND(Variable%GLOBAL_TO_LOCAL_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DOMAIN_GLOBAL_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DOMAIN_MAPPING_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GLOBAL_TO_LOCAL_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DOMAIN_GLOBAL_MAPPING_TYPE(Variable%GLOBAL_TO_LOCAL_MAP(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_GLOBAL_MAPPING_TYPE), ALLOCATABLE :: " // &
      & "GLOBAL_TO_LOCAL_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ADJACENT_DOMAINS:      ", &
    & Variable%NUMBER_OF_ADJACENT_DOMAINS
  
  ! Variable%ADJACENT_DOMAINS_PTR(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ADJACENT_DOMAINS_PTR)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ADJACENT_DOMAINS_PTR),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ADJACENT_DOMAINS_PTR(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ADJACENT_DOMAINS_PTR, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ADJACENT_DOMAINS_PTR,1), MIN(LBOUND(Variable% &
      & ADJACENT_DOMAINS_PTR,1)+MaxArrayLength, UBOUND(Variable%ADJACENT_DOMAINS_PTR,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ADJACENT_DOMAINS_PTR(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ADJACENT_DOMAINS_PTR(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ADJACENT_DOMAINS_LIST(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ADJACENT_DOMAINS_LIST)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ADJACENT_DOMAINS_LIST),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ADJACENT_DOMAINS_LIST(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ADJACENT_DOMAINS_LIST, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ADJACENT_DOMAINS_LIST,1), MIN(LBOUND(Variable% &
      & ADJACENT_DOMAINS_LIST,1)+MaxArrayLength, UBOUND(Variable%ADJACENT_DOMAINS_LIST,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ADJACENT_DOMAINS_LIST(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ADJACENT_DOMAINS_LIST(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ADJACENT_DOMAINS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ADJACENT_DOMAINS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ADJACENT_DOMAINS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_ADJACENT_DOMAIN_TYPE), ALLOCATABLE :: " // &
      & "ADJACENT_DOMAINS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ADJACENT_DOMAINS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%ADJACENT_DOMAINS,1), MIN(LBOUND(Variable%ADJACENT_DOMAINS,1)+MaxArrayLength, UBOUND(Variable% &
      & ADJACENT_DOMAINS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DOMAIN_ADJACENT_DOMAIN_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DOMAIN_MAPPING_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ADJACENT_DOMAINS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DOMAIN_ADJACENT_DOMAIN_TYPE(Variable%ADJACENT_DOMAINS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_ADJACENT_DOMAIN_TYPE), ALLOCATABLE :: " // &
      & "ADJACENT_DOMAINS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DOMAIN_MAPPING_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(FIELD_TYPE), POINTER :: NullPtr0


  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)

  
  ! Variable%INTERPOLATION_PARAMETERS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%INTERPOLATION_PARAMETERS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "INTERPOLATION_PARAMETERS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%INTERPOLATION_PARAMETERS,1), "): "
  
    DO I0 = LBOUND(Variable%INTERPOLATION_PARAMETERS,1), MIN(LBOUND(Variable% &
      & INTERPOLATION_PARAMETERS,1)+MaxArrayLength, UBOUND(Variable%INTERPOLATION_PARAMETERS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE has the following CheckVariable types: FIELD_TYPE, 
! The type to handle in this routine is: INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE (Variable)
! Available CheckVariables are: 
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERPOLATION_PARAMETERS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE(Variable% &
          & INTERPOLATION_PARAMETERS(I0), NullPtr0, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "INTERPOLATION_PARAMETERS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERPOLATED_POINT(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%INTERPOLATED_POINT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "INTERPOLATED_POINT(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%INTERPOLATED_POINT,1), "): "
  
    DO I0 = LBOUND(Variable%INTERPOLATED_POINT,1), MIN(LBOUND(Variable% &
      & INTERPOLATED_POINT,1)+MaxArrayLength, UBOUND(Variable%INTERPOLATED_POINT,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATED_POINT_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERPOLATED_POINT("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATED_POINT_PTR_TYPE(Variable%INTERPOLATED_POINT(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "INTERPOLATED_POINT(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERPOLATED_POINT_METRICS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%INTERPOLATED_POINT_METRICS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: " // &
      & "INTERPOLATED_POINT_METRICS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%INTERPOLATED_POINT_METRICS,1), "): "
  
    DO I0 = LBOUND(Variable%INTERPOLATED_POINT_METRICS,1), MIN(LBOUND(Variable% &
      & INTERPOLATED_POINT_METRICS,1)+MaxArrayLength, UBOUND(Variable%INTERPOLATED_POINT_METRICS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERPOLATED_POINT_METRICS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE(Variable% &
          & INTERPOLATED_POINT_METRICS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: " // &
      & "INTERPOLATED_POINT_METRICS(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DYNAMIC_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
  & CheckVariable32, CheckVariable33, Depth, MaxDepth, MaxArrayLength)
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable31
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable32
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable33

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(FIELD_TYPE), POINTER :: NullPtr0
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr2
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr6

  TYPE(SOLVER_TYPE), POINTER :: Ptr0

  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable14)) THEN
    Variable2 => CheckVariable14
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: DYNAMIC_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), SOLVER_EQUATIONS_TYPE (CheckVariable22), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), HISTORY_TYPE (CheckVariable25), DAE_SOLVER_TYPE (CheckVariable26), SOLVERS_TYPE (CheckVariable27), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable28), SOLVER_TYPE (CheckVariable29), SOLVER_MAPPING_TYPE (CheckVariable30), EULER_DAE_SOLVER_TYPE (CheckVariable31), LINEAR_SOLVER_TYPE (CheckVariable32), PROBLEM_TYPE (CheckVariable33), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DYNAMIC_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable16
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable29
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable33

    ! if variable was already followed
    Ptr0 => Variable%SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable29)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & SOLVER, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, CheckVariable3, CheckVariable4, NullPtr1, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, Variable2, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, &
        & CheckVariable19, CheckVariable20, CheckVariable21, NullPtr2, CheckVariable22, NullPtr3, CheckVariable23, &
        & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, NullPtr4, &
        & NullPtr5, CheckVariable30, CheckVariable31, NullPtr6, CheckVariable32, CheckVariable33, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "SOLVER_INITIALISED:                              ", &
    & Variable%SOLVER_INITIALISED
  Comment = ""
  IF (Variable%LINEARITY == 1) THEN
    Comment = "SOLVER_DYNAMIC_LINEAR " // & 
      & "!Dynamic solver has linear terms"
  ENDIF
  IF (Variable%LINEARITY == 2) THEN
    Comment = "SOLVER_DYNAMIC_NONLINEAR " // & 
      & "!Dynamic solver has nonlinear terms"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LINEARITY:                       ", &
    & Variable%LINEARITY, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%ORDER == 1) THEN
    Comment = "SOLVER_DYNAMIC_FIRST_ORDER " // & 
      & "!Dynamic solver has first order terms"
  ENDIF
  IF (Variable%ORDER == 2) THEN
    Comment = "SOLVER_DYNAMIC_SECOND_ORDER " // & 
      & "!Dynamic solver has second order terms"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ORDER:                           ", &
    & Variable%ORDER, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%DEGREE == 1) THEN
    Comment = "SOLVER_DYNAMIC_FIRST_DEGREE " // & 
      & "!Dynamic solver uses a first degree polynomial for time interpolation"
  ENDIF
  IF (Variable%DEGREE == 2) THEN
    Comment = "SOLVER_DYNAMIC_SECOND_DEGREE " // & 
      & "!Dynamic solver uses a second degree polynomial for time interpolation"
  ENDIF
  IF (Variable%DEGREE == 3) THEN
    Comment = "SOLVER_DYNAMIC_THIRD_DEGREE " // & 
      & "!Dynamic solver uses a third degree polynomial for time interpolation"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DEGREE:                          ", &
    & Variable%DEGREE, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%SCHEME == 1) THEN
    Comment = "SOLVER_DYNAMIC_EULER_SCHEME " // & 
      & "!Euler (explicit) dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 2) THEN
    Comment = "SOLVER_DYNAMIC_BACKWARD_EULER_SCHEME " // & 
      & "!Backward Euler (implicit) dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 3) THEN
    Comment = "SOLVER_DYNAMIC_CRANK_NICOLSON_SCHEME " // & 
      & "!Crank-Nicolson dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 4) THEN
    Comment = "SOLVER_DYNAMIC_GALERKIN_SCHEME " // & 
      & "!Galerkin dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 5) THEN
    Comment = "SOLVER_DYNAMIC_ZLAMAL_SCHEME " // & 
      & "!Zlamal dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 6) THEN
    Comment = "SOLVER_DYNAMIC_SECOND_DEGREE_GEAR_SCHEME " // & 
      & "!2nd degree Gear dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 7) THEN
    Comment = "SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER1_SCHEME " // & 
      & "!1st 2nd degree Liniger dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 8) THEN
    Comment = "SOLVER_DYNAMIC_SECOND_DEGREE_LINIGER2_SCHEME " // & 
      & "!2nd 2nd degree Liniger dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 9) THEN
    Comment = "SOLVER_DYNAMIC_NEWMARK1_SCHEME " // & 
      & "!1st Newmark dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 10) THEN
    Comment = "SOLVER_DYNAMIC_NEWMARK2_SCHEME " // & 
      & "!2nd Newmark dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 11) THEN
    Comment = "SOLVER_DYNAMIC_NEWMARK3_SCHEME " // & 
      & "!3rd Newmark dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 12) THEN
    Comment = "SOLVER_DYNAMIC_THIRD_DEGREE_GEAR_SCHEME " // & 
      & "!3rd degree Gear dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 13) THEN
    Comment = "SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER1_SCHEME " // & 
      & "!1st 3rd degree Liniger dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 14) THEN
    Comment = "SOLVER_DYNAMIC_THIRD_DEGREE_LINIGER2_SCHEME " // & 
      & "!2nd 3rd degree Liniger dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 15) THEN
    Comment = "SOLVER_DYNAMIC_HOUBOLT_SCHEME " // & 
      & "!Houbolt dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 16) THEN
    Comment = "SOLVER_DYNAMIC_WILSON_SCHEME " // & 
      & "!Wilson dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 17) THEN
    Comment = "SOLVER_DYNAMIC_BOSSAK_NEWMARK1_SCHEME " // & 
      & "!1st Bossak-Newmark dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 18) THEN
    Comment = "SOLVER_DYNAMIC_BOSSAK_NEWMARK2_SCHEME " // & 
      & "!2nd Bossak-Newmark dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 19) THEN
    Comment = "SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR1_SCHEME " // & 
      & "!1st Hilbert-Hughes-Taylor dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 20) THEN
    Comment = "SOLVER_DYNAMIC_HILBERT_HUGHES_TAYLOR2_SCHEME " // & 
      & "!1st Hilbert-Hughes-Taylor dynamic solver"
  ENDIF
  IF (Variable%SCHEME == 21) THEN
    Comment = "SOLVER_DYNAMIC_USER_DEFINED_SCHEME " // & 
      & "!User specified degree and theta dynamic solver"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SCHEME:                          ", &
    & Variable%SCHEME, " ", TRIM(Comment)
  
  ! Variable%THETA(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%THETA)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%THETA),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "THETA(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%THETA, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%THETA,1), MIN(LBOUND(Variable%THETA,1)+MaxArrayLength, UBOUND(Variable%THETA,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%THETA(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "THETA(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "EXPLICIT:                                        ", &
    & Variable%EXPLICIT
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "RESTART:                                         ", &
    & Variable%RESTART
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "ALE:                                             ", &
    & Variable%ALE
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "FSI:                                             ", &
    & Variable%FSI
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "UPDATE_BC:                                       ", &
    & Variable%UPDATE_BC
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "CURRENT_TIME:                ", &
    & Variable%CURRENT_TIME
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "TIME_INCREMENT:              ", &
    & Variable%TIME_INCREMENT
  
  ! Variable%LINEAR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINEAR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "LINEAR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: DYNAMIC_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), SOLVER_EQUATIONS_TYPE (CheckVariable22), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), HISTORY_TYPE (CheckVariable25), DAE_SOLVER_TYPE (CheckVariable26), SOLVERS_TYPE (CheckVariable27), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable28), SOLVER_TYPE (CheckVariable29), SOLVER_MAPPING_TYPE (CheckVariable30), EULER_DAE_SOLVER_TYPE (CheckVariable31), LINEAR_SOLVER_TYPE (CheckVariable32), PROBLEM_TYPE (CheckVariable33), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DYNAMIC_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable16
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable29
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable33

    ! if variable was already followed
    Ptr0 => Variable%LINEAR_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable29)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINEAR_SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & LINEAR_SOLVER, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, CheckVariable3, CheckVariable4, &
        & NullPtr1, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
        & CheckVariable11, CheckVariable12, CheckVariable13, Variable2, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, NullPtr2, CheckVariable22, NullPtr3, &
        & CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, &
        & CheckVariable29, NullPtr4, NullPtr5, CheckVariable30, CheckVariable31, NullPtr6, CheckVariable32, &
        & CheckVariable33, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "LINEAR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%NONLINEAR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NONLINEAR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "NONLINEAR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: DYNAMIC_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), SOLVER_EQUATIONS_TYPE (CheckVariable22), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), HISTORY_TYPE (CheckVariable25), DAE_SOLVER_TYPE (CheckVariable26), SOLVERS_TYPE (CheckVariable27), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable28), SOLVER_TYPE (CheckVariable29), SOLVER_MAPPING_TYPE (CheckVariable30), EULER_DAE_SOLVER_TYPE (CheckVariable31), LINEAR_SOLVER_TYPE (CheckVariable32), PROBLEM_TYPE (CheckVariable33), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DYNAMIC_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable16
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable29
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable33

    ! if variable was already followed
    Ptr0 => Variable%NONLINEAR_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable29)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NONLINEAR_SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & NONLINEAR_SOLVER, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, CheckVariable3, CheckVariable4, &
        & NullPtr1, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
        & CheckVariable11, CheckVariable12, CheckVariable13, Variable2, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, NullPtr2, CheckVariable22, NullPtr3, &
        & CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, &
        & CheckVariable29, NullPtr4, NullPtr5, CheckVariable30, CheckVariable31, NullPtr6, CheckVariable32, &
        & CheckVariable33, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "NONLINEAR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DYNAMIC_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CONTROL_LOOP_WHILE_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, Depth, MaxDepth, MaxArrayLength)
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable11

  ! iterator variables

  ! null pointers
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr3
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr9

  TYPE(CONTROL_LOOP_TYPE), POINTER :: Ptr0

  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable8)) THEN
    Variable2 => CheckVariable8
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  
  ! Variable%CONTROL_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CONTROL_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, PROBLEMS_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_WHILE_TYPE (Variable)
! Available CheckVariables are: HISTORY_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), PROBLEM_PTR_TYPE (CheckVariable7), CONTROL_LOOP_WHILE_TYPE (CheckVariable8), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable9), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable10), PROBLEM_TYPE (CheckVariable11), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is type of this print routine, use Variable2
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr0 => Variable%CONTROL_LOOP
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CONTROL_LOOP"
      CALL Print_CONTROL_LOOP_TYPE(Variable% &
        & CONTROL_LOOP, Variable2, CheckVariable1, CheckVariable5, CheckVariable6, NullPtr0, CheckVariable4, NullPtr1, &
        & NullPtr2, NullPtr3, NullPtr4, NullPtr5, CheckVariable9, NullPtr6, NullPtr7, CheckVariable10, CheckVariable0, &
        & NullPtr8, CheckVariable2, CheckVariable3, CheckVariable7, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ITERATION_NUMBER:                ", &
    & Variable%ITERATION_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_ITERATIONS:    ", &
    & Variable%MAXIMUM_NUMBER_OF_ITERATIONS
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "ABSOLUTE_TOLERANCE:          ", &
    & Variable%ABSOLUTE_TOLERANCE
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "CONTINUE_LOOP:                                   ", &
    & Variable%CONTINUE_LOOP

  
END SUBROUTINE Print_CONTROL_LOOP_WHILE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_SCALINGS_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_SCALINGS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(FIELD_SCALINGS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SCALING_TYPE:                    ", &
    & Variable%SCALING_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SCALING_INDICES:       ", &
    & Variable%NUMBER_OF_SCALING_INDICES
  
  ! Variable%SCALINGS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SCALINGS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SCALINGS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_SCALING_TYPE), ALLOCATABLE :: " // &
      & "SCALINGS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SCALINGS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%SCALINGS,1), MIN(LBOUND(Variable%SCALINGS,1)+MaxArrayLength, UBOUND(Variable%SCALINGS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_SCALING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_SCALINGS_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SCALINGS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_SCALING_TYPE(Variable%SCALINGS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_SCALING_TYPE), ALLOCATABLE :: " // &
      & "SCALINGS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_SCALINGS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CRANK_NICOLSON_DAE_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, Depth, MaxDepth, MaxArrayLength)
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable19

  ! iterator variables

  ! null pointers
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr0
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr6
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr8
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr10
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(HISTORY_TYPE), POINTER :: NullPtr13
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr14
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr15
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr16

  TYPE(DAE_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable9)) THEN
    Variable2 => CheckVariable9
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)

  
  ! Variable%DAE_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DAE_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_DAE_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CRANK_NICOLSON_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), CELLML_EQUATIONS_TYPE (CheckVariable2), SOLVERS_TYPE (CheckVariable3), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable4), SOLVER_TYPE (CheckVariable5), GeometricTransformationSolverType (CheckVariable6), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable7), EULER_DAE_SOLVER_TYPE (CheckVariable8), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable9), LINEAR_SOLVER_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), BDF_DAE_SOLVER_TYPE (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable18), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable19), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BACKWARD_EULER_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type FORWARD_EULER_DAE_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable6
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type IMPROVED_EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DAE_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DAE_SOLVER"
      CALL Print_DAE_SOLVER_TYPE(Variable% &
        & DAE_SOLVER, CheckVariable16, NullPtr0, CheckVariable18, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, NullPtr4, &
        & NullPtr5, NullPtr6, CheckVariable7, CheckVariable19, CheckVariable12, NullPtr7, NullPtr8, CheckVariable14, &
        & CheckVariable15, NullPtr9, CheckVariable6, CheckVariable17, NullPtr10, CheckVariable2, CheckVariable13, &
        & Variable2, CheckVariable11, NullPtr11, NullPtr12, NullPtr13, CheckVariable0, CheckVariable3, CheckVariable4, &
        & CheckVariable5, NullPtr14, CheckVariable8, CheckVariable10, NullPtr15, NullPtr16, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)

  
END SUBROUTINE Print_CRANK_NICOLSON_DAE_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_QUADRATURE_SCHEME_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, Depth, MaxDepth, MaxArrayLength)
  TYPE(QUADRATURE_SCHEME_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BASIS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(QUADRATURE_SCHEME_TYPE), POINTER, INTENT(IN) :: CheckVariable1

  ! iterator variables

  ! null pointers

  TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: Ptr0

  TYPE(QUADRATURE_SCHEME_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_QUADRATURE_SCHEME_TYPE has the following CheckVariable types: BASIS_TYPE, QUADRATURE_SCHEME_PTR_TYPE, 
! The type to handle in this routine is: QUADRATURE_SCHEME_PTR_TYPE (Variable)
! Available CheckVariables are: BASIS_TYPE (CheckVariable0), QUADRATURE_SCHEME_TYPE (CheckVariable1), 
! - signature type BASIS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type QUADRATURE_SCHEME_PTR_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_QUADRATURE_SCHEME_TYPE(Variable%PTR, CheckVariable0, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_QUADRATURE_SCHEME_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EquationsSetDerivedType), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable19

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr3
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr4
  TYPE(NODES_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr6
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr7
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr8
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr9
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr11
  TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER :: NullPtr12
  TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER :: NullPtr13
  TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER :: NullPtr14
  TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER :: NullPtr15
  TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER :: NullPtr16
  TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: NullPtr17
  TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: NullPtr18
  TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: NullPtr19
  TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER :: NullPtr20
  TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: NullPtr21

  TYPE(EQUATIONS_SET_TYPE), POINTER :: Ptr0
  TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: Ptr1
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: Ptr2
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: Ptr3

  TYPE(EQUATIONS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable0)) THEN
    Variable2 => CheckVariable0
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)

  
  ! Variable%EQUATIONS_SET
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SET)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_TYPE has the following CheckVariable types: EQUATIONS_TYPE, MESHES_TYPE, EquationsSetDerivedType, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), BOUNDARY_CONDITIONS_TYPE (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), EQUATIONS_MATRICES_TYPE (CheckVariable6), SOLVER_TYPE (CheckVariable7), EQUATIONS_SET_SOURCE_TYPE (CheckVariable8), EQUATIONS_MAPPING_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable11), EQUATIONS_SET_PTR_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), FIELD_TYPE (CheckVariable14), INTERFACE_TYPE (CheckVariable15), EQUATIONS_INTERPOLATION_TYPE (CheckVariable16), EQUATIONS_SETS_TYPE (CheckVariable17), REGION_TYPE (CheckVariable18), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable19), 
! - signature type EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable19

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_SET
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SET"
      CALL Print_EQUATIONS_SET_TYPE(Variable% &
        & EQUATIONS_SET, Variable2, NullPtr0, CheckVariable2, CheckVariable14, NullPtr1, CheckVariable17, CheckVariable11, &
        & CheckVariable15, NullPtr2, NullPtr3, CheckVariable1, CheckVariable3, CheckVariable5, NullPtr4, NullPtr5, &
        & NullPtr6, NullPtr7, NullPtr8, CheckVariable4, NullPtr9, NullPtr10, CheckVariable7, CheckVariable8, &
        & CheckVariable10, NullPtr11, CheckVariable12, CheckVariable13, CheckVariable18, CheckVariable19, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "EQUATIONS_FINISHED:                              ", &
    & Variable%EQUATIONS_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LINEARITY:                       ", &
    & Variable%LINEARITY
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TIME_DEPENDENCE:                 ", &
    & Variable%TIME_DEPENDENCE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "OUTPUT_TYPE:                     ", &
    & Variable%OUTPUT_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SPARSITY_TYPE:                   ", &
    & Variable%SPARSITY_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LUMPING_TYPE:                    ", &
    & Variable%LUMPING_TYPE
  
  ! Variable%INTERPOLATION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERPOLATION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: " // &
      & "INTERPOLATION " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_INTERPOLATION_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, FIELDS_TYPE, SOLVER_MAPPING_TYPE, FIELD_TYPE, INTERFACE_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), BOUNDARY_CONDITIONS_TYPE (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), EQUATIONS_MATRICES_TYPE (CheckVariable6), SOLVER_TYPE (CheckVariable7), EQUATIONS_SET_SOURCE_TYPE (CheckVariable8), EQUATIONS_MAPPING_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable11), EQUATIONS_SET_PTR_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), FIELD_TYPE (CheckVariable14), INTERFACE_TYPE (CheckVariable15), EQUATIONS_INTERPOLATION_TYPE (CheckVariable16), EQUATIONS_SETS_TYPE (CheckVariable17), REGION_TYPE (CheckVariable18), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable19), 
! - signature type EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable18

    ! if variable was already followed
    Ptr1 => Variable%INTERPOLATION
    IF (ASSOCIATED(Ptr1, CheckVariable16)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERPOLATION"
      CALL Print_EQUATIONS_INTERPOLATION_TYPE(Variable% &
        & INTERPOLATION, Variable2, CheckVariable1, CheckVariable5, CheckVariable10, CheckVariable14, CheckVariable15, &
        & CheckVariable17, CheckVariable18, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: " // &
      & "INTERPOLATION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%EQUATIONS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MAPPING_LINEAR_TYPE, EQUATIONS_MAPPING_DYNAMIC_TYPE, EQUATIONS_MAPPING_RHS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, REGION_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_MAPPING_SOURCE_TYPE, EQUATIONS_MAPPING_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), BOUNDARY_CONDITIONS_TYPE (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), EQUATIONS_MATRICES_TYPE (CheckVariable6), SOLVER_TYPE (CheckVariable7), EQUATIONS_SET_SOURCE_TYPE (CheckVariable8), EQUATIONS_MAPPING_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable11), EQUATIONS_SET_PTR_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), FIELD_TYPE (CheckVariable14), INTERFACE_TYPE (CheckVariable15), EQUATIONS_INTERPOLATION_TYPE (CheckVariable16), EQUATIONS_SETS_TYPE (CheckVariable17), REGION_TYPE (CheckVariable18), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable19), 
! - signature type EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EQUATIONS_MAPPING_LINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_LINEAR_TYPE
! - signature type EQUATIONS_MAPPING_DYNAMIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_DYNAMIC_TYPE
! - signature type EQUATIONS_MAPPING_RHS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_RHS_TYPE
! - signature type EQUATIONS_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type EQUATIONS_MAPPING_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_NONLINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_NONLINEAR_TYPE

    ! if variable was already followed
    Ptr2 => Variable%EQUATIONS_MAPPING
    IF (ASSOCIATED(Ptr2, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MAPPING"
      CALL Print_EQUATIONS_MAPPING_TYPE(Variable% &
        & EQUATIONS_MAPPING, Variable2, CheckVariable1, NullPtr12, NullPtr13, NullPtr14, CheckVariable6, CheckVariable10, &
        & CheckVariable18, CheckVariable13, CheckVariable14, CheckVariable17, NullPtr15, NullPtr16, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%EQUATIONS_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MATRICES_DYNAMIC_TYPE, SOLVER_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_MATRICES_RHS_TYPE, EQUATIONS_MATRICES_LINEAR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_MATRICES_SOURCE_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_MATRICES_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), BOUNDARY_CONDITIONS_TYPE (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), EQUATIONS_MATRICES_TYPE (CheckVariable6), SOLVER_TYPE (CheckVariable7), EQUATIONS_SET_SOURCE_TYPE (CheckVariable8), EQUATIONS_MAPPING_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable11), EQUATIONS_SET_PTR_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), FIELD_TYPE (CheckVariable14), INTERFACE_TYPE (CheckVariable15), EQUATIONS_INTERPOLATION_TYPE (CheckVariable16), EQUATIONS_SETS_TYPE (CheckVariable17), REGION_TYPE (CheckVariable18), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable19), 
! - signature type EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EQUATIONS_MATRICES_DYNAMIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_DYNAMIC_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type EQUATIONS_MATRICES_RHS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_RHS_TYPE
! - signature type EQUATIONS_MATRICES_LINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_LINEAR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type EQUATIONS_MATRICES_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_SOURCE_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type EQUATIONS_MATRICES_NONLINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_NONLINEAR_TYPE

    ! if variable was already followed
    Ptr3 => Variable%EQUATIONS_MATRICES
    IF (ASSOCIATED(Ptr3, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MATRICES"
      CALL Print_EQUATIONS_MATRICES_TYPE(Variable% &
        & EQUATIONS_MATRICES, Variable2, CheckVariable1, NullPtr17, CheckVariable7, CheckVariable9, CheckVariable10, &
        & NullPtr18, NullPtr19, CheckVariable13, CheckVariable14, NullPtr20, CheckVariable17, CheckVariable18, NullPtr21, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_PARAMETER_SET_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_PARAMETER_SET_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(FIELD_PARAMETER_SET_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_FIELD_PARAMETER_SET_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_PARAMETER_SET_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_FIELD_PARAMETER_SET_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELD_PARAMETER_SET_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_INTERPOLATION_PARAMETERS_TYPE(Variable, CheckVariable0, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable0

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr3
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr4
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr5
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr8
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr9
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr10
  TYPE(CELLML_TYPE), POINTER :: NullPtr11
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr12
  TYPE(MESH_TYPE), POINTER :: NullPtr13
  TYPE(FIELDS_TYPE), POINTER :: NullPtr14
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr15
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr16
  TYPE(NODES_TYPE), POINTER :: NullPtr17
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr19
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr20
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr21
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr22
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr23
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr24
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr25
  TYPE(REGION_TYPE), POINTER :: NullPtr26
  TYPE(BASIS_TYPE), POINTER :: NullPtr27
  TYPE(BASIS_PTR_TYPE), POINTER :: NullPtr28

  TYPE(FIELD_TYPE), POINTER :: Ptr0

  TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)

  
  ! Variable%FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_INTERPOLATION_PARAMETERS_TYPE (Variable)
! Available CheckVariables are: FIELD_TYPE (CheckVariable0), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr0 => Variable%FIELD
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & FIELD, NullPtr0, NullPtr1, NullPtr2, NullPtr3, CheckVariable0, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, &
        & NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, NullPtr18, &
        & NullPtr19, NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%FIELD_VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELD_VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "FIELD_VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: FIELD_INTERPOLATION_PARAMETERS_TYPE (Variable)
! Available CheckVariables are: FIELD_TYPE (CheckVariable0), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELD_VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & FIELD_VARIABLE, NullPtr21, NullPtr22, NullPtr0, NullPtr14, NullPtr23, NullPtr4, NullPtr3, NullPtr15, NullPtr11, &
        & NullPtr25, CheckVariable0, NullPtr19, NullPtr7, NullPtr9, NullPtr17, NullPtr6, NullPtr26, NullPtr20, Depth+1, &
        & MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "FIELD_VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_XI:                    ", &
    & Variable%NUMBER_OF_XI
  
  ! Variable%BASES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%BASES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%BASES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_PTR_TYPE), ALLOCATABLE :: " // &
      & "BASES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%BASES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%BASES,1), MIN(LBOUND(Variable%BASES,1)+MaxArrayLength, UBOUND(Variable%BASES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_BASIS_PTR_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: FIELD_INTERPOLATION_PARAMETERS_TYPE (Variable)
! Available CheckVariables are: FIELD_TYPE (CheckVariable0), 
! - signature type BASIS_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_TYPE
! - signature type BASIS_PTR_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_PTR_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BASES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_BASIS_PTR_TYPE(Variable%BASES(I0), NullPtr27, NullPtr28, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_PTR_TYPE), ALLOCATABLE :: " // &
      & "BASES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NUMBER_OF_PARAMETERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_PARAMETERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_PARAMETERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_PARAMETERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_PARAMETERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_PARAMETERS,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_PARAMETERS,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_PARAMETERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_PARAMETERS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_PARAMETERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%PARAMETERS(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%PARAMETERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%PARAMETERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "PARAMETERS(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%PARAMETERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%PARAMETERS,1), MIN(LBOUND(Variable%PARAMETERS,1)+MaxArrayLength, UBOUND(Variable%PARAMETERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%PARAMETERS,2), MIN(LBOUND(Variable%PARAMETERS,2)+MaxArrayLength, UBOUND(Variable%PARAMETERS,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%PARAMETERS(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "PARAMETERS(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%SCALE_FACTORS(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SCALE_FACTORS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SCALE_FACTORS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "SCALE_FACTORS(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SCALE_FACTORS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SCALE_FACTORS,1), MIN(LBOUND(Variable%SCALE_FACTORS,1)+MaxArrayLength, UBOUND(Variable%SCALE_FACTORS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%SCALE_FACTORS,2), MIN(LBOUND(Variable%SCALE_FACTORS,2)+MaxArrayLength, UBOUND(Variable% &
        & SCALE_FACTORS,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%SCALE_FACTORS(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "SCALE_FACTORS(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_INTERPOLATION_PARAMETERS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DECOMPOSITION_ELEMENT_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DECOMPOSITION_ELEMENT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(DECOMPOSITION_ELEMENT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LOCAL_NUMBER:                    ", &
    & Variable%LOCAL_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  
  ! Variable%ADJACENT_ELEMENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ADJACENT_ELEMENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ADJACENT_ELEMENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_ADJACENT_ELEMENT_TYPE), ALLOCATABLE :: " // &
      & "ADJACENT_ELEMENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ADJACENT_ELEMENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%ADJACENT_ELEMENTS,1), MIN(LBOUND(Variable%ADJACENT_ELEMENTS,1)+MaxArrayLength, UBOUND(Variable% &
      & ADJACENT_ELEMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DECOMPOSITION_ADJACENT_ELEMENT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DECOMPOSITION_ELEMENT_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ADJACENT_ELEMENTS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DECOMPOSITION_ADJACENT_ELEMENT_TYPE(Variable%ADJACENT_ELEMENTS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_ADJACENT_ELEMENT_TYPE), ALLOCATABLE :: " // &
      & "ADJACENT_ELEMENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ELEMENT_LINES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_LINES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_LINES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_LINES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_LINES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENT_LINES,1), MIN(LBOUND(Variable%ELEMENT_LINES,1)+MaxArrayLength, UBOUND(Variable%ELEMENT_LINES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ELEMENT_LINES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_LINES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ELEMENT_FACES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_FACES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_FACES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_FACES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_FACES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENT_FACES,1), MIN(LBOUND(Variable%ELEMENT_FACES,1)+MaxArrayLength, UBOUND(Variable%ELEMENT_FACES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ELEMENT_FACES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_FACES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "BOUNDARY_ELEMENT:                                ", &
    & Variable%BOUNDARY_ELEMENT

  
END SUBROUTINE Print_DECOMPOSITION_ELEMENT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_ELEMENT_CONNECTIVITY_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_ELEMENT_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1, I2
  CHARACTER(LEN=30) :: I0_STR, I1_STR, I2_STR

  ! null pointers


  TYPE(INTERFACE_ELEMENT_CONNECTIVITY_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "COUPLED_MESH_ELEMENT_NUMBER:     ", &
    & Variable%COUPLED_MESH_ELEMENT_NUMBER
  
  ! Variable%XI(:,:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%XI)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%XI),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "XI(:,:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%XI, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%XI,1), MIN(LBOUND(Variable%XI,1)+MaxArrayLength, UBOUND(Variable%XI,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%XI,2), MIN(LBOUND(Variable%XI,2)+MaxArrayLength, UBOUND(Variable%XI,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//","//TRIM(ADJUSTL(I1_STR))//",*): "
        DO I2 = LBOUND(Variable%XI,3), MIN(LBOUND(Variable%XI,3)+MaxArrayLength, UBOUND(Variable%XI,3))
          WRITE(I2_STR,"(I4)") I2 

          PRINT*, TRIM(PrintIndent), Variable%XI(I0,I1,I2)

        ENDDO  ! I2
      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "XI(:,:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "CONNECTED_FACE:                  ", &
    & Variable%CONNECTED_FACE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "CONNECTED_LINE:                  ", &
    & Variable%CONNECTED_LINE

  
END SUBROUTINE Print_INTERFACE_ELEMENT_CONNECTIVITY_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MeshElementDataPointType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(MeshElementDataPointType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(MeshElementDataPointType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "userNumber:                      ", &
    & Variable%userNumber
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "globalNumber:                    ", &
    & Variable%globalNumber

  
END SUBROUTINE Print_MeshElementDataPointType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_COL_TO_INTERFACE_MAP_TYPE(Variable, CheckVariable0, CheckVariable1, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(SOLVER_COL_TO_INTERFACE_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable1

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr1
  TYPE(EquationsSetDerivedType), POINTER :: NullPtr2
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: NullPtr4
  TYPE(FIELDS_TYPE), POINTER :: NullPtr5
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: NullPtr8
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: NullPtr10
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr11
  TYPE(FIELD_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr13
  TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: NullPtr14
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr15
  TYPE(REGION_TYPE), POINTER :: NullPtr16
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: NullPtr17


  TYPE(SOLVER_COL_TO_INTERFACE_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)

  
  ! Variable%INTERFACE_EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, BOUNDARY_CONDITIONS_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_SET_MATERIALS_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_TYPE, EQUATIONS_INTERPOLATION_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: SOLVER_COL_TO_INTERFACE_MAP_TYPE (Variable)
! Available CheckVariables are: SOLVER_EQUATIONS_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), 
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EquationsSetDerivedType
!   is not available in passing variables, use NullPtr of type EquationsSetDerivedType
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_ANALYTIC_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_MATERIALS_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type EQUATIONS_INTERPOLATION_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_INTERPOLATION_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_INDEPENDENT_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_EQUATIONS"
      CALL Print_EQUATIONS_TYPE(Variable% &
        & INTERFACE_EQUATIONS, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, &
        & NullPtr9, CheckVariable1, NullPtr10, NullPtr11, CheckVariable0, NullPtr12, NullPtr13, NullPtr14, NullPtr15, &
        & NullPtr16, NullPtr17, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOLVER_COL_TO_INTERFACE_EQUATIONS_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOLVER_COL_TO_INTERFACE_EQUATIONS_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOLVER_COL_TO_INTERFACE_EQUATIONS_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_COL_TO_INTERFACE_EQUATIONS_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOLVER_COL_TO_INTERFACE_EQUATIONS_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%SOLVER_COL_TO_INTERFACE_EQUATIONS_MAPS,1), MIN(LBOUND(Variable% &
      & SOLVER_COL_TO_INTERFACE_EQUATIONS_MAPS,1)+MaxArrayLength, UBOUND(Variable%SOLVER_COL_TO_INTERFACE_EQUATIONS_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: SOLVER_COL_TO_INTERFACE_MAP_TYPE (Variable)
! Available CheckVariables are: SOLVER_EQUATIONS_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_COL_TO_INTERFACE_EQUATIONS_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP_TYPE(Variable% &
          & SOLVER_COL_TO_INTERFACE_EQUATIONS_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_COL_TO_INTERFACE_EQUATIONS_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_SOLVER_COL_TO_INTERFACE_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_HISTORY_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, Depth, MaxDepth, MaxArrayLength)
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable11

  ! iterator variables

  ! null pointers
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr3
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(MESHES_TYPE), POINTER :: NullPtr10
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr11
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr12
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr13
  TYPE(FIELD_TYPE), POINTER :: NullPtr14
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr15
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr16
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr17
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr19
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr20
  TYPE(CELLML_TYPE), POINTER :: NullPtr21
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr22
  TYPE(MESH_TYPE), POINTER :: NullPtr23
  TYPE(FIELDS_TYPE), POINTER :: NullPtr24
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr25
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr26
  TYPE(NODES_TYPE), POINTER :: NullPtr27
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr28
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr29
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr30
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr31
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr32
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr33
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr34
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr35
  TYPE(REGION_TYPE), POINTER :: NullPtr36

  TYPE(CONTROL_LOOP_TYPE), POINTER :: Ptr0

  TYPE(HISTORY_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable0)) THEN
    Variable2 => CheckVariable0
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)
  Nullify(NullPtr29)
  Nullify(NullPtr30)
  Nullify(NullPtr31)
  Nullify(NullPtr32)
  Nullify(NullPtr33)
  Nullify(NullPtr34)
  Nullify(NullPtr35)
  Nullify(NullPtr36)

  
  ! Variable%CONTROL_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CONTROL_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, PROBLEMS_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: HISTORY_TYPE (Variable)
! Available CheckVariables are: HISTORY_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), PROBLEM_PTR_TYPE (CheckVariable7), CONTROL_LOOP_WHILE_TYPE (CheckVariable8), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable9), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable10), PROBLEM_TYPE (CheckVariable11), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type HISTORY_TYPE
!   is type of this print routine, use Variable2
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr0 => Variable%CONTROL_LOOP
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CONTROL_LOOP"
      CALL Print_CONTROL_LOOP_TYPE(Variable% &
        & CONTROL_LOOP, CheckVariable8, CheckVariable1, CheckVariable5, CheckVariable6, NullPtr0, CheckVariable4, NullPtr1, &
        & NullPtr2, NullPtr3, NullPtr4, NullPtr5, CheckVariable9, NullPtr6, NullPtr7, CheckVariable10, Variable2, NullPtr8, &
        & CheckVariable2, CheckVariable3, CheckVariable7, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "HISTORY_FINISHED:                                ", &
    & Variable%HISTORY_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "FILE_FORMAT:                     ", &
    & Variable%FILE_FORMAT
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "UNIT_NUMBER:                     ", &
    & Variable%UNIT_NUMBER
  
  ! Variable%FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: HISTORY_TYPE (Variable)
! Available CheckVariables are: HISTORY_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), PROBLEM_PTR_TYPE (CheckVariable7), CONTROL_LOOP_WHILE_TYPE (CheckVariable8), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable9), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable10), PROBLEM_TYPE (CheckVariable11), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & FIELD, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, NullPtr18, &
        & NullPtr19, NullPtr20, CheckVariable4, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, &
        & NullPtr27, NullPtr28, NullPtr29, NullPtr30, NullPtr31, NullPtr32, NullPtr33, NullPtr34, NullPtr35, NullPtr36, &
        & Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIELD (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_HISTORY_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BDF_DAE_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, Depth, MaxDepth, MaxArrayLength)
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable19

  ! iterator variables

  ! null pointers
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr0
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr6
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr8
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr10
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(HISTORY_TYPE), POINTER :: NullPtr13
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr14
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr15
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr16

  TYPE(DAE_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable16)) THEN
    Variable2 => CheckVariable16
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)

  
  ! Variable%DAE_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DAE_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_DAE_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: BDF_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), CELLML_EQUATIONS_TYPE (CheckVariable2), SOLVERS_TYPE (CheckVariable3), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable4), SOLVER_TYPE (CheckVariable5), GeometricTransformationSolverType (CheckVariable6), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable7), EULER_DAE_SOLVER_TYPE (CheckVariable8), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable9), LINEAR_SOLVER_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), BDF_DAE_SOLVER_TYPE (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable18), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable19), 
! - signature type BDF_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BACKWARD_EULER_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type FORWARD_EULER_DAE_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable6
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type IMPROVED_EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DAE_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DAE_SOLVER"
      CALL Print_DAE_SOLVER_TYPE(Variable% &
        & DAE_SOLVER, Variable2, NullPtr0, CheckVariable18, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, NullPtr4, &
        & NullPtr5, NullPtr6, CheckVariable7, CheckVariable19, CheckVariable12, NullPtr7, NullPtr8, CheckVariable14, &
        & CheckVariable15, NullPtr9, CheckVariable6, CheckVariable17, NullPtr10, CheckVariable2, CheckVariable13, &
        & CheckVariable9, CheckVariable11, NullPtr11, NullPtr12, NullPtr13, CheckVariable0, CheckVariable3, CheckVariable4, &
        & CheckVariable5, NullPtr14, CheckVariable8, CheckVariable10, NullPtr15, NullPtr16, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)

  
END SUBROUTINE Print_BDF_DAE_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BOUNDARY_CONDITIONS_DIRICHLET_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(BOUNDARY_CONDITIONS_DIRICHLET_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers


  TYPE(BOUNDARY_CONDITIONS_DIRICHLET_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%DIRICHLET_DOF_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DIRICHLET_DOF_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DIRICHLET_DOF_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DIRICHLET_DOF_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DIRICHLET_DOF_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DIRICHLET_DOF_INDICES,1), MIN(LBOUND(Variable% &
      & DIRICHLET_DOF_INDICES,1)+MaxArrayLength, UBOUND(Variable%DIRICHLET_DOF_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DIRICHLET_DOF_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DIRICHLET_DOF_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LINEAR_SPARSITY_INDICES(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LINEAR_SPARSITY_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LINEAR_SPARSITY_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE), ALLOCATABLE :: " // &
      & "LINEAR_SPARSITY_INDICES(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LINEAR_SPARSITY_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%LINEAR_SPARSITY_INDICES,1), MIN(LBOUND(Variable% &
      & LINEAR_SPARSITY_INDICES,1)+MaxArrayLength, UBOUND(Variable%LINEAR_SPARSITY_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%LINEAR_SPARSITY_INDICES,2), MIN(LBOUND(Variable% &
        & LINEAR_SPARSITY_INDICES,2)+MaxArrayLength, UBOUND(Variable%LINEAR_SPARSITY_INDICES,2))
        WRITE(I1_STR,"(I4)") I1 

! Signature of Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: BOUNDARY_CONDITIONS_DIRICHLET_TYPE (Variable)
! Available CheckVariables are: 
          PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINEAR_SPARSITY_INDICES("//TRIM(ADJUSTL(I0_STR))//"," // &
            & ""//TRIM(ADJUSTL(I1_STR))//")"
          CALL Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE(Variable% &
            & LINEAR_SPARSITY_INDICES(I0,I1), Depth+1, MaxDepth, MaxArrayLength)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE), ALLOCATABLE :: " // &
      & "LINEAR_SPARSITY_INDICES(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DYNAMIC_SPARSITY_INDICES(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DYNAMIC_SPARSITY_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DYNAMIC_SPARSITY_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE), ALLOCATABLE :: " // &
      & "DYNAMIC_SPARSITY_INDICES(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DYNAMIC_SPARSITY_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%DYNAMIC_SPARSITY_INDICES,1), MIN(LBOUND(Variable% &
      & DYNAMIC_SPARSITY_INDICES,1)+MaxArrayLength, UBOUND(Variable%DYNAMIC_SPARSITY_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%DYNAMIC_SPARSITY_INDICES,2), MIN(LBOUND(Variable% &
        & DYNAMIC_SPARSITY_INDICES,2)+MaxArrayLength, UBOUND(Variable%DYNAMIC_SPARSITY_INDICES,2))
        WRITE(I1_STR,"(I4)") I1 

! Signature of Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: BOUNDARY_CONDITIONS_DIRICHLET_TYPE (Variable)
! Available CheckVariables are: 
          PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DYNAMIC_SPARSITY_INDICES("//TRIM(ADJUSTL(I0_STR))//"," // &
            & ""//TRIM(ADJUSTL(I1_STR))//")"
          CALL Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE(Variable% &
            & DYNAMIC_SPARSITY_INDICES(I0,I1), Depth+1, MaxDepth, MaxArrayLength)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE), ALLOCATABLE :: " // &
      & "DYNAMIC_SPARSITY_INDICES(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_BOUNDARY_CONDITIONS_DIRICHLET_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PRESSURE_INCREMENTED_DOF_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%PRESSURE_INCREMENTED_DOF_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%PRESSURE_INCREMENTED_DOF_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "PRESSURE_INCREMENTED_DOF_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%PRESSURE_INCREMENTED_DOF_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%PRESSURE_INCREMENTED_DOF_INDICES,1), MIN(LBOUND(Variable% &
      & PRESSURE_INCREMENTED_DOF_INDICES,1)+MaxArrayLength, UBOUND(Variable%PRESSURE_INCREMENTED_DOF_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%PRESSURE_INCREMENTED_DOF_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "PRESSURE_INCREMENTED_DOF_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SOLVER_COLS:           ", &
    & Variable%NUMBER_OF_SOLVER_COLS
  
  ! Variable%SOLVER_COLS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOLVER_COLS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOLVER_COLS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "SOLVER_COLS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOLVER_COLS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SOLVER_COLS,1), MIN(LBOUND(Variable%SOLVER_COLS,1)+MaxArrayLength, UBOUND(Variable%SOLVER_COLS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SOLVER_COLS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "SOLVER_COLS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COUPLING_COEFFICIENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COUPLING_COEFFICIENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COUPLING_COEFFICIENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COUPLING_COEFFICIENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COUPLING_COEFFICIENTS,1), MIN(LBOUND(Variable% &
      & COUPLING_COEFFICIENTS,1)+MaxArrayLength, UBOUND(Variable%COUPLING_COEFFICIENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COUPLING_COEFFICIENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_ELEMENT_MATRIX_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(ELEMENT_MATRIX_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers


  TYPE(ELEMENT_MATRIX_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "EQUATIONS_MATRIX_NUMBER:         ", &
    & Variable%EQUATIONS_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "STRUCTURE_TYPE:                  ", &
    & Variable%STRUCTURE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ROWS:                  ", &
    & Variable%NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COLUMNS:               ", &
    & Variable%NUMBER_OF_COLUMNS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAX_NUMBER_OF_ROWS:              ", &
    & Variable%MAX_NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAX_NUMBER_OF_COLUMNS:           ", &
    & Variable%MAX_NUMBER_OF_COLUMNS
  
  ! Variable%ROW_DOFS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ROW_DOFS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ROW_DOFS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ROW_DOFS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ROW_DOFS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ROW_DOFS,1), MIN(LBOUND(Variable%ROW_DOFS,1)+MaxArrayLength, UBOUND(Variable%ROW_DOFS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ROW_DOFS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ROW_DOFS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COLUMN_DOFS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COLUMN_DOFS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COLUMN_DOFS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLUMN_DOFS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COLUMN_DOFS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COLUMN_DOFS,1), MIN(LBOUND(Variable%COLUMN_DOFS,1)+MaxArrayLength, UBOUND(Variable%COLUMN_DOFS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COLUMN_DOFS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLUMN_DOFS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%MATRIX(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MATRIX)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MATRIX),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "MATRIX(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MATRIX, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%MATRIX,1), MIN(LBOUND(Variable%MATRIX,1)+MaxArrayLength, UBOUND(Variable%MATRIX,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%MATRIX,2), MIN(LBOUND(Variable%MATRIX,2)+MaxArrayLength, UBOUND(Variable%MATRIX,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%MATRIX(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "MATRIX(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_ELEMENT_MATRIX_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CONTROL_LOOP_SIMPLE_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, Depth, MaxDepth, MaxArrayLength)
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable11

  ! iterator variables

  ! null pointers
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr3
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr9

  TYPE(CONTROL_LOOP_TYPE), POINTER :: Ptr0

  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable9)) THEN
    Variable2 => CheckVariable9
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  
  ! Variable%CONTROL_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CONTROL_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, PROBLEMS_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_SIMPLE_TYPE (Variable)
! Available CheckVariables are: HISTORY_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), PROBLEM_PTR_TYPE (CheckVariable7), CONTROL_LOOP_WHILE_TYPE (CheckVariable8), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable9), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable10), PROBLEM_TYPE (CheckVariable11), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr0 => Variable%CONTROL_LOOP
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CONTROL_LOOP"
      CALL Print_CONTROL_LOOP_TYPE(Variable% &
        & CONTROL_LOOP, CheckVariable8, CheckVariable1, CheckVariable5, CheckVariable6, NullPtr0, CheckVariable4, NullPtr1, &
        & NullPtr2, NullPtr3, NullPtr4, NullPtr5, Variable2, NullPtr6, NullPtr7, CheckVariable10, CheckVariable0, NullPtr8, &
        & CheckVariable2, CheckVariable3, CheckVariable7, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_CONTROL_LOOP_SIMPLE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_MODEL_MAPS_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_MODEL_MAPS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(CELLML_MODEL_MAPS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_FIELDS_MAPPED_TO:      ", &
    & Variable%NUMBER_OF_FIELDS_MAPPED_TO
  
  ! Variable%FIELDS_MAPPED_TO(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%FIELDS_MAPPED_TO)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%FIELDS_MAPPED_TO),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_MODEL_MAP_PTR_TYPE), ALLOCATABLE :: " // &
      & "FIELDS_MAPPED_TO(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%FIELDS_MAPPED_TO, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%FIELDS_MAPPED_TO,1), MIN(LBOUND(Variable%FIELDS_MAPPED_TO,1)+MaxArrayLength, UBOUND(Variable% &
      & FIELDS_MAPPED_TO,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_CELLML_MODEL_MAP_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: CELLML_MODEL_MAPS_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELDS_MAPPED_TO("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_CELLML_MODEL_MAP_PTR_TYPE(Variable%FIELDS_MAPPED_TO(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_MODEL_MAP_PTR_TYPE), ALLOCATABLE :: " // &
      & "FIELDS_MAPPED_TO(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_FIELDS_MAPPED_FROM:    ", &
    & Variable%NUMBER_OF_FIELDS_MAPPED_FROM
  
  ! Variable%FIELDS_MAPPED_FROM(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%FIELDS_MAPPED_FROM)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%FIELDS_MAPPED_FROM),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_MODEL_MAP_PTR_TYPE), ALLOCATABLE :: " // &
      & "FIELDS_MAPPED_FROM(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%FIELDS_MAPPED_FROM, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%FIELDS_MAPPED_FROM,1), MIN(LBOUND(Variable% &
      & FIELDS_MAPPED_FROM,1)+MaxArrayLength, UBOUND(Variable%FIELDS_MAPPED_FROM,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_CELLML_MODEL_MAP_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: CELLML_MODEL_MAPS_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELDS_MAPPED_FROM("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_CELLML_MODEL_MAP_PTR_TYPE(Variable%FIELDS_MAPPED_FROM(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_MODEL_MAP_PTR_TYPE), ALLOCATABLE :: " // &
      & "FIELDS_MAPPED_FROM(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_CELLML_MODEL_MAPS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DecompositionDataPointsType(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, Depth, MaxDepth, MaxArrayLength)
  TYPE(DecompositionDataPointsType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DecompositionDataPointsType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable11

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr3
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr4
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr5
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr7
  TYPE(FIELDS_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: NullPtr11
  TYPE(REGION_TYPE), POINTER :: NullPtr12

  TYPE(DECOMPOSITION_TYPE), POINTER :: Ptr0

  TYPE(DecompositionDataPointsType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable6)) THEN
    Variable2 => CheckVariable6
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)

  
  ! Variable%DECOMPOSITION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DECOMPOSITION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "DECOMPOSITION " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DecompositionDataPointsType (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DecompositionDataPointsType (CheckVariable6), DECOMPOSITION_FACES_TYPE (CheckVariable7), DECOMPOSITION_LINES_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITIONS_TYPE (CheckVariable10), DOMAIN_PTR_TYPE (CheckVariable11), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type DOMAIN_MAPPINGS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_MAPPINGS_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TOPOLOGY_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type DecompositionDataPointsType
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DECOMPOSITION
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DECOMPOSITION"
      CALL Print_DECOMPOSITION_TYPE(Variable% &
        & DECOMPOSITION, NullPtr0, NullPtr1, NullPtr2, CheckVariable5, NullPtr3, NullPtr4, CheckVariable9, NullPtr5, &
        & NullPtr6, CheckVariable3, NullPtr7, CheckVariable7, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr8, &
        & CheckVariable10, CheckVariable11, NullPtr9, NullPtr10, NullPtr11, CheckVariable4, Variable2, CheckVariable8, &
        & NullPtr12, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "DECOMPOSITION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfDataPoints:              ", &
    & Variable%numberOfDataPoints
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "totalNumberOfDataPoints:         ", &
    & Variable%totalNumberOfDataPoints
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfGlobalDataPoints:        ", &
    & Variable%numberOfGlobalDataPoints
  
  ! Variable%numberOfDomainLocal(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%numberOfDomainLocal)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%numberOfDomainLocal),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "numberOfDomainLocal(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%numberOfDomainLocal, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%numberOfDomainLocal,1), MIN(LBOUND(Variable% &
      & numberOfDomainLocal,1)+MaxArrayLength, UBOUND(Variable%numberOfDomainLocal,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%numberOfDomainLocal(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "numberOfDomainLocal(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%numberOfDomainGhost(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%numberOfDomainGhost)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%numberOfDomainGhost),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "numberOfDomainGhost(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%numberOfDomainGhost, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%numberOfDomainGhost,1), MIN(LBOUND(Variable% &
      & numberOfDomainGhost,1)+MaxArrayLength, UBOUND(Variable%numberOfDomainGhost,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%numberOfDomainGhost(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "numberOfDomainGhost(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%numberOfElementDataPoints(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%numberOfElementDataPoints)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%numberOfElementDataPoints),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "numberOfElementDataPoints(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%numberOfElementDataPoints, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%numberOfElementDataPoints,1), MIN(LBOUND(Variable% &
      & numberOfElementDataPoints,1)+MaxArrayLength, UBOUND(Variable%numberOfElementDataPoints,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%numberOfElementDataPoints(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "numberOfElementDataPoints(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%elementDataPoint(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%elementDataPoint)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%elementDataPoint),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DecompositionElementDataPointsType), ALLOCATABLE :: " // &
      & "elementDataPoint(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%elementDataPoint, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%elementDataPoint,1), MIN(LBOUND(Variable%elementDataPoint,1)+MaxArrayLength, UBOUND(Variable% &
      & elementDataPoint,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DecompositionElementDataPointsType has the following CheckVariable types: 
! The type to handle in this routine is: DecompositionDataPointsType (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DecompositionDataPointsType (CheckVariable6), DECOMPOSITION_FACES_TYPE (CheckVariable7), DECOMPOSITION_LINES_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITIONS_TYPE (CheckVariable10), DOMAIN_PTR_TYPE (CheckVariable11), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"elementDataPoint("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DecompositionElementDataPointsType(Variable%elementDataPoint(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DecompositionElementDataPointsType), ALLOCATABLE :: " // &
      & "elementDataPoint(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%dataPointsTree
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%dataPointsTree)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(TREE_TYPE), POINTER :: " // &
      & "dataPointsTree " // &
      & "(associated): " 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(TREE_TYPE) :: Variable%" // &
        & "dataPointsTree (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(TREE_TYPE), POINTER :: " // &
      & "dataPointsTree (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DecompositionDataPointsType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_MODEL_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_MODEL_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_MODEL_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9

  ! iterator variables

  ! null pointers

  TYPE(CELLML_MODEL_TYPE), POINTER :: Ptr0

  TYPE(CELLML_MODEL_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_MODEL_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_CELLML_MODEL_TYPE has the following CheckVariable types: CELLML_PARAMETERS_FIELD_TYPE, CELLML_FIELD_MAPS_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, FIELD_TYPE, CELLML_TYPE, CELLML_MODELS_FIELD_TYPE, REGION_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, 
! The type to handle in this routine is: CELLML_MODEL_PTR_TYPE (Variable)
! Available CheckVariables are: CELLML_PARAMETERS_FIELD_TYPE (CheckVariable0), CELLML_FIELD_MAPS_TYPE (CheckVariable1), CELLML_MODEL_TYPE (CheckVariable2), CELLML_ENVIRONMENTS_TYPE (CheckVariable3), CELLML_STATE_FIELD_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), CELLML_TYPE (CheckVariable6), CELLML_MODELS_FIELD_TYPE (CheckVariable7), REGION_TYPE (CheckVariable8), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable9), 
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable9

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_CELLML_MODEL_TYPE(Variable% &
        & PTR, CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_MODEL_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_CELLML_MODEL_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DISTRIBUTED_VECTOR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER, INTENT(IN) :: CheckVariable2

  ! iterator variables

  ! null pointers

  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: Ptr0
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: Ptr1

  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable0)) THEN
    Variable2 => CheckVariable0
  ELSE
    Variable2 => Variable
  END IF 


  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "VECTOR_FINISHED:                                 ", &
    & Variable%VECTOR_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LIBRARY_TYPE:                    ", &
    & Variable%LIBRARY_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GHOSTING_TYPE:                   ", &
    & Variable%GHOSTING_TYPE
  
  ! Variable%DOMAIN_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DOMAIN_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "DOMAIN_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DISTRIBUTED_VECTOR_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_VECTOR_TYPE (CheckVariable0), DISTRIBUTED_VECTOR_PETSC_TYPE (CheckVariable1), DISTRIBUTED_VECTOR_CMISS_TYPE (CheckVariable2), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOMAIN_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%DOMAIN_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "DOMAIN_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DATA_TYPE:                       ", &
    & Variable%DATA_TYPE
  
  ! Variable%CMISS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CMISS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: " // &
      & "CMISS " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_CMISS_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_CMISS_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_TYPE, 
! The type to handle in this routine is: DISTRIBUTED_VECTOR_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_VECTOR_TYPE (CheckVariable0), DISTRIBUTED_VECTOR_PETSC_TYPE (CheckVariable1), DISTRIBUTED_VECTOR_CMISS_TYPE (CheckVariable2), 
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr0 => Variable%CMISS
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CMISS"
      CALL Print_DISTRIBUTED_VECTOR_CMISS_TYPE(Variable% &
        & CMISS, CheckVariable2, CheckVariable1, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: " // &
      & "CMISS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%PETSC
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PETSC)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: " // &
      & "PETSC " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_PETSC_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_CMISS_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_TYPE, 
! The type to handle in this routine is: DISTRIBUTED_VECTOR_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_VECTOR_TYPE (CheckVariable0), DISTRIBUTED_VECTOR_PETSC_TYPE (CheckVariable1), DISTRIBUTED_VECTOR_CMISS_TYPE (CheckVariable2), 
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr1 => Variable%PETSC
    IF (ASSOCIATED(Ptr1, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PETSC"
      CALL Print_DISTRIBUTED_VECTOR_PETSC_TYPE(Variable% &
        & PETSC, CheckVariable2, CheckVariable1, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: " // &
      & "PETSC (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DISTRIBUTED_VECTOR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DECOMPOSITION_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DecompositionDataPointsType), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable24

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MeshComponentTopologyType), POINTER :: NullPtr0
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr2
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr3
  TYPE(NODES_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: NullPtr5
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr7
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr8
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr9
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr10
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr11
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: NullPtr12

  TYPE(DECOMPOSITIONS_TYPE), POINTER :: Ptr0
  TYPE(MESH_TYPE), POINTER :: Ptr1
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: Ptr2
  TYPE(DOMAIN_PTR_TYPE), POINTER :: Ptr3

  TYPE(DECOMPOSITION_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable21)) THEN
    Variable2 => CheckVariable21
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "DECOMPOSITION_FINISHED:                          ", &
    & Variable%DECOMPOSITION_FINISHED
  
  ! Variable%DECOMPOSITIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DECOMPOSITIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITIONS_TYPE), POINTER :: " // &
      & "DECOMPOSITIONS " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITIONS_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), DOMAIN_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), DECOMPOSITION_FACES_TYPE (CheckVariable11), DECOMPOSITION_ELEMENTS_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), DECOMPOSITIONS_TYPE (CheckVariable16), DOMAIN_PTR_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), DOMAIN_TOPOLOGY_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), DecompositionDataPointsType (CheckVariable22), DECOMPOSITION_LINES_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable16
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITION_TYPE
!   is type of this print routine, use Variable2
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable22
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable24

    ! if variable was already followed
    Ptr0 => Variable%DECOMPOSITIONS
    IF (ASSOCIATED(Ptr0, CheckVariable16)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DECOMPOSITIONS"
      CALL Print_DECOMPOSITIONS_TYPE(Variable% &
        & DECOMPOSITIONS, NullPtr0, CheckVariable0, CheckVariable1, NullPtr1, CheckVariable3, CheckVariable4, &
        & CheckVariable5, CheckVariable6, NullPtr2, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
        & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, NullPtr3, CheckVariable16, &
        & NullPtr4, CheckVariable17, CheckVariable18, CheckVariable19, Variable2, CheckVariable22, CheckVariable23, &
        & CheckVariable24, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITIONS_TYPE), POINTER :: " // &
      & "DECOMPOSITIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_TYPE), POINTER :: " // &
      & "MESH " // &
      & "(associated): " 
  
! Signature of Print_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, REGION_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), DOMAIN_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), DECOMPOSITION_FACES_TYPE (CheckVariable11), DECOMPOSITION_ELEMENTS_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), DECOMPOSITIONS_TYPE (CheckVariable16), DOMAIN_PTR_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), DOMAIN_TOPOLOGY_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), DecompositionDataPointsType (CheckVariable22), DECOMPOSITION_LINES_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_CYLINDER_TYPE
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_ELLIPSOID_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable13
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_REGULAR_TYPE
! - signature type DECOMPOSITION_TYPE
!   is type of this print routine, use Variable2
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable24

    ! if variable was already followed
    Ptr1 => Variable%MESH
    IF (ASSOCIATED(Ptr1, CheckVariable13)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MESH"
      CALL Print_MESH_TYPE(Variable% &
        & MESH, NullPtr0, CheckVariable0, NullPtr5, CheckVariable1, NullPtr1, NullPtr6, CheckVariable3, CheckVariable4, &
        & CheckVariable5, CheckVariable6, NullPtr2, CheckVariable7, CheckVariable8, CheckVariable9, NullPtr7, NullPtr8, &
        & CheckVariable10, NullPtr9, CheckVariable13, CheckVariable14, CheckVariable15, NullPtr3, CheckVariable16, &
        & NullPtr4, CheckVariable17, NullPtr10, CheckVariable18, NullPtr11, CheckVariable19, NullPtr12, Variable2, &
        & CheckVariable24, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_TYPE), POINTER :: " // &
      & "MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MESH_COMPONENT_NUMBER:           ", &
    & Variable%MESH_COMPONENT_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DECOMPOSITION_TYPE:              ", &
    & Variable%DECOMPOSITION_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DOMAINS:               ", &
    & Variable%NUMBER_OF_DOMAINS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_EDGES_CUT:             ", &
    & Variable%NUMBER_OF_EDGES_CUT
  
  ! Variable%ELEMENT_DOMAIN(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_DOMAIN)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_DOMAIN),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_DOMAIN(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_DOMAIN, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENT_DOMAIN,1), MIN(LBOUND(Variable%ELEMENT_DOMAIN,1)+MaxArrayLength, UBOUND(Variable% &
      & ELEMENT_DOMAIN,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ELEMENT_DOMAIN(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_DOMAIN(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%TOPOLOGY
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%TOPOLOGY)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: " // &
      & "TOPOLOGY " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITION_TOPOLOGY_TYPE has the following CheckVariable types: DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, DecompositionDataPointsType, INTERFACE_TYPE, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_LINES_TYPE, FIELD_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), DOMAIN_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), DECOMPOSITION_FACES_TYPE (CheckVariable11), DECOMPOSITION_ELEMENTS_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), DECOMPOSITIONS_TYPE (CheckVariable16), DOMAIN_PTR_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), DOMAIN_TOPOLOGY_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), DecompositionDataPointsType (CheckVariable22), DECOMPOSITION_LINES_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DECOMPOSITION_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable3
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable22
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable24

    ! if variable was already followed
    Ptr2 => Variable%TOPOLOGY
    IF (ASSOCIATED(Ptr2, CheckVariable3)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TOPOLOGY"
      CALL Print_DECOMPOSITION_TOPOLOGY_TYPE(Variable% &
        & TOPOLOGY, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable9, CheckVariable15, Variable2, &
        & CheckVariable3, CheckVariable22, CheckVariable8, CheckVariable11, CheckVariable23, CheckVariable6, &
        & CheckVariable16, CheckVariable17, CheckVariable24, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: " // &
      & "TOPOLOGY (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DOMAIN(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%DOMAIN)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_PTR_TYPE), POINTER :: " // &
      & "DOMAIN(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%DOMAIN,1), "): "
  
    DO I0 = LBOUND(Variable%DOMAIN,1), MIN(LBOUND(Variable%DOMAIN,1)+MaxArrayLength, UBOUND(Variable%DOMAIN,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DOMAIN_PTR_TYPE has the following CheckVariable types: DECOMPOSITION_ELEMENTS_TYPE, DATA_PROJECTION_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, DecompositionDataPointsType, FIELD_PTR_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_LINES_TYPE, FIELD_TYPE, INTERFACE_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), DOMAIN_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), DECOMPOSITION_FACES_TYPE (CheckVariable11), DECOMPOSITION_ELEMENTS_TYPE (CheckVariable12), MESH_TYPE (CheckVariable13), DECOMPOSITION_PTR_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), DECOMPOSITIONS_TYPE (CheckVariable16), DOMAIN_PTR_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), DOMAIN_TOPOLOGY_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), DecompositionDataPointsType (CheckVariable22), DECOMPOSITION_LINES_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DECOMPOSITION_TYPE
!   is type of this print routine, use Variable2
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable22
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DOMAIN_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable17
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable24

      ! if variable was already followed
      Ptr3 => Variable%DOMAIN(I0)
      IF (ASSOCIATED(Ptr3, CheckVariable17)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOMAIN("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DOMAIN_PTR_TYPE(Variable% &
          & DOMAIN(I0), CheckVariable12, CheckVariable19, CheckVariable13, CheckVariable14, CheckVariable9, &
          & CheckVariable15, Variable2, CheckVariable2, CheckVariable3, CheckVariable22, CheckVariable4, CheckVariable20, &
          & CheckVariable11, CheckVariable23, CheckVariable6, CheckVariable8, CheckVariable16, CheckVariable17, &
          & CheckVariable24, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_PTR_TYPE), POINTER :: " // &
      & "DOMAIN(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "CALCULATE_FACES:                                 ", &
    & Variable%CALCULATE_FACES
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "CALCULATE_LINES:                                 ", &
    & Variable%CALCULATE_LINES

  
END SUBROUTINE Print_DECOMPOSITION_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_REGIONS_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(REGIONS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_TYPE), POINTER :: NullPtr6
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr7
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr8
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr9
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr11
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr13
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr14
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr15
  TYPE(CELLML_TYPE), POINTER :: NullPtr16
  TYPE(MESH_TYPE), POINTER :: NullPtr17
  TYPE(FIELDS_TYPE), POINTER :: NullPtr18
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr19
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr20
  TYPE(NODES_TYPE), POINTER :: NullPtr21
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr22
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr23
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr24
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr25
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr26
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr27
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr28
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr29
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr30
  TYPE(REGION_TYPE), POINTER :: NullPtr31


  TYPE(REGIONS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)
  Nullify(NullPtr29)
  Nullify(NullPtr30)
  Nullify(NullPtr31)

  
  ! Variable%WORLD_REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%WORLD_REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "WORLD_REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: REGIONS_TYPE (Variable)
! Available CheckVariables are: 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"WORLD_REGION"
      CALL Print_REGION_TYPE(Variable% &
        & WORLD_REGION, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, NullPtr18, NullPtr19, &
        & NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, NullPtr29, &
        & NullPtr30, NullPtr31, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "WORLD_REGION (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_REGIONS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MAPPING_NONLINEAR_TYPE(Variable, CheckVariable0, CheckVariable1, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable1

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr4
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr5
  TYPE(REGION_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(FIELD_TYPE), POINTER :: NullPtr8
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER :: NullPtr10
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr11
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr12
  TYPE(FIELDS_TYPE), POINTER :: NullPtr13
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr15
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr16
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr17

  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: Ptr0

  TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)

  
  ! Variable%EQUATIONS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MAPPING_LINEAR_TYPE, EQUATIONS_MAPPING_DYNAMIC_TYPE, EQUATIONS_MAPPING_RHS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, REGION_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_MAPPING_SOURCE_TYPE, EQUATIONS_MAPPING_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_NONLINEAR_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EQUATIONS_MAPPING_LINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_LINEAR_TYPE
! - signature type EQUATIONS_MAPPING_DYNAMIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_DYNAMIC_TYPE
! - signature type EQUATIONS_MAPPING_RHS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_RHS_TYPE
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type EQUATIONS_MAPPING_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_NONLINEAR_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_MAPPING
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MAPPING"
      CALL Print_EQUATIONS_MAPPING_TYPE(Variable% &
        & EQUATIONS_MAPPING, CheckVariable0, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, &
        & NullPtr7, NullPtr8, NullPtr9, NullPtr10, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_RESIDUAL_VARIABLES:    ", &
    & Variable%NUMBER_OF_RESIDUAL_VARIABLES
  
  ! Variable%RESIDUAL_VARIABLES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%RESIDUAL_VARIABLES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%RESIDUAL_VARIABLES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_PTR_TYPE), ALLOCATABLE :: " // &
      & "RESIDUAL_VARIABLES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%RESIDUAL_VARIABLES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%RESIDUAL_VARIABLES,1), MIN(LBOUND(Variable% &
      & RESIDUAL_VARIABLES,1)+MaxArrayLength, UBOUND(Variable%RESIDUAL_VARIABLES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_VARIABLE_PTR_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, FIELDS_TYPE, FIELD_PTR_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACE_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_NONLINEAR_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RESIDUAL_VARIABLES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_VARIABLE_PTR_TYPE(Variable% &
          & RESIDUAL_VARIABLES(I0), NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr8, NullPtr16, NullPtr6, &
          & NullPtr17, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_PTR_TYPE), ALLOCATABLE :: " // &
      & "RESIDUAL_VARIABLES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%VAR_TO_JACOBIAN_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VAR_TO_JACOBIAN_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VAR_TO_JACOBIAN_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(VAR_TO_EQUATIONS_JACOBIAN_MAP_TYPE), ALLOCATABLE :: " // &
      & "VAR_TO_JACOBIAN_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VAR_TO_JACOBIAN_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%VAR_TO_JACOBIAN_MAP,1), MIN(LBOUND(Variable% &
      & VAR_TO_JACOBIAN_MAP,1)+MaxArrayLength, UBOUND(Variable%VAR_TO_JACOBIAN_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_VAR_TO_EQUATIONS_JACOBIAN_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MAPPING_NONLINEAR_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VAR_TO_JACOBIAN_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_VAR_TO_EQUATIONS_JACOBIAN_MAP_TYPE(Variable%VAR_TO_JACOBIAN_MAP(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(VAR_TO_EQUATIONS_JACOBIAN_MAP_TYPE), ALLOCATABLE :: " // &
      & "VAR_TO_JACOBIAN_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%JACOBIAN_TO_VAR_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%JACOBIAN_TO_VAR_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%JACOBIAN_TO_VAR_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE), ALLOCATABLE :: " // &
      & "JACOBIAN_TO_VAR_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%JACOBIAN_TO_VAR_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%JACOBIAN_TO_VAR_MAP,1), MIN(LBOUND(Variable% &
      & JACOBIAN_TO_VAR_MAP,1)+MaxArrayLength, UBOUND(Variable%JACOBIAN_TO_VAR_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MAPPING_NONLINEAR_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"JACOBIAN_TO_VAR_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE(Variable%JACOBIAN_TO_VAR_MAP(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE), ALLOCATABLE :: " // &
      & "JACOBIAN_TO_VAR_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "RESIDUAL_COEFFICIENT:        ", &
    & Variable%RESIDUAL_COEFFICIENT
  
  ! Variable%EQUATIONS_ROW_TO_RESIDUAL_DOF_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_ROW_TO_RESIDUAL_DOF_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_ROW_TO_RESIDUAL_DOF_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_ROW_TO_RESIDUAL_DOF_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_ROW_TO_RESIDUAL_DOF_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_ROW_TO_RESIDUAL_DOF_MAP,1), MIN(LBOUND(Variable% &
      & EQUATIONS_ROW_TO_RESIDUAL_DOF_MAP,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_ROW_TO_RESIDUAL_DOF_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_ROW_TO_RESIDUAL_DOF_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_ROW_TO_RESIDUAL_DOF_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EQUATIONS_MAPPING_NONLINEAR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MeshElementDataPointsType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(MeshElementDataPointsType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(MeshElementDataPointsType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfProjectedData:           ", &
    & Variable%numberOfProjectedData
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "elementNumber:                   ", &
    & Variable%elementNumber
  
  ! Variable%dataIndices(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%dataIndices)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%dataIndices),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshElementDataPointType), ALLOCATABLE :: " // &
      & "dataIndices(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%dataIndices, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%dataIndices,1), MIN(LBOUND(Variable%dataIndices,1)+MaxArrayLength, UBOUND(Variable%dataIndices,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_MeshElementDataPointType has the following CheckVariable types: 
! The type to handle in this routine is: MeshElementDataPointsType (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"dataIndices("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_MeshElementDataPointType(Variable%dataIndices(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshElementDataPointType), ALLOCATABLE :: " // &
      & "dataIndices(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_MeshElementDataPointsType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_NodalVectorType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(NodalVectorType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(NodalVectorType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfRows:                    ", &
    & Variable%numberOfRows
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "maxNumberOfRows:                 ", &
    & Variable%maxNumberOfRows
  
  ! Variable%rowDofs(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%rowDofs)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%rowDofs),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "rowDofs(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%rowDofs, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%rowDofs,1), MIN(LBOUND(Variable%rowDofs,1)+MaxArrayLength, UBOUND(Variable%rowDofs,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%rowDofs(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "rowDofs(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%vector(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%vector)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%vector),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "vector(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%vector, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%vector,1), MIN(LBOUND(Variable%vector,1)+MaxArrayLength, UBOUND(Variable%vector,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%vector(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "vector(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_NodalVectorType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_GEOMETRIC_PARAMETERS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable7

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr2
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr3
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr4
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr5
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr6
  TYPE(MESH_TYPE), POINTER :: NullPtr7
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr8
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr9
  TYPE(NODES_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr11
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr12
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr13
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr14

  TYPE(FIELD_PTR_TYPE), POINTER :: Ptr0

  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable1)) THEN
    Variable2 => CheckVariable1
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LINES:                 ", &
    & Variable%NUMBER_OF_LINES
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_AREAS:                 ", &
    & Variable%NUMBER_OF_AREAS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_VOLUMES:               ", &
    & Variable%NUMBER_OF_VOLUMES
  
  ! Variable%LENGTHS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LENGTHS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LENGTHS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "LENGTHS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LENGTHS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LENGTHS,1), MIN(LBOUND(Variable%LENGTHS,1)+MaxArrayLength, UBOUND(Variable%LENGTHS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LENGTHS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "LENGTHS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%AREAS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%AREAS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%AREAS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "AREAS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%AREAS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%AREAS,1), MIN(LBOUND(Variable%AREAS,1)+MaxArrayLength, UBOUND(Variable%AREAS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%AREAS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "AREAS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%VOLUMES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VOLUMES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VOLUMES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "VOLUMES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VOLUMES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%VOLUMES,1), MIN(LBOUND(Variable%VOLUMES,1)+MaxArrayLength, UBOUND(Variable%VOLUMES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%VOLUMES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "VOLUMES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_FIELDS_USING:          ", &
    & Variable%NUMBER_OF_FIELDS_USING
  
  ! Variable%FIELDS_USING(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%FIELDS_USING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_PTR_TYPE), POINTER :: " // &
      & "FIELDS_USING(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%FIELDS_USING,1), "): "
  
    DO I0 = LBOUND(Variable%FIELDS_USING,1), MIN(LBOUND(Variable%FIELDS_USING,1)+MaxArrayLength, UBOUND(Variable%FIELDS_USING,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_PTR_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_GEOMETRIC_PARAMETERS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_VARIABLE_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7

      ! if variable was already followed
      Ptr0 => Variable%FIELDS_USING(I0)
      IF (ASSOCIATED(Ptr0, CheckVariable3)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELDS_USING("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_PTR_TYPE(Variable% &
          & FIELDS_USING(I0), NullPtr0, NullPtr1, NullPtr2, CheckVariable3, CheckVariable5, NullPtr3, NullPtr4, &
          & CheckVariable6, NullPtr5, NullPtr6, NullPtr7, CheckVariable2, NullPtr8, NullPtr9, NullPtr10, NullPtr11, &
          & NullPtr12, NullPtr13, CheckVariable0, Variable2, NullPtr14, CheckVariable4, CheckVariable7, Depth+1, MaxDepth, &
          & MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_PTR_TYPE), POINTER :: " // &
      & "FIELDS_USING(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELD_GEOMETRIC_PARAMETERS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DISTRIBUTED_VECTOR_CMISS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER, INTENT(IN) :: CheckVariable2

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers

  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: Ptr0

  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable0)) THEN
    Variable2 => CheckVariable0
  ELSE
    Variable2 => Variable
  END IF 


  
  ! Variable%DISTRIBUTED_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DISTRIBUTED_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "DISTRIBUTED_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: DISTRIBUTED_VECTOR_CMISS_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_VECTOR_CMISS_TYPE (CheckVariable0), DISTRIBUTED_VECTOR_PETSC_TYPE (CheckVariable1), DISTRIBUTED_VECTOR_TYPE (CheckVariable2), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr0 => Variable%DISTRIBUTED_VECTOR
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DISTRIBUTED_VECTOR"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable% &
        & DISTRIBUTED_VECTOR, CheckVariable2, CheckVariable1, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "DISTRIBUTED_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "BASE_TAG_NUMBER:                 ", &
    & Variable%BASE_TAG_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "N:                               ", &
    & Variable%N
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DATA_SIZE:                       ", &
    & Variable%DATA_SIZE
  
  ! Variable%DATA_INTG(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_INTG)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_INTG),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DATA_INTG(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_INTG, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_INTG,1), MIN(LBOUND(Variable%DATA_INTG,1)+MaxArrayLength, UBOUND(Variable%DATA_INTG,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_INTG(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DATA_INTG(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_DP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_DP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_DP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "DATA_DP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_DP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_DP,1), MIN(LBOUND(Variable%DATA_DP,1)+MaxArrayLength, UBOUND(Variable%DATA_DP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_DP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "DATA_DP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_SP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_SP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_SP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(SP), ALLOCATABLE :: " // &
      & "DATA_SP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_SP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(SP), ALLOCATABLE :: " // &
      & "DATA_SP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_L(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_L)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_L),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "DATA_L(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_L, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_L,1), MIN(LBOUND(Variable%DATA_L,1)+MaxArrayLength, UBOUND(Variable%DATA_L,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_L(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "DATA_L(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%TRANSFERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%TRANSFERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%TRANSFERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TRANSFER_TYPE), ALLOCATABLE :: " // &
      & "TRANSFERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%TRANSFERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%TRANSFERS,1), MIN(LBOUND(Variable%TRANSFERS,1)+MaxArrayLength, UBOUND(Variable%TRANSFERS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DISTRIBUTED_VECTOR_TRANSFER_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: DISTRIBUTED_VECTOR_CMISS_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_VECTOR_CMISS_TYPE (CheckVariable0), DISTRIBUTED_VECTOR_PETSC_TYPE (CheckVariable1), DISTRIBUTED_VECTOR_TYPE (CheckVariable2), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is type of this print routine, use Variable2
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TRANSFERS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DISTRIBUTED_VECTOR_TRANSFER_TYPE(Variable% &
          & TRANSFERS(I0), CheckVariable2, Variable2, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TRANSFER_TYPE), ALLOCATABLE :: " // &
      & "TRANSFERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DISTRIBUTED_VECTOR_CMISS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_PARAMETER_SETS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_PARAMETER_SETS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable7

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr1
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr2
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr5
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr6
  TYPE(NODES_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9

  TYPE(FIELD_VARIABLE_TYPE), POINTER :: Ptr0

  TYPE(FIELD_PARAMETER_SETS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  
  ! Variable%FIELD_VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELD_VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "FIELD_VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: FIELD_PARAMETER_SETS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_VARIABLE_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE

    ! if variable was already followed
    Ptr0 => Variable%FIELD_VARIABLE
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELD_VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & FIELD_VARIABLE, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, NullPtr1, NullPtr2, CheckVariable3, &
        & NullPtr3, NullPtr4, CheckVariable4, CheckVariable5, NullPtr5, CheckVariable6, NullPtr6, NullPtr7, NullPtr8, &
        & CheckVariable7, NullPtr9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "FIELD_VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_PARAMETER_SETS:        ", &
    & Variable%NUMBER_OF_PARAMETER_SETS
  
  ! Variable%SET_TYPE(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%SET_TYPE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_PARAMETER_SET_PTR_TYPE), POINTER :: " // &
      & "SET_TYPE(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%SET_TYPE,1), "): "
  
    DO I0 = LBOUND(Variable%SET_TYPE,1), MIN(LBOUND(Variable%SET_TYPE,1)+MaxArrayLength, UBOUND(Variable%SET_TYPE,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_PARAMETER_SET_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_PARAMETER_SETS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_VARIABLE_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SET_TYPE("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_PARAMETER_SET_PTR_TYPE(Variable%SET_TYPE(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_PARAMETER_SET_PTR_TYPE), POINTER :: " // &
      & "SET_TYPE(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%PARAMETER_SETS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%PARAMETER_SETS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_PARAMETER_SET_PTR_TYPE), POINTER :: " // &
      & "PARAMETER_SETS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%PARAMETER_SETS,1), "): "
  
    DO I0 = LBOUND(Variable%PARAMETER_SETS,1), MIN(LBOUND(Variable%PARAMETER_SETS,1)+MaxArrayLength, UBOUND(Variable% &
      & PARAMETER_SETS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_PARAMETER_SET_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_PARAMETER_SETS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_VARIABLE_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PARAMETER_SETS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_PARAMETER_SET_PTR_TYPE(Variable%PARAMETER_SETS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_PARAMETER_SET_PTR_TYPE), POINTER :: " // &
      & "PARAMETER_SETS(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELD_PARAMETER_SETS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DECOMPOSITION_LINE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DECOMPOSITION_LINE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(DECOMPOSITION_LINE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER:                          ", &
    & Variable%NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "XI_DIRECTION:                    ", &
    & Variable%XI_DIRECTION
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SURROUNDING_ELEMENTS:  ", &
    & Variable%NUMBER_OF_SURROUNDING_ELEMENTS
  
  ! Variable%SURROUNDING_ELEMENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SURROUNDING_ELEMENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SURROUNDING_ELEMENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "SURROUNDING_ELEMENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SURROUNDING_ELEMENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SURROUNDING_ELEMENTS,1), MIN(LBOUND(Variable% &
      & SURROUNDING_ELEMENTS,1)+MaxArrayLength, UBOUND(Variable%SURROUNDING_ELEMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SURROUNDING_ELEMENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "SURROUNDING_ELEMENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ELEMENT_LINES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_LINES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_LINES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_LINES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_LINES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENT_LINES,1), MIN(LBOUND(Variable%ELEMENT_LINES,1)+MaxArrayLength, UBOUND(Variable%ELEMENT_LINES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ELEMENT_LINES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_LINES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
    PRINT*," "
    DO I0 = LBOUND(Variable%ADJACENT_LINES,1), 1
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ADJACENT_LINES(I0)

    ENDDO  ! I0
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "BOUNDARY_LINE:                                   ", &
    & Variable%BOUNDARY_LINE

  
END SUBROUTINE Print_DECOMPOSITION_LINE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DECOMPOSITION_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, Depth, MaxDepth, MaxArrayLength)
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(DecompositionDataPointsType), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable18

  ! iterator variables

  ! null pointers
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr1
  TYPE(FIELDS_TYPE), POINTER :: NullPtr2
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr3
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr4
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: NullPtr5

  TYPE(DECOMPOSITION_TYPE), POINTER :: Ptr0

  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable0)) THEN
    Variable2 => CheckVariable0
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_PTR_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_PTR_TYPE (CheckVariable0), DECOMPOSITION_ELEMENTS_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), MESHES_TYPE (CheckVariable3), DOMAIN_TYPE (CheckVariable4), MESH_PTR_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable7), DECOMPOSITION_FACES_TYPE (CheckVariable8), DecompositionDataPointsType (CheckVariable9), REGION_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), GENERATED_MESH_TYPE (CheckVariable12), DECOMPOSITION_LINES_TYPE (CheckVariable13), FIELD_TYPE (CheckVariable14), DECOMPOSITIONS_TYPE (CheckVariable15), InterfacePointsConnectivityType (CheckVariable16), DOMAIN_PTR_TYPE (CheckVariable17), INTERFACE_TYPE (CheckVariable18), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DOMAIN_MAPPINGS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_MAPPINGS_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_PTR_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TOPOLOGY_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable6
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable9
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable10

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_DECOMPOSITION_TYPE(Variable% &
        & PTR, CheckVariable3, CheckVariable5, NullPtr0, CheckVariable7, NullPtr1, CheckVariable12, CheckVariable14, &
        & CheckVariable16, CheckVariable18, CheckVariable4, CheckVariable11, CheckVariable8, CheckVariable1, &
        & CheckVariable2, Variable2, NullPtr2, CheckVariable15, CheckVariable17, NullPtr3, NullPtr4, NullPtr5, &
        & CheckVariable6, CheckVariable9, CheckVariable13, CheckVariable10, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DECOMPOSITION_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_PROBLEM_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, Depth, MaxDepth, MaxArrayLength)
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable11

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr3
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr9

  TYPE(PROBLEMS_TYPE), POINTER :: Ptr0
  TYPE(CONTROL_LOOP_TYPE), POINTER :: Ptr1

  TYPE(PROBLEM_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable11)) THEN
    Variable2 => CheckVariable11
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "PROBLEM_FINISHED:                                ", &
    & Variable%PROBLEM_FINISHED
  
  ! Variable%PROBLEMS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PROBLEMS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(PROBLEMS_TYPE), POINTER :: " // &
      & "PROBLEMS " // &
      & "(associated): " 
  
! Signature of Print_PROBLEMS_TYPE has the following CheckVariable types: HISTORY_TYPE, PROBLEMS_TYPE, SOLVERS_TYPE, CONTROL_LOOP_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, PROBLEM_PTR_TYPE, CONTROL_LOOP_WHILE_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: PROBLEM_TYPE (Variable)
! Available CheckVariables are: HISTORY_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), PROBLEM_PTR_TYPE (CheckVariable7), CONTROL_LOOP_WHILE_TYPE (CheckVariable8), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable9), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable10), PROBLEM_TYPE (CheckVariable11), 
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type PROBLEMS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type PROBLEM_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr0 => Variable%PROBLEMS
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PROBLEMS"
      CALL Print_PROBLEMS_TYPE(Variable% &
        & PROBLEMS, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(PROBLEMS_TYPE), POINTER :: " // &
      & "PROBLEMS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SPECIFICATION(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SPECIFICATION)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SPECIFICATION),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "SPECIFICATION(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SPECIFICATION, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SPECIFICATION,1), MIN(LBOUND(Variable%SPECIFICATION,1)+MaxArrayLength, UBOUND(Variable%SPECIFICATION,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SPECIFICATION(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "SPECIFICATION(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%CONTROL_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CONTROL_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, PROBLEMS_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: PROBLEM_TYPE (Variable)
! Available CheckVariables are: HISTORY_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), PROBLEM_PTR_TYPE (CheckVariable7), CONTROL_LOOP_WHILE_TYPE (CheckVariable8), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable9), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable10), PROBLEM_TYPE (CheckVariable11), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr1 => Variable%CONTROL_LOOP
    IF (ASSOCIATED(Ptr1, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CONTROL_LOOP"
      CALL Print_CONTROL_LOOP_TYPE(Variable% &
        & CONTROL_LOOP, CheckVariable8, CheckVariable1, CheckVariable5, CheckVariable6, NullPtr0, CheckVariable4, NullPtr1, &
        & NullPtr2, NullPtr3, NullPtr4, NullPtr5, CheckVariable9, NullPtr6, NullPtr7, CheckVariable10, CheckVariable0, &
        & NullPtr8, CheckVariable2, CheckVariable3, CheckVariable7, NullPtr9, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_PROBLEM_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BOUNDARY_CONDITIONS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, Depth, MaxDepth, MaxArrayLength)
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable20

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr8
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr9
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: NullPtr11
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr12
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr13
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: NullPtr14
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr15
  TYPE(HISTORY_TYPE), POINTER :: NullPtr16
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: NullPtr17

  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: Ptr0

  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable3)) THEN
    Variable2 => CheckVariable3
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)

  
  ! Variable%SOLVER_EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: " // &
      & "SOLVER_EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_EQUATIONS_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, PROBLEM_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, LINEAR_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: BOUNDARY_CONDITIONS_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), NONLINEAR_SOLVER_TYPE (CheckVariable2), BOUNDARY_CONDITIONS_TYPE (CheckVariable3), CELLML_EQUATIONS_TYPE (CheckVariable4), INTERFACE_CONDITION_TYPE (CheckVariable5), SOLVERS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), SOLVER_TYPE (CheckVariable8), SOLVER_MAPPING_TYPE (CheckVariable9), SOLVER_MATRICES_TYPE (CheckVariable10), LINEAR_SOLVER_TYPE (CheckVariable11), SOLVER_EQUATIONS_TYPE (CheckVariable12), OPTIMISER_SOLVER_TYPE (CheckVariable13), FIELD_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), BOUNDARY_CONDITIONS_VARIABLE_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), EIGENPROBLEM_SOLVER_TYPE (CheckVariable20), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable19
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable20

    ! if variable was already followed
    Ptr0 => Variable%SOLVER_EQUATIONS
    IF (ASSOCIATED(Ptr0, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_EQUATIONS"
      CALL Print_SOLVER_EQUATIONS_TYPE(Variable% &
        & SOLVER_EQUATIONS, CheckVariable5, NullPtr0, NullPtr1, CheckVariable14, NullPtr2, NullPtr3, NullPtr4, NullPtr5, &
        & CheckVariable2, NullPtr6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, NullPtr11, CheckVariable13, NullPtr12, &
        & CheckVariable16, CheckVariable18, CheckVariable19, NullPtr13, CheckVariable1, Variable2, CheckVariable4, &
        & CheckVariable15, NullPtr14, CheckVariable12, NullPtr15, NullPtr16, CheckVariable0, CheckVariable6, NullPtr17, &
        & CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable20, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: " // &
      & "SOLVER_EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "BOUNDARY_CONDITIONS_FINISHED:                    ", &
    & Variable%BOUNDARY_CONDITIONS_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_BOUNDARY_CONDITIONS_VARIABLES: ", &
    & Variable%NUMBER_OF_BOUNDARY_CONDITIONS_VARIABLES
  
  ! Variable%BOUNDARY_CONDITIONS_VARIABLES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%BOUNDARY_CONDITIONS_VARIABLES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%BOUNDARY_CONDITIONS_VARIABLES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BOUNDARY_CONDITIONS_VARIABLE_PTR_TYPE), ALLOCATABLE :: " // &
      & "BOUNDARY_CONDITIONS_VARIABLES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%BOUNDARY_CONDITIONS_VARIABLES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%BOUNDARY_CONDITIONS_VARIABLES,1), MIN(LBOUND(Variable% &
      & BOUNDARY_CONDITIONS_VARIABLES,1)+MaxArrayLength, UBOUND(Variable%BOUNDARY_CONDITIONS_VARIABLES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_BOUNDARY_CONDITIONS_VARIABLE_PTR_TYPE has the following CheckVariable types: BOUNDARY_CONDITIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, REGION_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, BOUNDARY_CONDITIONS_VARIABLE_TYPE, 
! The type to handle in this routine is: BOUNDARY_CONDITIONS_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), NONLINEAR_SOLVER_TYPE (CheckVariable2), BOUNDARY_CONDITIONS_TYPE (CheckVariable3), CELLML_EQUATIONS_TYPE (CheckVariable4), INTERFACE_CONDITION_TYPE (CheckVariable5), SOLVERS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), SOLVER_TYPE (CheckVariable8), SOLVER_MAPPING_TYPE (CheckVariable9), SOLVER_MATRICES_TYPE (CheckVariable10), LINEAR_SOLVER_TYPE (CheckVariable11), SOLVER_EQUATIONS_TYPE (CheckVariable12), OPTIMISER_SOLVER_TYPE (CheckVariable13), FIELD_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), BOUNDARY_CONDITIONS_VARIABLE_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), EIGENPROBLEM_SOLVER_TYPE (CheckVariable20), 
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type BOUNDARY_CONDITIONS_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable17
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BOUNDARY_CONDITIONS_VARIABLES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_BOUNDARY_CONDITIONS_VARIABLE_PTR_TYPE(Variable% &
          & BOUNDARY_CONDITIONS_VARIABLES(I0), Variable2, CheckVariable6, CheckVariable8, CheckVariable7, CheckVariable12, &
          & CheckVariable14, CheckVariable17, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BOUNDARY_CONDITIONS_VARIABLE_PTR_TYPE), ALLOCATABLE :: " // &
      & "BOUNDARY_CONDITIONS_VARIABLES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  Comment = ""
  IF (Variable%neumannMatrixSparsity == 1) THEN
    Comment = "SOLVER_SPARSE_MATRICES " // & 
      & "!Use sparse solver matrices"
  ENDIF
  IF (Variable%neumannMatrixSparsity == 2) THEN
    Comment = "SOLVER_FULL_MATRICES " // & 
      & "!Use fully populated solver matrices"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "neumannMatrixSparsity:           ", &
    & Variable%neumannMatrixSparsity, " ", TRIM(Comment)

  
END SUBROUTINE Print_BOUNDARY_CONDITIONS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_LIST_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(LIST_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(LIST_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(LIST_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_LIST_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: LIST_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_LIST_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(LIST_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_LIST_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SolverMappingDofCouplingsType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(SolverMappingDofCouplingsType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(SolverMappingDofCouplingsType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfCouplings:               ", &
    & Variable%numberOfCouplings
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "capacity:                        ", &
    & Variable%capacity
  
  ! Variable%dofCouplings(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%dofCouplings)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%dofCouplings),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BoundaryConditionsCoupledDofsPtrType), ALLOCATABLE :: " // &
      & "dofCouplings(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%dofCouplings, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%dofCouplings,1), MIN(LBOUND(Variable%dofCouplings,1)+MaxArrayLength, UBOUND(Variable%dofCouplings,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_BoundaryConditionsCoupledDofsPtrType has the following CheckVariable types: 
! The type to handle in this routine is: SolverMappingDofCouplingsType (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"dofCouplings("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_BoundaryConditionsCoupledDofsPtrType(Variable%dofCouplings(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BoundaryConditionsCoupledDofsPtrType), ALLOCATABLE :: " // &
      & "dofCouplings(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_SolverMappingDofCouplingsType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS_TYPE(Variable, CheckVariable0, CheckVariable1, &
  & CheckVariable2, CheckVariable3, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable3

  ! iterator variables

  ! null pointers
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr0
  TYPE(MESHES_TYPE), POINTER :: NullPtr1
  TYPE(EquationsSetDerivedType), POINTER :: NullPtr2
  TYPE(FIELD_TYPE), POINTER :: NullPtr3
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr4
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr5
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr8
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr10
  TYPE(FIELDS_TYPE), POINTER :: NullPtr11
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr12
  TYPE(NODES_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr14
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr15
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr16
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: NullPtr17
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr18
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr19
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: NullPtr20
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr21
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr22
  TYPE(REGION_TYPE), POINTER :: NullPtr23
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: NullPtr24


  TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "EQUATIONS_SET_INDEX:             ", &
    & Variable%EQUATIONS_SET_INDEX
  
  ! Variable%EQUATIONS_SET
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SET)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_TYPE has the following CheckVariable types: EQUATIONS_TYPE, MESHES_TYPE, EquationsSetDerivedType, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS_TYPE (Variable)
! Available CheckVariables are: SOLVER_TYPE (CheckVariable0), SOLVER_EQUATIONS_TYPE (CheckVariable1), BOUNDARY_CONDITIONS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), 
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type EquationsSetDerivedType
!   is not available in passing variables, use NullPtr of type EquationsSetDerivedType
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_MATERIALS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_ANALYTIC_TYPE
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_SOURCE_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_INDEPENDENT_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SET"
      CALL Print_EQUATIONS_SET_TYPE(Variable% &
        & EQUATIONS_SET, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, &
        & NullPtr9, NullPtr10, CheckVariable2, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, &
        & NullPtr18, NullPtr19, CheckVariable0, NullPtr20, CheckVariable3, NullPtr21, NullPtr22, CheckVariable1, NullPtr23, &
        & NullPtr24, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INTERFACE_MATRIX_INDEX:          ", &
    & Variable%INTERFACE_MATRIX_INDEX

  
END SUBROUTINE Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr1
  TYPE(EquationsSetDerivedType), POINTER :: NullPtr2
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: NullPtr4
  TYPE(FIELDS_TYPE), POINTER :: NullPtr5
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: NullPtr8
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: NullPtr9
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr10
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: NullPtr11
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr12
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr13
  TYPE(FIELD_TYPE), POINTER :: NullPtr14
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr15
  TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: NullPtr16
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr17
  TYPE(REGION_TYPE), POINTER :: NullPtr18
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: NullPtr19


  TYPE(EQUATIONS_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, BOUNDARY_CONDITIONS_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_SET_MATERIALS_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_TYPE, EQUATIONS_INTERPOLATION_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_PTR_TYPE (Variable)
! Available CheckVariables are: 
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EquationsSetDerivedType
!   is not available in passing variables, use NullPtr of type EquationsSetDerivedType
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_ANALYTIC_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_MATERIALS_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type EQUATIONS_INTERPOLATION_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_INTERPOLATION_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_INDEPENDENT_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_EQUATIONS_TYPE(Variable% &
        & PTR, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, NullPtr18, NullPtr19, &
        & Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MeshNodesType(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, Depth, MaxDepth, MaxArrayLength)
  TYPE(MeshNodesType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MeshComponentTopologyType), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(MeshNodesType), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(MeshElementsType), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(MeshDataPointsType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(MeshDofsType), POINTER, INTENT(IN) :: CheckVariable9

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_TYPE), POINTER :: NullPtr1
  TYPE(FIELDS_TYPE), POINTER :: NullPtr2
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr3
  TYPE(REGION_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr5
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr6
  TYPE(MESHES_TYPE), POINTER :: NullPtr7
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr8

  TYPE(MeshComponentTopologyType), POINTER :: Ptr0

  TYPE(MeshNodesType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable4)) THEN
    Variable2 => CheckVariable4
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)

  
  ! Variable%meshComponentTopology
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%meshComponentTopology)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshComponentTopologyType), POINTER :: " // &
      & "meshComponentTopology " // &
      & "(associated): " 
  
! Signature of Print_MeshComponentTopologyType has the following CheckVariable types: DATA_PROJECTION_TYPE, MESH_TYPE, MeshDataPointsType, MeshComponentTopologyPtrType, FIELD_TYPE, MESH_PTR_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, MeshNodesType, MeshElementsType, REGION_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, GENERATED_MESH_TYPE, MeshComponentTopologyType, MESHES_TYPE, DECOMPOSITIONS_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, MeshDofsType, 
! The type to handle in this routine is: MeshNodesType (Variable)
! Available CheckVariables are: MESH_TYPE (CheckVariable0), MeshComponentTopologyType (CheckVariable1), MeshComponentTopologyPtrType (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), MeshNodesType (CheckVariable4), MeshElementsType (CheckVariable5), MeshDataPointsType (CheckVariable6), DECOMPOSITIONS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), MeshDofsType (CheckVariable9), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MeshDataPointsType
!   matches available passing type, use it as CheckVariable6
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type MeshNodesType
!   is type of this print routine, use Variable2
! - signature type MeshElementsType
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type MeshComponentTopologyType
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type MeshDofsType
!   matches available passing type, use it as CheckVariable9

    ! if variable was already followed
    Ptr0 => Variable%meshComponentTopology
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"meshComponentTopology"
      CALL Print_MeshComponentTopologyType(Variable% &
        & meshComponentTopology, NullPtr0, CheckVariable0, CheckVariable6, CheckVariable2, NullPtr1, CheckVariable3, &
        & NullPtr2, NullPtr3, Variable2, CheckVariable5, NullPtr4, NullPtr5, NullPtr6, CheckVariable1, NullPtr7, &
        & CheckVariable7, NullPtr8, CheckVariable8, CheckVariable9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshComponentTopologyType), POINTER :: " // &
      & "meshComponentTopology (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfnodes:                   ", &
    & Variable%numberOfnodes
  
  ! Variable%nodes(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%nodes)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%nodes),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshNodeType), ALLOCATABLE :: " // &
      & "nodes(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%nodes, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%nodes,1), MIN(LBOUND(Variable%nodes,1)+MaxArrayLength, UBOUND(Variable%nodes,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_MeshNodeType has the following CheckVariable types: 
! The type to handle in this routine is: MeshNodesType (Variable)
! Available CheckVariables are: MESH_TYPE (CheckVariable0), MeshComponentTopologyType (CheckVariable1), MeshComponentTopologyPtrType (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), MeshNodesType (CheckVariable4), MeshElementsType (CheckVariable5), MeshDataPointsType (CheckVariable6), DECOMPOSITIONS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), MeshDofsType (CheckVariable9), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"nodes("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_MeshNodeType(Variable%nodes(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshNodeType), ALLOCATABLE :: " // &
      & "nodes(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%nodesTree
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%nodesTree)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(TREE_TYPE), POINTER :: " // &
      & "nodesTree " // &
      & "(associated): " 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(TREE_TYPE) :: Variable%" // &
        & "nodesTree (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(TREE_TYPE), POINTER :: " // &
      & "nodesTree (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_MeshNodesType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_FACES_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_FACES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable4

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_LINES_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_TYPE), POINTER :: NullPtr3
  TYPE(DOMAIN_DOFS_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr5
  TYPE(FIELDS_TYPE), POINTER :: NullPtr6
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr8
  TYPE(CELLML_TYPE), POINTER :: NullPtr9
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: NullPtr10
  TYPE(MESH_TYPE), POINTER :: NullPtr11
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr12
  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: NullPtr13
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr14
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr15
  TYPE(DecompositionDataPointsType), POINTER :: NullPtr16
  TYPE(DOMAIN_NODES_TYPE), POINTER :: NullPtr17
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: NullPtr18
  TYPE(REGION_TYPE), POINTER :: NullPtr19

  TYPE(DOMAIN_TYPE), POINTER :: Ptr0

  TYPE(DOMAIN_FACES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)

  
  ! Variable%DOMAIN
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DOMAIN)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_TYPE has the following CheckVariable types: DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, DOMAIN_LINES_TYPE, FIELD_TYPE, DOMAIN_DOFS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_FACES_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_ELEMENTS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_FACES_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DOMAIN_NODES_TYPE, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DOMAIN_FACES_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TOPOLOGY_TYPE (CheckVariable0), DECOMPOSITION_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DOMAIN_PTR_TYPE (CheckVariable3), DOMAIN_TYPE (CheckVariable4), 
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type DOMAIN_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_LINES_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type DOMAIN_DOFS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_DOFS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_FACES_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_ELEMENTS_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type DOMAIN_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_ELEMENTS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DOMAIN_FACES_TYPE
!   is type of this print routine, use Variable2
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DecompositionDataPointsType
!   is not available in passing variables, use NullPtr of type DecompositionDataPointsType
! - signature type DOMAIN_NODES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_NODES_TYPE
! - signature type DECOMPOSITION_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_LINES_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DOMAIN
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOMAIN"
      CALL Print_DOMAIN_TYPE(Variable% &
        & DOMAIN, CheckVariable2, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, CheckVariable4, NullPtr6, &
        & NullPtr7, NullPtr8, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, CheckVariable3, Variable2, &
        & NullPtr15, CheckVariable0, CheckVariable1, NullPtr16, NullPtr17, NullPtr18, NullPtr19, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_FACES:                 ", &
    & Variable%NUMBER_OF_FACES
  
  ! Variable%FACES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%FACES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%FACES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_FACE_TYPE), ALLOCATABLE :: " // &
      & "FACES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%FACES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%FACES,1), MIN(LBOUND(Variable%FACES,1)+MaxArrayLength, UBOUND(Variable%FACES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DOMAIN_FACE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DOMAIN_FACES_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TOPOLOGY_TYPE (CheckVariable0), DECOMPOSITION_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DOMAIN_PTR_TYPE (CheckVariable3), DOMAIN_TYPE (CheckVariable4), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FACES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DOMAIN_FACE_TYPE(Variable%FACES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_FACE_TYPE), ALLOCATABLE :: " // &
      & "FACES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DOMAIN_FACES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_LIST_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(LIST_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers


  TYPE(LIST_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "MUTABLE:                                         ", &
    & Variable%MUTABLE
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "LIST_FINISHED:                                   ", &
    & Variable%LIST_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_IN_LIST:                  ", &
    & Variable%NUMBER_IN_LIST
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DATA_DIMENSION:                  ", &
    & Variable%DATA_DIMENSION
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INITIAL_SIZE:                    ", &
    & Variable%INITIAL_SIZE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SIZE:                            ", &
    & Variable%SIZE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DATA_TYPE:                       ", &
    & Variable%DATA_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "KEY_DIMENSION:                   ", &
    & Variable%KEY_DIMENSION
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SORT_ORDER:                      ", &
    & Variable%SORT_ORDER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SORT_METHOD:                     ", &
    & Variable%SORT_METHOD
  
  ! Variable%LIST_INTG(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LIST_INTG)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LIST_INTG),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LIST_INTG(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LIST_INTG, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LIST_INTG,1), MIN(LBOUND(Variable%LIST_INTG,1)+MaxArrayLength, UBOUND(Variable%LIST_INTG,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LIST_INTG(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LIST_INTG(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LIST_INTG2(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LIST_INTG2)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LIST_INTG2),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LIST_INTG2(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LIST_INTG2, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LIST_INTG2,1), MIN(LBOUND(Variable%LIST_INTG2,1)+MaxArrayLength, UBOUND(Variable%LIST_INTG2,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%LIST_INTG2,2), MIN(LBOUND(Variable%LIST_INTG2,2)+MaxArrayLength, UBOUND(Variable%LIST_INTG2,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%LIST_INTG2(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LIST_INTG2(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LIST_SP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LIST_SP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LIST_SP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(SP), ALLOCATABLE :: " // &
      & "LIST_SP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LIST_SP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(SP), ALLOCATABLE :: " // &
      & "LIST_SP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LIST_SP2(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LIST_SP2)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LIST_SP2),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(SP), ALLOCATABLE :: " // &
      & "LIST_SP2(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LIST_SP2, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(SP), ALLOCATABLE :: " // &
      & "LIST_SP2(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LIST_DP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LIST_DP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LIST_DP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "LIST_DP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LIST_DP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LIST_DP,1), MIN(LBOUND(Variable%LIST_DP,1)+MaxArrayLength, UBOUND(Variable%LIST_DP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LIST_DP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "LIST_DP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LIST_DP2(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LIST_DP2)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LIST_DP2),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "LIST_DP2(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LIST_DP2, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LIST_DP2,1), MIN(LBOUND(Variable%LIST_DP2,1)+MaxArrayLength, UBOUND(Variable%LIST_DP2,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%LIST_DP2,2), MIN(LBOUND(Variable%LIST_DP2,2)+MaxArrayLength, UBOUND(Variable%LIST_DP2,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%LIST_DP2(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "LIST_DP2(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LIST_C_INT(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LIST_C_INT)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LIST_C_INT),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(C_INT), ALLOCATABLE :: " // &
      & "LIST_C_INT(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LIST_C_INT, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(C_INT), ALLOCATABLE :: " // &
      & "LIST_C_INT(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LIST_C_INT2(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LIST_C_INT2)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LIST_C_INT2),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(C_INT), ALLOCATABLE :: " // &
      & "LIST_C_INT2(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LIST_C_INT2, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(C_INT), ALLOCATABLE :: " // &
      & "LIST_C_INT2(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_LIST_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CONTROL_LOOP_TIME_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, Depth, MaxDepth, MaxArrayLength)
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable11

  ! iterator variables

  ! null pointers
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr3
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr9

  TYPE(CONTROL_LOOP_TYPE), POINTER :: Ptr0

  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable6)) THEN
    Variable2 => CheckVariable6
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  
  ! Variable%CONTROL_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CONTROL_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, PROBLEMS_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_TIME_TYPE (Variable)
! Available CheckVariables are: HISTORY_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), PROBLEM_PTR_TYPE (CheckVariable7), CONTROL_LOOP_WHILE_TYPE (CheckVariable8), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable9), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable10), PROBLEM_TYPE (CheckVariable11), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TIME_TYPE
!   is type of this print routine, use Variable2
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr0 => Variable%CONTROL_LOOP
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CONTROL_LOOP"
      CALL Print_CONTROL_LOOP_TYPE(Variable% &
        & CONTROL_LOOP, CheckVariable8, CheckVariable1, CheckVariable5, Variable2, NullPtr0, CheckVariable4, NullPtr1, &
        & NullPtr2, NullPtr3, NullPtr4, NullPtr5, CheckVariable9, NullPtr6, NullPtr7, CheckVariable10, CheckVariable0, &
        & NullPtr8, CheckVariable2, CheckVariable3, CheckVariable7, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ITERATION_NUMBER:                ", &
    & Variable%ITERATION_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_ITERATION_NUMBER:         ", &
    & Variable%GLOBAL_ITERATION_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "OUTPUT_NUMBER:                   ", &
    & Variable%OUTPUT_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INPUT_NUMBER:                    ", &
    & Variable%INPUT_NUMBER
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "CURRENT_TIME:                ", &
    & Variable%CURRENT_TIME
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "START_TIME:                  ", &
    & Variable%START_TIME
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "STOP_TIME:                   ", &
    & Variable%STOP_TIME
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "TIME_INCREMENT:              ", &
    & Variable%TIME_INCREMENT

  
END SUBROUTINE Print_CONTROL_LOOP_TIME_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_SET_EQUATIONS_SET_FIELD_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(EQUATIONS_SET_EQUATIONS_SET_FIELD_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(EquationsSetDerivedType), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable15

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr3
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr9
  TYPE(SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr16
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr19
  TYPE(MESH_TYPE), POINTER :: NullPtr20
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr21
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr23
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr24

  TYPE(EQUATIONS_SET_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(EQUATIONS_SET_EQUATIONS_SET_FIELD_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  
  ! Variable%EQUATIONS_SET
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SET)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_TYPE has the following CheckVariable types: EQUATIONS_TYPE, MESHES_TYPE, EquationsSetDerivedType, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_EQUATIONS_SET_FIELD_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable15

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_SET
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SET"
      CALL Print_EQUATIONS_SET_TYPE(Variable% &
        & EQUATIONS_SET, CheckVariable1, NullPtr0, CheckVariable3, CheckVariable12, NullPtr1, CheckVariable13, &
        & CheckVariable8, CheckVariable9, NullPtr2, NullPtr3, CheckVariable2, NullPtr4, CheckVariable5, NullPtr5, NullPtr6, &
        & NullPtr7, NullPtr8, CheckVariable0, CheckVariable4, NullPtr9, CheckVariable6, NullPtr10, CheckVariable7, &
        & NullPtr11, NullPtr12, CheckVariable10, CheckVariable11, CheckVariable14, CheckVariable15, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "EQUATIONS_SET_FIELD_FINISHED:                    ", &
    & Variable%EQUATIONS_SET_FIELD_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "EQUATIONS_SET_FIELD_AUTO_CREATED:                ", &
    & Variable%EQUATIONS_SET_FIELD_AUTO_CREATED
  
  ! Variable%EQUATIONS_SET_FIELD_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SET_FIELD_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "EQUATIONS_SET_FIELD_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_EQUATIONS_SET_FIELD_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr1 => Variable%EQUATIONS_SET_FIELD_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SET_FIELD_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & EQUATIONS_SET_FIELD_FIELD, NullPtr0, NullPtr13, NullPtr14, NullPtr15, CheckVariable12, NullPtr1, NullPtr16, &
        & CheckVariable13, CheckVariable9, NullPtr17, NullPtr2, NullPtr3, NullPtr18, NullPtr19, NullPtr20, CheckVariable5, &
        & NullPtr5, NullPtr21, NullPtr6, NullPtr22, NullPtr7, NullPtr8, CheckVariable0, NullPtr23, CheckVariable6, &
        & CheckVariable10, NullPtr24, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "EQUATIONS_SET_FIELD_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_SET_EQUATIONS_SET_FIELD_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_MAPPING_RHS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr2
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr3
  TYPE(INTERFACE_MATRICES_TYPE), POINTER :: NullPtr4
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr6
  TYPE(MESHES_TYPE), POINTER :: NullPtr7
  TYPE(FIELDS_TYPE), POINTER :: NullPtr8
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr9
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr10
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr11
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr12
  TYPE(CELLML_TYPE), POINTER :: NullPtr13
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr14
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr15
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr16
  TYPE(NODES_TYPE), POINTER :: NullPtr17
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr18
  TYPE(REGION_TYPE), POINTER :: NullPtr19
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr20

  TYPE(INTERFACE_MAPPING_TYPE), POINTER :: Ptr0

  TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)

  
  ! Variable%INTERFACE_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MAPPING_TYPE), POINTER :: " // &
      & "INTERFACE_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_MAPPING_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_MAPPING_RHS_TYPE, INTERFACE_EQUATIONS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_MAPPING_TYPE, FIELD_TYPE, INTERFACE_TYPE, INTERFACE_MATRICES_TYPE, 
! The type to handle in this routine is: INTERFACE_MAPPING_RHS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MAPPING_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type INTERFACE_MAPPING_RHS_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type INTERFACE_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MATRICES_TYPE

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_MAPPING
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_MAPPING"
      CALL Print_INTERFACE_MAPPING_TYPE(Variable% &
        & INTERFACE_MAPPING, NullPtr0, Variable2, CheckVariable2, NullPtr1, NullPtr2, CheckVariable1, NullPtr3, NullPtr4, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MAPPING_TYPE), POINTER :: " // &
      & "INTERFACE_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "RHS_VARIABLE_TYPE:               ", &
    & Variable%RHS_VARIABLE_TYPE
  
  ! Variable%RHS_VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RHS_VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "RHS_VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: INTERFACE_MAPPING_RHS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MAPPING_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RHS_VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & RHS_VARIABLE, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, &
        & NullPtr14, CheckVariable1, NullPtr15, NullPtr3, NullPtr16, NullPtr17, NullPtr18, NullPtr19, NullPtr20, Depth+1, &
        & MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "RHS_VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%RHS_VARIABLE_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RHS_VARIABLE_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "RHS_VARIABLE_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_MAPPING_RHS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MAPPING_TYPE (CheckVariable0), FIELD_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RHS_VARIABLE_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%RHS_VARIABLE_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "RHS_VARIABLE_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "RHS_COEFFICIENT:             ", &
    & Variable%RHS_COEFFICIENT
  
  ! Variable%RHS_DOF_TO_INTERFACE_ROW_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%RHS_DOF_TO_INTERFACE_ROW_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%RHS_DOF_TO_INTERFACE_ROW_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "RHS_DOF_TO_INTERFACE_ROW_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%RHS_DOF_TO_INTERFACE_ROW_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%RHS_DOF_TO_INTERFACE_ROW_MAP,1), MIN(LBOUND(Variable% &
      & RHS_DOF_TO_INTERFACE_ROW_MAP,1)+MaxArrayLength, UBOUND(Variable%RHS_DOF_TO_INTERFACE_ROW_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%RHS_DOF_TO_INTERFACE_ROW_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "RHS_DOF_TO_INTERFACE_ROW_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERFACE_ROW_TO_RHS_DOF_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_ROW_TO_RHS_DOF_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_ROW_TO_RHS_DOF_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERFACE_ROW_TO_RHS_DOF_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_ROW_TO_RHS_DOF_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%INTERFACE_ROW_TO_RHS_DOF_MAP,1), MIN(LBOUND(Variable% &
      & INTERFACE_ROW_TO_RHS_DOF_MAP,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_ROW_TO_RHS_DOF_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%INTERFACE_ROW_TO_RHS_DOF_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERFACE_ROW_TO_RHS_DOF_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_INTERFACE_MAPPING_RHS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%SPARSE_ROW_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SPARSE_ROW_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SPARSE_ROW_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "SPARSE_ROW_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SPARSE_ROW_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SPARSE_ROW_INDICES,1), MIN(LBOUND(Variable% &
      & SPARSE_ROW_INDICES,1)+MaxArrayLength, UBOUND(Variable%SPARSE_ROW_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SPARSE_ROW_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "SPARSE_ROW_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%SPARSE_COLUMN_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SPARSE_COLUMN_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SPARSE_COLUMN_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "SPARSE_COLUMN_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SPARSE_COLUMN_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SPARSE_COLUMN_INDICES,1), MIN(LBOUND(Variable% &
      & SPARSE_COLUMN_INDICES,1)+MaxArrayLength, UBOUND(Variable%SPARSE_COLUMN_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SPARSE_COLUMN_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "SPARSE_COLUMN_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_VERSIONS:              ", &
    & Variable%NUMBER_OF_VERSIONS
  
  ! Variable%VERSIONS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VERSIONS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VERSIONS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "VERSIONS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VERSIONS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%VERSIONS,1), MIN(LBOUND(Variable%VERSIONS,1)+MaxArrayLength, UBOUND(Variable%VERSIONS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%VERSIONS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "VERSIONS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DECOMPOSITION_TOPOLOGY_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, Depth, MaxDepth, MaxArrayLength)
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DecompositionDataPointsType), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable14

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr3
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr4
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr5
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr6
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr7
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr8
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: NullPtr9

  TYPE(DECOMPOSITION_TYPE), POINTER :: Ptr0
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: Ptr1
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: Ptr2
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: Ptr3
  TYPE(DecompositionDataPointsType), POINTER :: Ptr4

  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable6)) THEN
    Variable2 => CheckVariable6
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  
  ! Variable%decomposition
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%decomposition)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "decomposition " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_TOPOLOGY_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), FIELDS_TYPE (CheckVariable4), DECOMPOSITION_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), DecompositionDataPointsType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), DECOMPOSITION_FACES_TYPE (CheckVariable9), DECOMPOSITION_LINES_TYPE (CheckVariable10), FIELD_TYPE (CheckVariable11), DECOMPOSITIONS_TYPE (CheckVariable12), DOMAIN_PTR_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type DOMAIN_MAPPINGS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_MAPPINGS_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TOPOLOGY_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable5
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr0 => Variable%decomposition
    IF (ASSOCIATED(Ptr0, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"decomposition"
      CALL Print_DECOMPOSITION_TYPE(Variable% &
        & decomposition, NullPtr0, NullPtr1, NullPtr2, Variable2, NullPtr3, NullPtr4, CheckVariable11, NullPtr5, &
        & CheckVariable8, CheckVariable3, NullPtr6, CheckVariable9, CheckVariable0, CheckVariable1, CheckVariable2, &
        & CheckVariable4, CheckVariable12, CheckVariable13, NullPtr7, NullPtr8, NullPtr9, CheckVariable5, CheckVariable7, &
        & CheckVariable10, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "decomposition (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%elements
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%elements)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: " // &
      & "elements " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITION_ELEMENTS_TYPE has the following CheckVariable types: DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_TYPE, DECOMPOSITION_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, DecompositionDataPointsType, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_LINES_TYPE, FIELD_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_TOPOLOGY_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), FIELDS_TYPE (CheckVariable4), DECOMPOSITION_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), DecompositionDataPointsType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), DECOMPOSITION_FACES_TYPE (CheckVariable9), DECOMPOSITION_LINES_TYPE (CheckVariable10), FIELD_TYPE (CheckVariable11), DECOMPOSITIONS_TYPE (CheckVariable12), DOMAIN_PTR_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), 
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is type of this print routine, use Variable2
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable13

    ! if variable was already followed
    Ptr1 => Variable%elements
    IF (ASSOCIATED(Ptr1, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"elements"
      CALL Print_DECOMPOSITION_ELEMENTS_TYPE(Variable% &
        & elements, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable5, Variable2, &
        & CheckVariable7, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: " // &
      & "elements (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%lines
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%lines)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: " // &
      & "lines " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITION_LINES_TYPE has the following CheckVariable types: DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_TYPE, DECOMPOSITION_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, DecompositionDataPointsType, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_LINES_TYPE, FIELD_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_TOPOLOGY_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), FIELDS_TYPE (CheckVariable4), DECOMPOSITION_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), DecompositionDataPointsType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), DECOMPOSITION_FACES_TYPE (CheckVariable9), DECOMPOSITION_LINES_TYPE (CheckVariable10), FIELD_TYPE (CheckVariable11), DECOMPOSITIONS_TYPE (CheckVariable12), DOMAIN_PTR_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), 
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is type of this print routine, use Variable2
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable10
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable13

    ! if variable was already followed
    Ptr2 => Variable%lines
    IF (ASSOCIATED(Ptr2, CheckVariable10)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"lines"
      CALL Print_DECOMPOSITION_LINES_TYPE(Variable% &
        & lines, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable5, Variable2, CheckVariable7, &
        & CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: " // &
      & "lines (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%faces
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%faces)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: " // &
      & "faces " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITION_FACES_TYPE has the following CheckVariable types: DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_TYPE, DECOMPOSITION_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, DecompositionDataPointsType, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_LINES_TYPE, FIELD_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_TOPOLOGY_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), FIELDS_TYPE (CheckVariable4), DECOMPOSITION_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), DecompositionDataPointsType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), DECOMPOSITION_FACES_TYPE (CheckVariable9), DECOMPOSITION_LINES_TYPE (CheckVariable10), FIELD_TYPE (CheckVariable11), DECOMPOSITIONS_TYPE (CheckVariable12), DOMAIN_PTR_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), 
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is type of this print routine, use Variable2
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable13

    ! if variable was already followed
    Ptr3 => Variable%faces
    IF (ASSOCIATED(Ptr3, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"faces"
      CALL Print_DECOMPOSITION_FACES_TYPE(Variable% &
        & faces, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable5, Variable2, CheckVariable7, &
        & CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: " // &
      & "faces (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%dataPoints
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%dataPoints)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DecompositionDataPointsType), POINTER :: " // &
      & "dataPoints " // &
      & "(associated): " 
  
! Signature of Print_DecompositionDataPointsType has the following CheckVariable types: DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_TYPE, DECOMPOSITION_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, DecompositionDataPointsType, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_LINES_TYPE, FIELD_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_TOPOLOGY_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), FIELDS_TYPE (CheckVariable4), DECOMPOSITION_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), DecompositionDataPointsType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), DECOMPOSITION_FACES_TYPE (CheckVariable9), DECOMPOSITION_LINES_TYPE (CheckVariable10), FIELD_TYPE (CheckVariable11), DECOMPOSITIONS_TYPE (CheckVariable12), DOMAIN_PTR_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), 
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is type of this print routine, use Variable2
! - signature type DecompositionDataPointsType
!   matches available passing type (and equals subtype), use it as CheckVariable7
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable13

    ! if variable was already followed
    Ptr4 => Variable%dataPoints
    IF (ASSOCIATED(Ptr4, CheckVariable7)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"dataPoints"
      CALL Print_DecompositionDataPointsType(Variable% &
        & dataPoints, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable5, Variable2, &
        & CheckVariable7, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DecompositionDataPointsType), POINTER :: " // &
      & "dataPoints (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DECOMPOSITION_TOPOLOGY_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_LAGRANGE_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(INTERFACE_PENALTY_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable13

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr2
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr3
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr4
  TYPE(MESH_TYPE), POINTER :: NullPtr5
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr6
  TYPE(NODES_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr12
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr13
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr16
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr18
  TYPE(CELLML_TYPE), POINTER :: NullPtr19
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr20
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr21
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr22
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr23
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr24

  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable11)) THEN
    Variable2 => CheckVariable11
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  
  ! Variable%INTERFACE_CONDITION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_CONDITION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITION " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_CONDITION_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, SOLVER_EQUATIONS_TYPE, INTERFACE_LAGRANGE_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, INTERFACE_PENALTY_TYPE, GENERATED_MESHES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_LAGRANGE_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), INTERFACE_CONDITION_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), FIELDS_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), INTERFACE_DEPENDENT_TYPE (CheckVariable5), REGION_TYPE (CheckVariable6), INTERFACE_PENALTY_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITION_TYPE (CheckVariable10), INTERFACE_LAGRANGE_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), INTERFACE_TYPE (CheckVariable13), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_LAGRANGE_TYPE
!   is type of this print routine, use Variable2
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type INTERFACE_DEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type INTERFACE_PENALTY_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable6

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_CONDITION
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_CONDITION"
      CALL Print_INTERFACE_CONDITION_TYPE(Variable% &
        & INTERFACE_CONDITION, CheckVariable1, NullPtr0, NullPtr1, CheckVariable4, CheckVariable9, NullPtr2, &
        & CheckVariable13, NullPtr3, NullPtr4, CheckVariable12, NullPtr5, NullPtr6, CheckVariable2, CheckVariable3, &
        & CheckVariable8, Variable2, NullPtr7, NullPtr8, NullPtr9, CheckVariable0, NullPtr10, CheckVariable10, NullPtr11, &
        & CheckVariable5, NullPtr12, NullPtr13, CheckVariable7, NullPtr14, CheckVariable6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "LAGRANGE_FINISHED:                               ", &
    & Variable%LAGRANGE_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "LAGRANGE_FIELD_AUTO_CREATED:                     ", &
    & Variable%LAGRANGE_FIELD_AUTO_CREATED
  
  ! Variable%LAGRANGE_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LAGRANGE_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "LAGRANGE_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_LAGRANGE_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), INTERFACE_CONDITION_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), FIELDS_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), INTERFACE_DEPENDENT_TYPE (CheckVariable5), REGION_TYPE (CheckVariable6), INTERFACE_PENALTY_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITION_TYPE (CheckVariable10), INTERFACE_LAGRANGE_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), INTERFACE_TYPE (CheckVariable13), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable6

    ! if variable was already followed
    Ptr1 => Variable%LAGRANGE_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LAGRANGE_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & LAGRANGE_FIELD, NullPtr0, NullPtr1, CheckVariable4, NullPtr15, CheckVariable9, NullPtr16, NullPtr2, NullPtr17, &
        & CheckVariable13, NullPtr3, NullPtr18, NullPtr4, NullPtr19, CheckVariable12, NullPtr5, CheckVariable3, NullPtr14, &
        & NullPtr20, NullPtr7, NullPtr21, NullPtr8, NullPtr9, CheckVariable0, NullPtr22, CheckVariable10, NullPtr23, &
        & NullPtr24, CheckVariable6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "LAGRANGE_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COMPONENTS:            ", &
    & Variable%NUMBER_OF_COMPONENTS

  
END SUBROUTINE Print_INTERFACE_LAGRANGE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BOUNDARY_CONDITIONS_VARIABLE_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, Depth, MaxDepth, MaxArrayLength)
  TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable5

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr1
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr3
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr4
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr5
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr6
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr9
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr11
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr12
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr13
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr15
  TYPE(MESHES_TYPE), POINTER :: NullPtr16
  TYPE(FIELDS_TYPE), POINTER :: NullPtr17
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr18
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr19
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr20
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr21
  TYPE(CELLML_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr23
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr24
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr25
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr26
  TYPE(NODES_TYPE), POINTER :: NullPtr27
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr28
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr29

  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: Ptr0

  TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)
  Nullify(NullPtr29)

  
  ! Variable%BOUNDARY_CONDITIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%BOUNDARY_CONDITIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: " // &
      & "BOUNDARY_CONDITIONS " // &
      & "(associated): " 
  
! Signature of Print_BOUNDARY_CONDITIONS_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, EQUATIONS_SET_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, INTERFACE_CONDITION_TYPE, SOLVERS_TYPE, REGION_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, FIELD_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, BOUNDARY_CONDITIONS_VARIABLE_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: BOUNDARY_CONDITIONS_VARIABLE_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), SOLVER_TYPE (CheckVariable2), SOLVER_EQUATIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_TYPE (CheckVariable5), 
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_VARIABLE_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE

    ! if variable was already followed
    Ptr0 => Variable%BOUNDARY_CONDITIONS
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BOUNDARY_CONDITIONS"
      CALL Print_BOUNDARY_CONDITIONS_TYPE(Variable% &
        & BOUNDARY_CONDITIONS, NullPtr0, NullPtr1, NullPtr2, CheckVariable0, NullPtr3, NullPtr4, CheckVariable1, &
        & CheckVariable5, CheckVariable2, NullPtr5, NullPtr6, NullPtr7, CheckVariable3, NullPtr8, CheckVariable4, NullPtr9, &
        & NullPtr10, Variable2, NullPtr11, NullPtr12, NullPtr13, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: " // &
      & "BOUNDARY_CONDITIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "VARIABLE_TYPE:                   ", &
    & Variable%VARIABLE_TYPE
  
  ! Variable%VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: BOUNDARY_CONDITIONS_VARIABLE_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), SOLVER_TYPE (CheckVariable2), SOLVER_EQUATIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_TYPE (CheckVariable5), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & VARIABLE, NullPtr14, NullPtr15, NullPtr16, NullPtr17, NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, &
        & NullPtr23, CheckVariable4, NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, CheckVariable5, NullPtr29, &
        & Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DOF_TYPES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOF_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOF_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_TYPES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOF_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DOF_TYPES,1), MIN(LBOUND(Variable%DOF_TYPES,1)+MaxArrayLength, UBOUND(Variable%DOF_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DOF_TYPES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_TYPES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%CONDITION_TYPES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%CONDITION_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%CONDITION_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "CONDITION_TYPES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%CONDITION_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%CONDITION_TYPES,1), MIN(LBOUND(Variable%CONDITION_TYPES,1)+MaxArrayLength, UBOUND(Variable% &
      & CONDITION_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%CONDITION_TYPES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "CONDITION_TYPES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DIRICHLET_BOUNDARY_CONDITIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DIRICHLET_BOUNDARY_CONDITIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BOUNDARY_CONDITIONS_DIRICHLET_TYPE), POINTER :: " // &
      & "DIRICHLET_BOUNDARY_CONDITIONS " // &
      & "(associated): " 
  
! Signature of Print_BOUNDARY_CONDITIONS_DIRICHLET_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: BOUNDARY_CONDITIONS_VARIABLE_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), SOLVER_TYPE (CheckVariable2), SOLVER_EQUATIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_TYPE (CheckVariable5), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DIRICHLET_BOUNDARY_CONDITIONS"
      CALL Print_BOUNDARY_CONDITIONS_DIRICHLET_TYPE(Variable%DIRICHLET_BOUNDARY_CONDITIONS, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BOUNDARY_CONDITIONS_DIRICHLET_TYPE), POINTER :: " // &
      & "DIRICHLET_BOUNDARY_CONDITIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DIRICHLET_CONDITIONS:  ", &
    & Variable%NUMBER_OF_DIRICHLET_CONDITIONS
  
  ! Variable%neumannBoundaryConditions
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%neumannBoundaryConditions)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BoundaryConditionsNeumannType), POINTER :: " // &
      & "neumannBoundaryConditions " // &
      & "(associated): " 
  
! Signature of Print_BoundaryConditionsNeumannType has the following CheckVariable types: 
! The type to handle in this routine is: BOUNDARY_CONDITIONS_VARIABLE_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), SOLVER_TYPE (CheckVariable2), SOLVER_EQUATIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_TYPE (CheckVariable5), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"neumannBoundaryConditions"
      CALL Print_BoundaryConditionsNeumannType(Variable%neumannBoundaryConditions, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BoundaryConditionsNeumannType), POINTER :: " // &
      & "neumannBoundaryConditions (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%PRESSURE_INCREMENTED_BOUNDARY_CONDITIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PRESSURE_INCREMENTED_BOUNDARY_CONDITIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED_TYPE), POINTER :: " // &
      & "PRESSURE_INCREMENTED_BOUNDARY_CONDITIONS " // &
      & "(associated): " 
  
! Signature of Print_BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: BOUNDARY_CONDITIONS_VARIABLE_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), SOLVER_TYPE (CheckVariable2), SOLVER_EQUATIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_TYPE (CheckVariable5), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PRESSURE_INCREMENTED_BOUNDARY_CONDITIONS"
      CALL Print_BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED_TYPE(Variable% &
        & PRESSURE_INCREMENTED_BOUNDARY_CONDITIONS, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED_TYPE), POINTER :: " // &
      & "PRESSURE_INCREMENTED_BOUNDARY_CONDITIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DOF_COUNTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOF_COUNTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOF_COUNTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_COUNTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOF_COUNTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DOF_COUNTS,1), MIN(LBOUND(Variable%DOF_COUNTS,1)+MaxArrayLength, UBOUND(Variable%DOF_COUNTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DOF_COUNTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_COUNTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%parameterSetRequired(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%parameterSetRequired)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%parameterSetRequired),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "parameterSetRequired(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%parameterSetRequired, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%parameterSetRequired,1), MIN(LBOUND(Variable% &
      & parameterSetRequired,1)+MaxArrayLength, UBOUND(Variable%parameterSetRequired,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%parameterSetRequired(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "parameterSetRequired(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%dofConstraints
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%dofConstraints)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BoundaryConditionsDofConstraintsType), POINTER :: " // &
      & "dofConstraints " // &
      & "(associated): " 
  
! Signature of Print_BoundaryConditionsDofConstraintsType has the following CheckVariable types: 
! The type to handle in this routine is: BOUNDARY_CONDITIONS_VARIABLE_TYPE (Variable)
! Available CheckVariables are: BOUNDARY_CONDITIONS_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), SOLVER_TYPE (CheckVariable2), SOLVER_EQUATIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), REGION_TYPE (CheckVariable5), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"dofConstraints"
      CALL Print_BoundaryConditionsDofConstraintsType(Variable%dofConstraints, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BoundaryConditionsDofConstraintsType), POINTER :: " // &
      & "dofConstraints (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_BOUNDARY_CONDITIONS_VARIABLE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_LINES_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_LINES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable4

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr1
  TYPE(FIELD_TYPE), POINTER :: NullPtr2
  TYPE(DOMAIN_DOFS_TYPE), POINTER :: NullPtr3
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr4
  TYPE(FIELDS_TYPE), POINTER :: NullPtr5
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: NullPtr6
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_TYPE), POINTER :: NullPtr8
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: NullPtr9
  TYPE(MESH_TYPE), POINTER :: NullPtr10
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr11
  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: NullPtr12
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr13
  TYPE(DOMAIN_FACES_TYPE), POINTER :: NullPtr14
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr15
  TYPE(DecompositionDataPointsType), POINTER :: NullPtr16
  TYPE(DOMAIN_NODES_TYPE), POINTER :: NullPtr17
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: NullPtr18
  TYPE(REGION_TYPE), POINTER :: NullPtr19

  TYPE(DOMAIN_TYPE), POINTER :: Ptr0

  TYPE(DOMAIN_LINES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)

  
  ! Variable%DOMAIN
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DOMAIN)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_TYPE has the following CheckVariable types: DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, DOMAIN_LINES_TYPE, FIELD_TYPE, DOMAIN_DOFS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_FACES_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_ELEMENTS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_FACES_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DOMAIN_NODES_TYPE, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DOMAIN_LINES_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TOPOLOGY_TYPE (CheckVariable0), DECOMPOSITION_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DOMAIN_PTR_TYPE (CheckVariable3), DOMAIN_TYPE (CheckVariable4), 
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type DOMAIN_LINES_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type DOMAIN_DOFS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_DOFS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_FACES_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_ELEMENTS_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type DOMAIN_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_ELEMENTS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DOMAIN_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_FACES_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DecompositionDataPointsType
!   is not available in passing variables, use NullPtr of type DecompositionDataPointsType
! - signature type DOMAIN_NODES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_NODES_TYPE
! - signature type DECOMPOSITION_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_LINES_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DOMAIN
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOMAIN"
      CALL Print_DOMAIN_TYPE(Variable% &
        & DOMAIN, CheckVariable2, NullPtr0, NullPtr1, Variable2, NullPtr2, NullPtr3, NullPtr4, CheckVariable4, NullPtr5, &
        & NullPtr6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, CheckVariable3, NullPtr14, &
        & NullPtr15, CheckVariable0, CheckVariable1, NullPtr16, NullPtr17, NullPtr18, NullPtr19, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LINES:                 ", &
    & Variable%NUMBER_OF_LINES
  
  ! Variable%LINES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LINES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LINES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_LINE_TYPE), ALLOCATABLE :: " // &
      & "LINES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LINES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%LINES,1), MIN(LBOUND(Variable%LINES,1)+MaxArrayLength, UBOUND(Variable%LINES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DOMAIN_LINE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DOMAIN_LINES_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TOPOLOGY_TYPE (CheckVariable0), DECOMPOSITION_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DOMAIN_PTR_TYPE (CheckVariable3), DOMAIN_TYPE (CheckVariable4), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DOMAIN_LINE_TYPE(Variable%LINES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_LINE_TYPE), ALLOCATABLE :: " // &
      & "LINES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DOMAIN_LINES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DATA_POINTS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, Depth, MaxDepth, MaxArrayLength)
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable28

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr2
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr3
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr4
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr5

  TYPE(REGION_TYPE), POINTER :: Ptr0
  TYPE(INTERFACE_TYPE), POINTER :: Ptr1

  TYPE(DATA_POINTS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable21)) THEN
    Variable2 => CheckVariable21
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)

  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DATA_POINTS_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), GENERATED_MESH_PTR_TYPE (CheckVariable22), DATA_PROJECTION_TYPE (CheckVariable23), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable24), DECOMPOSITION_TYPE (CheckVariable25), EQUATIONS_SET_PTR_TYPE (CheckVariable26), FIELD_VARIABLE_TYPE (CheckVariable27), REGION_TYPE (CheckVariable28), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   is type of this print routine, use Variable2
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable28

    ! if variable was already followed
    Ptr0 => Variable%REGION
    IF (ASSOCIATED(Ptr0, CheckVariable28)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr0, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, NullPtr1, CheckVariable10, CheckVariable11, &
        & CheckVariable12, NullPtr2, CheckVariable13, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, &
        & CheckVariable19, NullPtr3, CheckVariable20, Variable2, CheckVariable22, CheckVariable23, CheckVariable24, &
        & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DATA_POINTS_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), GENERATED_MESH_PTR_TYPE (CheckVariable22), DATA_PROJECTION_TYPE (CheckVariable23), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable24), DECOMPOSITION_TYPE (CheckVariable25), EQUATIONS_SET_PTR_TYPE (CheckVariable26), FIELD_VARIABLE_TYPE (CheckVariable27), REGION_TYPE (CheckVariable28), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   is type of this print routine, use Variable2
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable28

    ! if variable was already followed
    Ptr1 => Variable%INTERFACE
    IF (ASSOCIATED(Ptr1, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE"
      CALL Print_INTERFACE_TYPE(Variable% &
        & INTERFACE, NullPtr4, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, NullPtr2, CheckVariable14, CheckVariable15, NullPtr5, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, Variable2, CheckVariable22, CheckVariable23, CheckVariable24, &
        & CheckVariable25, CheckVariable27, CheckVariable28, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "DATA_POINTS_FINISHED:                            ", &
    & Variable%DATA_POINTS_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DATA_POINTS:           ", &
    & Variable%NUMBER_OF_DATA_POINTS
  
  ! Variable%DATA_POINTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_POINTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_POINTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DATA_POINT_TYPE), ALLOCATABLE :: " // &
      & "DATA_POINTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_POINTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%DATA_POINTS,1), MIN(LBOUND(Variable%DATA_POINTS,1)+MaxArrayLength, UBOUND(Variable%DATA_POINTS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DATA_POINT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DATA_POINTS_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), GENERATED_MESH_PTR_TYPE (CheckVariable22), DATA_PROJECTION_TYPE (CheckVariable23), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable24), DECOMPOSITION_TYPE (CheckVariable25), EQUATIONS_SET_PTR_TYPE (CheckVariable26), FIELD_VARIABLE_TYPE (CheckVariable27), REGION_TYPE (CheckVariable28), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DATA_POINTS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DATA_POINT_TYPE(Variable%DATA_POINTS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DATA_POINT_TYPE), ALLOCATABLE :: " // &
      & "DATA_POINTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_POINTS_TREE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DATA_POINTS_TREE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(TREE_TYPE), POINTER :: " // &
      & "DATA_POINTS_TREE " // &
      & "(associated): " 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(TREE_TYPE) :: Variable%" // &
        & "DATA_POINTS_TREE (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(TREE_TYPE), POINTER :: " // &
      & "DATA_POINTS_TREE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DATA_PROJECTIONS:      ", &
    & Variable%NUMBER_OF_DATA_PROJECTIONS
  
  ! Variable%DATA_PROJECTIONS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_PROJECTIONS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_PROJECTIONS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DATA_PROJECTION_PTR_TYPE), ALLOCATABLE :: " // &
      & "DATA_PROJECTIONS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_PROJECTIONS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%DATA_PROJECTIONS,1), MIN(LBOUND(Variable%DATA_PROJECTIONS,1)+MaxArrayLength, UBOUND(Variable% &
      & DATA_PROJECTIONS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DATA_PROJECTION_PTR_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DATA_POINTS_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), GENERATED_MESH_PTR_TYPE (CheckVariable22), DATA_PROJECTION_TYPE (CheckVariable23), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable24), DECOMPOSITION_TYPE (CheckVariable25), EQUATIONS_SET_PTR_TYPE (CheckVariable26), FIELD_VARIABLE_TYPE (CheckVariable27), REGION_TYPE (CheckVariable28), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   is type of this print routine, use Variable2
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable28
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DATA_PROJECTIONS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DATA_PROJECTION_PTR_TYPE(Variable% &
          & DATA_PROJECTIONS(I0), CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable4, CheckVariable5, &
          & CheckVariable6, CheckVariable7, CheckVariable9, CheckVariable11, CheckVariable12, CheckVariable15, &
          & CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, Variable2, &
          & CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable27, CheckVariable28, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DATA_PROJECTION_PTR_TYPE), ALLOCATABLE :: " // &
      & "DATA_PROJECTIONS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_PROJECTIONS_TREE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DATA_PROJECTIONS_TREE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(TREE_TYPE), POINTER :: " // &
      & "DATA_PROJECTIONS_TREE " // &
      & "(associated): " 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(TREE_TYPE) :: Variable%" // &
        & "DATA_PROJECTIONS_TREE (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(TREE_TYPE), POINTER :: " // &
      & "DATA_PROJECTIONS_TREE (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DATA_POINTS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTEGER_INTG_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTEGER_INTG_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(INTEGER_INTG_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), POINTER :: " // &
      & "PTR(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%PTR,1), "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%PTR,1), MIN(LBOUND(Variable%PTR,1)+MaxArrayLength, UBOUND(Variable%PTR,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%PTR(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), POINTER :: " // &
      & "PTR(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTEGER_INTG_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_VARIABLE_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable17

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr2
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr3
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr5
  TYPE(MESH_TYPE), POINTER :: NullPtr6
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr7
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr8
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr10
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr11
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr13
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr14

  TYPE(FIELD_TYPE), POINTER :: Ptr0
  TYPE(REGION_TYPE), POINTER :: Ptr1

  TYPE(FIELD_VARIABLE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable9)) THEN
    Variable2 => CheckVariable9
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "VARIABLE_NUMBER:                 ", &
    & Variable%VARIABLE_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "VARIABLE_TYPE:                   ", &
    & Variable%VARIABLE_TYPE
  
  ! Variable%FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_VARIABLE_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable1), MESHES_TYPE (CheckVariable2), FIELDS_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), FIELD_PTR_TYPE (CheckVariable6), GENERATED_MESHES_TYPE (CheckVariable7), CELLML_TYPE (CheckVariable8), FIELD_VARIABLE_TYPE (CheckVariable9), FIELD_TYPE (CheckVariable10), INTERFACES_TYPE (CheckVariable11), INTERFACE_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), EQUATIONS_SETS_TYPE (CheckVariable15), REGION_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable10
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is type of this print routine, use Variable2
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable16

    ! if variable was already followed
    Ptr0 => Variable%FIELD
    IF (ASSOCIATED(Ptr0, CheckVariable10)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & FIELD, CheckVariable2, NullPtr0, NullPtr1, CheckVariable6, CheckVariable10, CheckVariable5, NullPtr2, &
        & CheckVariable15, CheckVariable12, NullPtr3, CheckVariable13, NullPtr4, CheckVariable8, NullPtr5, NullPtr6, &
        & CheckVariable3, CheckVariable7, NullPtr7, CheckVariable14, NullPtr8, CheckVariable11, CheckVariable17, &
        & CheckVariable0, CheckVariable1, CheckVariable4, NullPtr9, Variable2, CheckVariable16, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_VARIABLE_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable1), MESHES_TYPE (CheckVariable2), FIELDS_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), FIELD_PTR_TYPE (CheckVariable6), GENERATED_MESHES_TYPE (CheckVariable7), CELLML_TYPE (CheckVariable8), FIELD_VARIABLE_TYPE (CheckVariable9), FIELD_TYPE (CheckVariable10), INTERFACES_TYPE (CheckVariable11), INTERFACE_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), EQUATIONS_SETS_TYPE (CheckVariable15), REGION_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is type of this print routine, use Variable2
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable16

    ! if variable was already followed
    Ptr1 => Variable%REGION
    IF (ASSOCIATED(Ptr1, CheckVariable16)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, CheckVariable2, NullPtr0, NullPtr1, NullPtr10, CheckVariable6, NullPtr11, CheckVariable10, &
        & CheckVariable5, NullPtr2, CheckVariable15, CheckVariable12, NullPtr12, NullPtr13, NullPtr3, CheckVariable13, &
        & NullPtr4, CheckVariable8, NullPtr6, CheckVariable3, CheckVariable7, NullPtr7, CheckVariable14, NullPtr8, &
        & CheckVariable11, CheckVariable17, NullPtr14, CheckVariable0, CheckVariable1, CheckVariable4, NullPtr9, Variable2, &
        & CheckVariable16, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DIMENSION:                       ", &
    & Variable%DIMENSION
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DATA_TYPE:                       ", &
    & Variable%DATA_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DOF_ORDER_TYPE:                  ", &
    & Variable%DOF_ORDER_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "maxNumberElementInterpolationParameters: ", &
    & Variable%maxNumberElementInterpolationParameters
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "maxNumberNodeInterpolationParameters: ", &
    & Variable%maxNumberNodeInterpolationParameters
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DOFS:                  ", &
    & Variable%NUMBER_OF_DOFS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_DOFS:            ", &
    & Variable%TOTAL_NUMBER_OF_DOFS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_DOFS:           ", &
    & Variable%NUMBER_OF_GLOBAL_DOFS
  
  ! Variable%DOMAIN_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DOMAIN_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "DOMAIN_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_VARIABLE_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable1), MESHES_TYPE (CheckVariable2), FIELDS_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), FIELD_PTR_TYPE (CheckVariable6), GENERATED_MESHES_TYPE (CheckVariable7), CELLML_TYPE (CheckVariable8), FIELD_VARIABLE_TYPE (CheckVariable9), FIELD_TYPE (CheckVariable10), INTERFACES_TYPE (CheckVariable11), INTERFACE_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), EQUATIONS_SETS_TYPE (CheckVariable15), REGION_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOMAIN_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%DOMAIN_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "DOMAIN_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COMPONENTS:            ", &
    & Variable%NUMBER_OF_COMPONENTS
  
  ! Variable%COMPONENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COMPONENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COMPONENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_COMPONENT_TYPE), ALLOCATABLE :: " // &
      & "COMPONENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COMPONENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%COMPONENTS,1), MIN(LBOUND(Variable%COMPONENTS,1)+MaxArrayLength, UBOUND(Variable%COMPONENTS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_VARIABLE_COMPONENT_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, FIELDS_TYPE, FIELD_PTR_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_VARIABLE_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable1), MESHES_TYPE (CheckVariable2), FIELDS_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), FIELD_PTR_TYPE (CheckVariable6), GENERATED_MESHES_TYPE (CheckVariable7), CELLML_TYPE (CheckVariable8), FIELD_VARIABLE_TYPE (CheckVariable9), FIELD_TYPE (CheckVariable10), INTERFACES_TYPE (CheckVariable11), INTERFACE_TYPE (CheckVariable12), CELLML_ENVIRONMENTS_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), EQUATIONS_SETS_TYPE (CheckVariable15), REGION_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELD_VARIABLE_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable16
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"COMPONENTS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_VARIABLE_COMPONENT_TYPE(Variable% &
          & COMPONENTS(I0), CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable6, Variable2, CheckVariable10, &
          & CheckVariable12, CheckVariable16, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_COMPONENT_TYPE), ALLOCATABLE :: " // &
      & "COMPONENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_VARIABLE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_PARAM_TO_DOF_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_PARAM_TO_DOF_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(FIELD_PARAM_TO_DOF_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_CONSTANT_PARAMETERS:   ", &
    & Variable%NUMBER_OF_CONSTANT_PARAMETERS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "CONSTANT_PARAM2DOF_MAP:          ", &
    & Variable%CONSTANT_PARAM2DOF_MAP

  
END SUBROUTINE Print_FIELD_PARAM_TO_DOF_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DATA_PROJECTION_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, Depth, MaxDepth, MaxArrayLength)
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable22

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_TYPE), POINTER :: NullPtr2
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr3
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr4
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr5
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr6
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr7
  TYPE(MeshComponentTopologyType), POINTER :: NullPtr8
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: NullPtr9
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: NullPtr10
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr11
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr12
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr13
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr14
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: NullPtr15

  TYPE(DATA_POINTS_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1
  TYPE(MESH_TYPE), POINTER :: Ptr2

  TYPE(DATA_PROJECTION_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable18)) THEN
    Variable2 => CheckVariable18
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "DATA_PROJECTION_FINISHED:                        ", &
    & Variable%DATA_PROJECTION_FINISHED
  
  ! Variable%DATA_POINTS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DATA_POINTS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DATA_POINTS_TYPE), POINTER :: " // &
      & "DATA_POINTS " // &
      & "(associated): " 
  
! Signature of Print_DATA_POINTS_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DATA_PROJECTION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), MESH_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), DECOMPOSITIONS_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DATA_POINTS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable17
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable22

    ! if variable was already followed
    Ptr0 => Variable%DATA_POINTS
    IF (ASSOCIATED(Ptr0, CheckVariable17)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DATA_POINTS"
      CALL Print_DATA_POINTS_TYPE(Variable% &
        & DATA_POINTS, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, NullPtr0, CheckVariable8, NullPtr1, CheckVariable9, CheckVariable10, NullPtr2, &
        & NullPtr3, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
        & CheckVariable17, NullPtr4, Variable2, CheckVariable19, CheckVariable20, NullPtr5, CheckVariable21, &
        & CheckVariable22, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DATA_POINTS_TYPE), POINTER :: " // &
      & "DATA_POINTS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%PROJECTION_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PROJECTION_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "PROJECTION_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DATA_PROJECTION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), MESH_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), DECOMPOSITIONS_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DATA_PROJECTION_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable22

    ! if variable was already followed
    Ptr1 => Variable%PROJECTION_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PROJECTION_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & PROJECTION_FIELD, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable5, CheckVariable6, &
        & CheckVariable7, NullPtr0, CheckVariable8, CheckVariable9, CheckVariable10, NullPtr6, NullPtr2, NullPtr3, &
        & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, NullPtr7, CheckVariable16, &
        & CheckVariable17, Variable2, CheckVariable19, CheckVariable20, NullPtr5, CheckVariable21, CheckVariable22, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "PROJECTION_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "COORDINATE_SYSTEM_DIMENSIONS:    ", &
    & Variable%COORDINATE_SYSTEM_DIMENSIONS
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "MAXIMUM_ITERATION_UPDATE:    ", &
    & Variable%MAXIMUM_ITERATION_UPDATE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_ITERATIONS:    ", &
    & Variable%MAXIMUM_NUMBER_OF_ITERATIONS
  
  ! Variable%MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_TYPE), POINTER :: " // &
      & "MESH " // &
      & "(associated): " 
  
! Signature of Print_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, REGION_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DATA_PROJECTION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), MESH_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), DECOMPOSITIONS_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_CYLINDER_TYPE
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_ELLIPSOID_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable11
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is type of this print routine, use Variable2
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_REGULAR_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable22

    ! if variable was already followed
    Ptr2 => Variable%MESH
    IF (ASSOCIATED(Ptr2, CheckVariable11)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MESH"
      CALL Print_MESH_TYPE(Variable% &
        & MESH, NullPtr8, CheckVariable0, NullPtr9, CheckVariable1, CheckVariable2, NullPtr10, NullPtr11, CheckVariable3, &
        & CheckVariable4, CheckVariable5, NullPtr12, CheckVariable7, CheckVariable8, NullPtr13, NullPtr1, CheckVariable6, &
        & CheckVariable9, CheckVariable10, CheckVariable11, NullPtr14, CheckVariable12, CheckVariable13, CheckVariable14, &
        & CheckVariable15, NullPtr7, CheckVariable16, CheckVariable17, NullPtr4, Variable2, NullPtr15, CheckVariable20, &
        & CheckVariable22, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_TYPE), POINTER :: " // &
      & "MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_CLOSEST_ELEMENTS:      ", &
    & Variable%NUMBER_OF_CLOSEST_ELEMENTS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_XI:                    ", &
    & Variable%NUMBER_OF_XI
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "PROJECTION_TYPE:                 ", &
    & Variable%PROJECTION_TYPE
  
  ! Variable%STARTING_XI(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%STARTING_XI)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%STARTING_XI),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "STARTING_XI(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%STARTING_XI, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%STARTING_XI,1), MIN(LBOUND(Variable%STARTING_XI,1)+MaxArrayLength, UBOUND(Variable%STARTING_XI,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%STARTING_XI(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "STARTING_XI(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "ABSOLUTE_TOLERANCE:          ", &
    & Variable%ABSOLUTE_TOLERANCE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "RELATIVE_TOLERANCE:          ", &
    & Variable%RELATIVE_TOLERANCE
  
  ! Variable%candidateElementNumbers(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%candidateElementNumbers)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%candidateElementNumbers),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "candidateElementNumbers(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%candidateElementNumbers, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%candidateElementNumbers,1), MIN(LBOUND(Variable% &
      & candidateElementNumbers,1)+MaxArrayLength, UBOUND(Variable%candidateElementNumbers,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%candidateElementNumbers(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "candidateElementNumbers(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%localFaceLineNumbers(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%localFaceLineNumbers)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%localFaceLineNumbers),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "localFaceLineNumbers(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%localFaceLineNumbers, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%localFaceLineNumbers,1), MIN(LBOUND(Variable% &
      & localFaceLineNumbers,1)+MaxArrayLength, UBOUND(Variable%localFaceLineNumbers,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%localFaceLineNumbers(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "localFaceLineNumbers(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "DATA_PROJECTION_PROJECTED:                       ", &
    & Variable%DATA_PROJECTION_PROJECTED
  
  ! Variable%DATA_PROJECTION_RESULTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_PROJECTION_RESULTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_PROJECTION_RESULTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DATA_PROJECTION_RESULT_TYPE), ALLOCATABLE :: " // &
      & "DATA_PROJECTION_RESULTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_PROJECTION_RESULTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%DATA_PROJECTION_RESULTS,1), MIN(LBOUND(Variable% &
      & DATA_PROJECTION_RESULTS,1)+MaxArrayLength, UBOUND(Variable%DATA_PROJECTION_RESULTS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DATA_PROJECTION_RESULT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DATA_PROJECTION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), INTERFACE_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), CELLML_ENVIRONMENTS_TYPE (CheckVariable10), MESH_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), DECOMPOSITIONS_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), INTERFACES_TYPE (CheckVariable16), DATA_POINTS_TYPE (CheckVariable17), DATA_PROJECTION_TYPE (CheckVariable18), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), FIELD_VARIABLE_TYPE (CheckVariable21), REGION_TYPE (CheckVariable22), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DATA_PROJECTION_RESULTS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DATA_PROJECTION_RESULT_TYPE(Variable%DATA_PROJECTION_RESULTS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DATA_PROJECTION_RESULT_TYPE), ALLOCATABLE :: " // &
      & "DATA_PROJECTION_RESULTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DATA_PROJECTION_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_COL_TO_STATIC_EQUATIONS_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_COL_TO_STATIC_EQUATIONS_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(SOLVER_COL_TO_STATIC_EQUATIONS_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LINEAR_EQUATIONS_MATRICES: ", &
    & Variable%NUMBER_OF_LINEAR_EQUATIONS_MATRICES
  
  ! Variable%EQUATIONS_MATRIX_NUMBERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_MATRIX_NUMBERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_MATRIX_NUMBERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_MATRIX_NUMBERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_MATRIX_NUMBERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_MATRIX_NUMBERS,1), MIN(LBOUND(Variable% &
      & EQUATIONS_MATRIX_NUMBERS,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_MATRIX_NUMBERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_MATRIX_NUMBERS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_MATRIX_NUMBERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_COL_NUMBERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_COL_NUMBERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_COL_NUMBERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_COL_NUMBERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_COL_NUMBERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_COL_NUMBERS,1), MIN(LBOUND(Variable% &
      & EQUATIONS_COL_NUMBERS,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_COL_NUMBERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_COL_NUMBERS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_COL_NUMBERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COUPLING_COEFFICIENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COUPLING_COEFFICIENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COUPLING_COEFFICIENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COUPLING_COEFFICIENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COUPLING_COEFFICIENTS,1), MIN(LBOUND(Variable% &
      & COUPLING_COEFFICIENTS,1)+MaxArrayLength, UBOUND(Variable%COUPLING_COEFFICIENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COUPLING_COEFFICIENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "JACOBIAN_COL_NUMBER:             ", &
    & Variable%JACOBIAN_COL_NUMBER
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "JACOBIAN_COUPLING_COEFFICIENT: ", &
    & Variable%JACOBIAN_COUPLING_COEFFICIENT

  
END SUBROUTINE Print_SOLVER_COL_TO_STATIC_EQUATIONS_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_PARAMETERS_FIELD_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable12

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr2
  TYPE(MESH_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_MODEL_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr9
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr11
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr12
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr13
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr14
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr15
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr16
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr17
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr18
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr19
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr20
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr21

  TYPE(CELLML_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable1)) THEN
    Variable2 => CheckVariable1
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)

  
  ! Variable%CELLML
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CELLML)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML " // &
      & "(associated): " 
  
! Signature of Print_CELLML_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, CELLML_MODEL_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_PARAMETERS_FIELD_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), CELLML_FIELD_MAPS_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), CELLML_ENVIRONMENTS_TYPE (CheckVariable6), CELLML_STATE_FIELD_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), CELLML_MODELS_FIELD_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable12), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CELLML_MODEL_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_MODEL_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr0 => Variable%CELLML
    IF (ASSOCIATED(Ptr0, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML"
      CALL Print_CELLML_TYPE(Variable% &
        & CELLML, NullPtr0, CheckVariable8, NullPtr1, CheckVariable10, CheckVariable12, CheckVariable5, NullPtr2, &
        & CheckVariable6, CheckVariable7, CheckVariable9, NullPtr3, CheckVariable2, CheckVariable4, NullPtr4, NullPtr5, &
        & NullPtr6, NullPtr7, NullPtr8, CheckVariable0, Variable2, CheckVariable3, NullPtr9, CheckVariable11, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "PARAMETERS_FIELD_FINISHED:                       ", &
    & Variable%PARAMETERS_FIELD_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "PARAMETERS_FIELD_AUTO_CREATED:                   ", &
    & Variable%PARAMETERS_FIELD_AUTO_CREATED
  
  ! Variable%PARAMETERS_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PARAMETERS_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "PARAMETERS_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_PARAMETERS_FIELD_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), CELLML_FIELD_MAPS_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), CELLML_ENVIRONMENTS_TYPE (CheckVariable6), CELLML_STATE_FIELD_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), CELLML_MODELS_FIELD_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable12), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr1 => Variable%PARAMETERS_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PARAMETERS_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & PARAMETERS_FIELD, NullPtr0, NullPtr10, NullPtr11, NullPtr12, CheckVariable8, NullPtr1, NullPtr13, NullPtr14, &
        & CheckVariable5, NullPtr15, CheckVariable6, NullPtr16, CheckVariable9, NullPtr17, NullPtr3, CheckVariable2, &
        & NullPtr5, NullPtr18, NullPtr6, NullPtr19, NullPtr7, NullPtr8, CheckVariable0, NullPtr20, CheckVariable3, &
        & NullPtr21, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "PARAMETERS_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_CELLML_PARAMETERS_FIELD_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_MATRICES_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_MATRICES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(INTERFACE_RHS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: NullPtr0
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(FIELDS_TYPE), POINTER :: NullPtr2
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: NullPtr3
  TYPE(INTERFACE_PENALTY_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER :: NullPtr7
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr9
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr11
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr12
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr13
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr14
  TYPE(SOLVER_MATRIX_TYPE), POINTER :: NullPtr15
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr16
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr17
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr18
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr19
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr20
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr21
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr22

  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: Ptr0
  TYPE(INTERFACE_MAPPING_TYPE), POINTER :: Ptr1
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: Ptr2
  TYPE(INTERFACE_RHS_TYPE), POINTER :: Ptr3

  TYPE(INTERFACE_MATRICES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)

  
  ! Variable%INTERFACE_EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_EQUATIONS_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_LAGRANGE_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_MATRICES_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, INTERFACE_MAPPING_TYPE, INTERFACE_PENALTY_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_EQUATIONS_INTERPOLATION_TYPE, INTERFACE_CONDITION_PTR_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRICES_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_EQUATIONS_TYPE (CheckVariable5), INTERFACE_RHS_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), INTERFACE_MAPPING_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type INTERFACE_LAGRANGE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_LAGRANGE_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type INTERFACE_MATRICES_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_DEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_DEPENDENT_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACE_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_PENALTY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PENALTY_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_EQUATIONS_INTERPOLATION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_INTERPOLATION_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_EQUATIONS
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_EQUATIONS"
      CALL Print_INTERFACE_EQUATIONS_TYPE(Variable% &
        & INTERFACE_EQUATIONS, CheckVariable0, NullPtr0, NullPtr1, Variable2, CheckVariable1, NullPtr2, CheckVariable2, &
        & CheckVariable3, NullPtr3, CheckVariable4, CheckVariable8, NullPtr4, CheckVariable5, CheckVariable7, NullPtr5, &
        & NullPtr6, CheckVariable9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "INTERFACE_MATRICES_FINISHED:                     ", &
    & Variable%INTERFACE_MATRICES_FINISHED
  
  ! Variable%INTERFACE_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MAPPING_TYPE), POINTER :: " // &
      & "INTERFACE_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_MAPPING_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_MAPPING_RHS_TYPE, INTERFACE_EQUATIONS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_MAPPING_TYPE, FIELD_TYPE, INTERFACE_TYPE, INTERFACE_MATRICES_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRICES_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_EQUATIONS_TYPE (CheckVariable5), INTERFACE_RHS_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), INTERFACE_MAPPING_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type INTERFACE_MAPPING_RHS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MAPPING_RHS_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MATRICES_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr1 => Variable%INTERFACE_MAPPING
    IF (ASSOCIATED(Ptr1, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_MAPPING"
      CALL Print_INTERFACE_MAPPING_TYPE(Variable% &
        & INTERFACE_MAPPING, CheckVariable0, NullPtr7, CheckVariable1, CheckVariable2, CheckVariable4, CheckVariable7, &
        & CheckVariable9, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MAPPING_TYPE), POINTER :: " // &
      & "INTERFACE_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOLVER_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MAPPING_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, DAE_SOLVER_TYPE, EQUATIONS_SET_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, EQUATIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, INTERFACE_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, SOLVER_MATRIX_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRICES_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_EQUATIONS_TYPE (CheckVariable5), INTERFACE_RHS_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), INTERFACE_MAPPING_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type SOLVER_MATRIX_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRIX_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE

    ! if variable was already followed
    Ptr2 => Variable%SOLVER_MAPPING
    IF (ASSOCIATED(Ptr2, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MAPPING"
      CALL Print_SOLVER_MAPPING_TYPE(Variable% &
        & SOLVER_MAPPING, CheckVariable0, NullPtr8, NullPtr9, NullPtr10, NullPtr1, NullPtr11, NullPtr12, NullPtr13, &
        & CheckVariable3, CheckVariable1, CheckVariable4, NullPtr14, NullPtr15, NullPtr16, CheckVariable5, NullPtr17, &
        & NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COLUMNS:               ", &
    & Variable%NUMBER_OF_COLUMNS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_COLUMNS:         ", &
    & Variable%TOTAL_NUMBER_OF_COLUMNS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_COLUMNS:        ", &
    & Variable%NUMBER_OF_GLOBAL_COLUMNS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_INTERFACE_MATRICES:    ", &
    & Variable%NUMBER_OF_INTERFACE_MATRICES
  
  ! Variable%MATRICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MATRICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MATRICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MATRIX_PTR_TYPE), ALLOCATABLE :: " // &
      & "MATRICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MATRICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%MATRICES,1), MIN(LBOUND(Variable%MATRICES,1)+MaxArrayLength, UBOUND(Variable%MATRICES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_MATRIX_PTR_TYPE has the following CheckVariable types: INTERFACE_MATRICES_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRICES_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_EQUATIONS_TYPE (CheckVariable5), INTERFACE_RHS_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), INTERFACE_MAPPING_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), 
! - signature type INTERFACE_MATRICES_TYPE
!   is type of this print routine, use Variable2
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATRICES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_MATRIX_PTR_TYPE(Variable%MATRICES(I0), Variable2, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MATRIX_PTR_TYPE), ALLOCATABLE :: " // &
      & "MATRICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%RHS_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RHS_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_RHS_TYPE), POINTER :: " // &
      & "RHS_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_RHS_TYPE has the following CheckVariable types: SOLVER_MAPPING_TYPE, INTERFACE_MATRICES_TYPE, INTERFACE_EQUATIONS_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRICES_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_EQUATIONS_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_EQUATIONS_TYPE (CheckVariable5), INTERFACE_RHS_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), INTERFACE_MAPPING_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), 
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACE_MATRICES_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1

    ! if variable was already followed
    Ptr3 => Variable%RHS_VECTOR
    IF (ASSOCIATED(Ptr3, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RHS_VECTOR"
      CALL Print_INTERFACE_RHS_TYPE(Variable% &
        & RHS_VECTOR, CheckVariable4, Variable2, CheckVariable1, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_RHS_TYPE), POINTER :: " // &
      & "RHS_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_MATRICES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DISTRIBUTED_MATRIX_PETSC_TYPE(Variable, CheckVariable0, Depth, MaxDepth, MaxArrayLength)
  TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER, INTENT(IN) :: CheckVariable0

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER :: NullPtr0

  TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: Ptr0

  TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)

  
  ! Variable%DISTRIBUTED_MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DISTRIBUTED_MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "DISTRIBUTED_MATRIX " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_MATRIX_TYPE has the following CheckVariable types: DISTRIBUTED_MATRIX_CMISS_TYPE, DISTRIBUTED_MATRIX_PETSC_TYPE, 
! The type to handle in this routine is: DISTRIBUTED_MATRIX_PETSC_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_MATRIX_TYPE (CheckVariable0), 
! - signature type DISTRIBUTED_MATRIX_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_CMISS_TYPE
! - signature type DISTRIBUTED_MATRIX_PETSC_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr0 => Variable%DISTRIBUTED_MATRIX
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DISTRIBUTED_MATRIX"
      CALL Print_DISTRIBUTED_MATRIX_TYPE(Variable%DISTRIBUTED_MATRIX, NullPtr0, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "DISTRIBUTED_MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "M:                               ", &
    & Variable%M
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "N:                               ", &
    & Variable%N
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_M:                        ", &
    & Variable%GLOBAL_M
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_N:                        ", &
    & Variable%GLOBAL_N
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "STORAGE_TYPE:                    ", &
    & Variable%STORAGE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_NON_ZEROS:                ", &
    & Variable%NUMBER_NON_ZEROS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DATA_SIZE:                       ", &
    & Variable%DATA_SIZE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_COLUMN_INDICES_PER_ROW:  ", &
    & Variable%MAXIMUM_COLUMN_INDICES_PER_ROW
  
  ! Variable%DIAGONAL_NUMBER_NON_ZEROS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DIAGONAL_NUMBER_NON_ZEROS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DIAGONAL_NUMBER_NON_ZEROS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DIAGONAL_NUMBER_NON_ZEROS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DIAGONAL_NUMBER_NON_ZEROS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DIAGONAL_NUMBER_NON_ZEROS,1), MIN(LBOUND(Variable% &
      & DIAGONAL_NUMBER_NON_ZEROS,1)+MaxArrayLength, UBOUND(Variable%DIAGONAL_NUMBER_NON_ZEROS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DIAGONAL_NUMBER_NON_ZEROS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DIAGONAL_NUMBER_NON_ZEROS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%OFFDIAGONAL_NUMBER_NON_ZEROS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%OFFDIAGONAL_NUMBER_NON_ZEROS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%OFFDIAGONAL_NUMBER_NON_ZEROS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "OFFDIAGONAL_NUMBER_NON_ZEROS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%OFFDIAGONAL_NUMBER_NON_ZEROS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%OFFDIAGONAL_NUMBER_NON_ZEROS,1), MIN(LBOUND(Variable% &
      & OFFDIAGONAL_NUMBER_NON_ZEROS,1)+MaxArrayLength, UBOUND(Variable%OFFDIAGONAL_NUMBER_NON_ZEROS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%OFFDIAGONAL_NUMBER_NON_ZEROS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "OFFDIAGONAL_NUMBER_NON_ZEROS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ROW_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ROW_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ROW_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ROW_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ROW_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ROW_INDICES,1), MIN(LBOUND(Variable%ROW_INDICES,1)+MaxArrayLength, UBOUND(Variable%ROW_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ROW_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ROW_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COLUMN_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COLUMN_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COLUMN_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLUMN_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COLUMN_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COLUMN_INDICES,1), MIN(LBOUND(Variable%COLUMN_INDICES,1)+MaxArrayLength, UBOUND(Variable% &
      & COLUMN_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COLUMN_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLUMN_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%GLOBAL_ROW_NUMBERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GLOBAL_ROW_NUMBERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GLOBAL_ROW_NUMBERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "GLOBAL_ROW_NUMBERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GLOBAL_ROW_NUMBERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%GLOBAL_ROW_NUMBERS,1), MIN(LBOUND(Variable% &
      & GLOBAL_ROW_NUMBERS,1)+MaxArrayLength, UBOUND(Variable%GLOBAL_ROW_NUMBERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%GLOBAL_ROW_NUMBERS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "GLOBAL_ROW_NUMBERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_DP(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%DATA_DP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), POINTER :: " // &
      & "DATA_DP(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%DATA_DP,1), "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_DP,1), MIN(LBOUND(Variable%DATA_DP,1)+MaxArrayLength, UBOUND(Variable%DATA_DP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_DP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), POINTER :: " // &
      & "DATA_DP(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "USE_OVERRIDE_MATRIX:                             ", &
    & Variable%USE_OVERRIDE_MATRIX

  
END SUBROUTINE Print_DISTRIBUTED_MATRIX_PETSC_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MeshNodeType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(MeshNodeType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(MeshNodeType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "meshNumber:                      ", &
    & Variable%meshNumber
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "globalNumber:                    ", &
    & Variable%globalNumber
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "userNumber:                      ", &
    & Variable%userNumber
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfDerivatives:             ", &
    & Variable%numberOfDerivatives
  
  ! Variable%derivatives(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%derivatives)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%derivatives),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshNodeDerivativeType), ALLOCATABLE :: " // &
      & "derivatives(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%derivatives, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%derivatives,1), MIN(LBOUND(Variable%derivatives,1)+MaxArrayLength, UBOUND(Variable%derivatives,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_MeshNodeDerivativeType has the following CheckVariable types: 
! The type to handle in this routine is: MeshNodeType (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"derivatives("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_MeshNodeDerivativeType(Variable%derivatives(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshNodeDerivativeType), ALLOCATABLE :: " // &
      & "derivatives(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfSurroundingElements:     ", &
    & Variable%numberOfSurroundingElements
  
  ! Variable%surroundingElements(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%surroundingElements)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), POINTER :: " // &
      & "surroundingElements(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%surroundingElements,1), "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%surroundingElements,1), MIN(LBOUND(Variable% &
      & surroundingElements,1)+MaxArrayLength, UBOUND(Variable%surroundingElements,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%surroundingElements(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), POINTER :: " // &
      & "surroundingElements(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "boundaryNode:                                    ", &
    & Variable%boundaryNode

  
END SUBROUTINE Print_MeshNodeType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_PROBLEMS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable10

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers

  TYPE(PROBLEM_PTR_TYPE), POINTER :: Ptr0

  TYPE(PROBLEMS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable1)) THEN
    Variable2 => CheckVariable1
  ELSE
    Variable2 => Variable
  END IF 


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_PROBLEMS:              ", &
    & Variable%NUMBER_OF_PROBLEMS
  
  ! Variable%PROBLEMS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%PROBLEMS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(PROBLEM_PTR_TYPE), POINTER :: " // &
      & "PROBLEMS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%PROBLEMS,1), "): "
  
    DO I0 = LBOUND(Variable%PROBLEMS,1), MIN(LBOUND(Variable%PROBLEMS,1)+MaxArrayLength, UBOUND(Variable%PROBLEMS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_PROBLEM_PTR_TYPE has the following CheckVariable types: HISTORY_TYPE, PROBLEMS_TYPE, SOLVERS_TYPE, CONTROL_LOOP_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, PROBLEM_PTR_TYPE, CONTROL_LOOP_WHILE_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: PROBLEMS_TYPE (Variable)
! Available CheckVariables are: HISTORY_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), CONTROL_LOOP_TYPE (CheckVariable3), CONTROL_LOOP_FIXED_TYPE (CheckVariable4), CONTROL_LOOP_TIME_TYPE (CheckVariable5), PROBLEM_PTR_TYPE (CheckVariable6), CONTROL_LOOP_WHILE_TYPE (CheckVariable7), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable8), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable9), PROBLEM_TYPE (CheckVariable10), 
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type PROBLEMS_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable6
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable10

      ! if variable was already followed
      Ptr0 => Variable%PROBLEMS(I0)
      IF (ASSOCIATED(Ptr0, CheckVariable6)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PROBLEMS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_PROBLEM_PTR_TYPE(Variable% &
          & PROBLEMS(I0), CheckVariable0, Variable2, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, &
          & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(PROBLEM_PTR_TYPE), POINTER :: " // &
      & "PROBLEMS(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_PROBLEMS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_CONDITION_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
  & CheckVariable24, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable24

  ! iterator variables

  ! null pointers
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: NullPtr1
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: NullPtr2
  TYPE(INTERFACE_PENALTY_TYPE), POINTER :: NullPtr3

  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: Ptr0

  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable9)) THEN
    Variable2 => CheckVariable9
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_CONDITION_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, SOLVER_EQUATIONS_TYPE, INTERFACE_LAGRANGE_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, INTERFACE_PENALTY_TYPE, GENERATED_MESHES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITION_PTR_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), InterfacePointsConnectivityType (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable7), CONTROL_LOOP_TYPE (CheckVariable8), INTERFACE_CONDITION_PTR_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), SOLVER_EQUATIONS_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), INTERFACES_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), DATA_PROJECTION_TYPE (CheckVariable17), SOLVERS_TYPE (CheckVariable18), DECOMPOSITION_TYPE (CheckVariable19), SOLVER_TYPE (CheckVariable20), SOLVER_MAPPING_TYPE (CheckVariable21), SOLVER_MATRICES_TYPE (CheckVariable22), GENERATED_MESHES_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is type of this print routine, use Variable2
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_LAGRANGE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_LAGRANGE_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type INTERFACE_DEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_DEPENDENT_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type INTERFACE_PENALTY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PENALTY_TYPE
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable24

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_INTERFACE_CONDITION_TYPE(Variable% &
        & PTR, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, Variable2, CheckVariable10, CheckVariable11, NullPtr0, &
        & CheckVariable12, CheckVariable13, NullPtr1, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, NullPtr2, CheckVariable21, CheckVariable22, NullPtr3, &
        & CheckVariable23, CheckVariable24, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_CONDITION_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_SET_MATERIALS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(EquationsSetDerivedType), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable15

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr3
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr9
  TYPE(SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr16
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr19
  TYPE(MESH_TYPE), POINTER :: NullPtr20
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr21
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr23
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr24

  TYPE(EQUATIONS_SET_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable8)) THEN
    Variable2 => CheckVariable8
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  
  ! Variable%EQUATIONS_SET
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SET)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_TYPE has the following CheckVariable types: EQUATIONS_TYPE, MESHES_TYPE, EquationsSetDerivedType, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_MATERIALS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable15

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_SET
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SET"
      CALL Print_EQUATIONS_SET_TYPE(Variable% &
        & EQUATIONS_SET, CheckVariable1, NullPtr0, CheckVariable3, CheckVariable12, NullPtr1, CheckVariable13, Variable2, &
        & CheckVariable9, NullPtr2, NullPtr3, CheckVariable2, NullPtr4, CheckVariable5, NullPtr5, NullPtr6, NullPtr7, &
        & NullPtr8, CheckVariable0, CheckVariable4, NullPtr9, CheckVariable6, NullPtr10, CheckVariable7, NullPtr11, &
        & NullPtr12, CheckVariable10, CheckVariable11, CheckVariable14, CheckVariable15, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "MATERIALS_FINISHED:                              ", &
    & Variable%MATERIALS_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "MATERIALS_FIELD_AUTO_CREATED:                    ", &
    & Variable%MATERIALS_FIELD_AUTO_CREATED
  
  ! Variable%MATERIALS_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MATERIALS_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "MATERIALS_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_MATERIALS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr1 => Variable%MATERIALS_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATERIALS_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & MATERIALS_FIELD, NullPtr0, NullPtr13, NullPtr14, NullPtr15, CheckVariable12, NullPtr1, NullPtr16, &
        & CheckVariable13, CheckVariable9, NullPtr17, NullPtr2, NullPtr3, NullPtr18, NullPtr19, NullPtr20, CheckVariable5, &
        & NullPtr5, NullPtr21, NullPtr6, NullPtr22, NullPtr7, NullPtr8, CheckVariable0, NullPtr23, CheckVariable6, &
        & CheckVariable10, NullPtr24, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "MATERIALS_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_SET_MATERIALS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_MAPPING_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_MAPPING_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(INTERFACE_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable7

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: NullPtr0
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(FIELDS_TYPE), POINTER :: NullPtr2
  TYPE(SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_PENALTY_TYPE), POINTER :: NullPtr5
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr8
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr10
  TYPE(MESHES_TYPE), POINTER :: NullPtr11
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr12
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr13
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr14
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr15
  TYPE(CELLML_TYPE), POINTER :: NullPtr16
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr17
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr18
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr19
  TYPE(NODES_TYPE), POINTER :: NullPtr20
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr21
  TYPE(REGION_TYPE), POINTER :: NullPtr22
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr23

  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: Ptr0
  TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER :: Ptr1

  TYPE(INTERFACE_MAPPING_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)

  
  ! Variable%INTERFACE_EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_EQUATIONS_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_LAGRANGE_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_MATRICES_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, INTERFACE_MAPPING_TYPE, INTERFACE_PENALTY_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_EQUATIONS_INTERPOLATION_TYPE, INTERFACE_CONDITION_PTR_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_MAPPING_RHS_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MATRICES_TYPE (CheckVariable7), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type INTERFACE_LAGRANGE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_LAGRANGE_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type INTERFACE_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type INTERFACE_DEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_DEPENDENT_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACE_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_PENALTY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PENALTY_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_EQUATIONS_INTERPOLATION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_INTERPOLATION_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_EQUATIONS
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_EQUATIONS"
      CALL Print_INTERFACE_EQUATIONS_TYPE(Variable% &
        & INTERFACE_EQUATIONS, CheckVariable0, NullPtr0, NullPtr1, CheckVariable7, CheckVariable2, NullPtr2, &
        & CheckVariable3, NullPtr3, NullPtr4, CheckVariable4, Variable2, NullPtr5, NullPtr6, CheckVariable5, NullPtr7, &
        & NullPtr8, CheckVariable6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "INTERFACE_MAPPING_FINISHED:                      ", &
    & Variable%INTERFACE_MAPPING_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LAGRANGE_VARIABLE_TYPE:          ", &
    & Variable%LAGRANGE_VARIABLE_TYPE
  
  ! Variable%LAGRANGE_VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LAGRANGE_VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "LAGRANGE_VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: INTERFACE_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_MAPPING_RHS_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MATRICES_TYPE (CheckVariable7), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LAGRANGE_VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & LAGRANGE_VARIABLE, NullPtr9, NullPtr10, NullPtr11, NullPtr2, NullPtr12, NullPtr13, NullPtr14, NullPtr15, &
        & NullPtr16, NullPtr17, CheckVariable5, NullPtr18, CheckVariable6, NullPtr19, NullPtr20, NullPtr21, NullPtr22, &
        & NullPtr23, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "LAGRANGE_VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COLUMNS:               ", &
    & Variable%NUMBER_OF_COLUMNS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_COLUMNS:         ", &
    & Variable%TOTAL_NUMBER_OF_COLUMNS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_COLUMNS:        ", &
    & Variable%NUMBER_OF_GLOBAL_COLUMNS
  
  ! Variable%COLUMN_DOFS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%COLUMN_DOFS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "COLUMN_DOFS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_MAPPING_RHS_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MATRICES_TYPE (CheckVariable7), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"COLUMN_DOFS_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%COLUMN_DOFS_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "COLUMN_DOFS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%LAGRANGE_DOF_TO_COLUMN_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LAGRANGE_DOF_TO_COLUMN_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LAGRANGE_DOF_TO_COLUMN_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LAGRANGE_DOF_TO_COLUMN_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LAGRANGE_DOF_TO_COLUMN_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LAGRANGE_DOF_TO_COLUMN_MAP,1), MIN(LBOUND(Variable% &
      & LAGRANGE_DOF_TO_COLUMN_MAP,1)+MaxArrayLength, UBOUND(Variable%LAGRANGE_DOF_TO_COLUMN_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LAGRANGE_DOF_TO_COLUMN_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LAGRANGE_DOF_TO_COLUMN_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_INTERFACE_MATRICES:    ", &
    & Variable%NUMBER_OF_INTERFACE_MATRICES
  
  ! Variable%INTERFACE_MATRIX_ROWS_TO_VAR_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_MATRIX_ROWS_TO_VAR_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_MATRIX_ROWS_TO_VAR_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MATRIX_TO_VAR_MAP_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_MATRIX_ROWS_TO_VAR_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_MATRIX_ROWS_TO_VAR_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_MATRIX_ROWS_TO_VAR_MAPS,1), MIN(LBOUND(Variable% &
      & INTERFACE_MATRIX_ROWS_TO_VAR_MAPS,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_MATRIX_ROWS_TO_VAR_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_MATRIX_TO_VAR_MAP_TYPE has the following CheckVariable types: INTERFACE_MAPPING_TYPE, INTERFACE_CONDITION_TYPE, FIELD_TYPE, INTERFACE_EQUATIONS_TYPE, 
! The type to handle in this routine is: INTERFACE_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_MAPPING_RHS_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MATRICES_TYPE (CheckVariable7), 
! - signature type INTERFACE_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_MATRIX_ROWS_TO_VAR_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_MATRIX_TO_VAR_MAP_TYPE(Variable% &
          & INTERFACE_MATRIX_ROWS_TO_VAR_MAPS(I0), Variable2, CheckVariable0, CheckVariable5, CheckVariable2, Depth+1, &
          & MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MATRIX_TO_VAR_MAP_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_MATRIX_ROWS_TO_VAR_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%RHS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RHS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER :: " // &
      & "RHS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_MAPPING_RHS_TYPE has the following CheckVariable types: INTERFACE_MAPPING_TYPE, FIELD_TYPE, INTERFACE_EQUATIONS_TYPE, 
! The type to handle in this routine is: INTERFACE_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_MAPPING_RHS_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MATRICES_TYPE (CheckVariable7), 
! - signature type INTERFACE_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2

    ! if variable was already followed
    Ptr1 => Variable%RHS_MAPPING
    IF (ASSOCIATED(Ptr1, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RHS_MAPPING"
      CALL Print_INTERFACE_MAPPING_RHS_TYPE(Variable% &
        & RHS_MAPPING, Variable2, CheckVariable5, CheckVariable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER :: " // &
      & "RHS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CREATE_VALUES_CACHE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CREATE_VALUES_CACHE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER :: " // &
      & "CREATE_VALUES_CACHE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_MAPPING_CREATE_VALUES_CACHE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), INTERFACE_MAPPING_RHS_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MATRICES_TYPE (CheckVariable7), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CREATE_VALUES_CACHE"
      CALL Print_INTERFACE_MAPPING_CREATE_VALUES_CACHE_TYPE(Variable%CREATE_VALUES_CACHE, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER :: " // &
      & "CREATE_VALUES_CACHE (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_MAPPING_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr1
  TYPE(MESHES_TYPE), POINTER :: NullPtr2
  TYPE(FIELDS_TYPE), POINTER :: NullPtr3
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr4
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr6
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr11
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr12
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr13
  TYPE(NODES_TYPE), POINTER :: NullPtr14
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr15
  TYPE(REGION_TYPE), POINTER :: NullPtr16
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr17


  TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRIX_NUMBER:            ", &
    & Variable%SOLVER_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LAGRANGE_VARIABLE_TYPE:          ", &
    & Variable%LAGRANGE_VARIABLE_TYPE
  
  ! Variable%LAGRANGE_VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LAGRANGE_VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "LAGRANGE_VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LAGRANGE_VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & LAGRANGE_VARIABLE, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, &
        & NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, Depth+1, &
        & MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "LAGRANGE_VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DEPENDENT_VARIABLES:   ", &
    & Variable%NUMBER_OF_DEPENDENT_VARIABLES
  
  ! Variable%DEPENDENT_VARIABLE_TYPES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DEPENDENT_VARIABLE_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DEPENDENT_VARIABLE_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DEPENDENT_VARIABLE_TYPES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DEPENDENT_VARIABLE_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DEPENDENT_VARIABLE_TYPES,1), MIN(LBOUND(Variable% &
      & DEPENDENT_VARIABLE_TYPES,1)+MaxArrayLength, UBOUND(Variable%DEPENDENT_VARIABLE_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DEPENDENT_VARIABLE_TYPES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DEPENDENT_VARIABLE_TYPES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DEPENDENT_VARIABLES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DEPENDENT_VARIABLES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DEPENDENT_VARIABLES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_PTR_TYPE), ALLOCATABLE :: " // &
      & "DEPENDENT_VARIABLES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DEPENDENT_VARIABLES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%DEPENDENT_VARIABLES,1), MIN(LBOUND(Variable% &
      & DEPENDENT_VARIABLES,1)+MaxArrayLength, UBOUND(Variable%DEPENDENT_VARIABLES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_VARIABLE_PTR_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, FIELDS_TYPE, FIELD_PTR_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACE_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DEPENDENT_VARIABLES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_VARIABLE_PTR_TYPE(Variable% &
          & DEPENDENT_VARIABLES(I0), NullPtr0, NullPtr1, NullPtr3, NullPtr6, NullPtr9, NullPtr10, NullPtr12, NullPtr16, &
          & NullPtr17, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_PTR_TYPE), ALLOCATABLE :: " // &
      & "DEPENDENT_VARIABLES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DEPENDENT_VARIABLE_TO_SOLVER_COL_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DEPENDENT_VARIABLE_TO_SOLVER_COL_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DEPENDENT_VARIABLE_TO_SOLVER_COL_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(VARIABLE_TO_SOLVER_COL_MAP_TYPE), ALLOCATABLE :: " // &
      & "DEPENDENT_VARIABLE_TO_SOLVER_COL_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DEPENDENT_VARIABLE_TO_SOLVER_COL_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%DEPENDENT_VARIABLE_TO_SOLVER_COL_MAPS,1), MIN(LBOUND(Variable% &
      & DEPENDENT_VARIABLE_TO_SOLVER_COL_MAPS,1)+MaxArrayLength, UBOUND(Variable%DEPENDENT_VARIABLE_TO_SOLVER_COL_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_VARIABLE_TO_SOLVER_COL_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DEPENDENT_VARIABLE_TO_SOLVER_COL_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_VARIABLE_TO_SOLVER_COL_MAP_TYPE(Variable% &
          & DEPENDENT_VARIABLE_TO_SOLVER_COL_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(VARIABLE_TO_SOLVER_COL_MAP_TYPE), ALLOCATABLE :: " // &
      & "DEPENDENT_VARIABLE_TO_SOLVER_COL_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_INTERFACE_MATRICES:    ", &
    & Variable%NUMBER_OF_INTERFACE_MATRICES
  
  ! Variable%INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TO_SOLVER_MAPS_PTR_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS,1), MIN(LBOUND(Variable% &
      & INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_TO_SOLVER_MAPS_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_TO_SOLVER_MAPS_PTR_TYPE(Variable% &
          & INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TO_SOLVER_MAPS_PTR_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_EQUATIONS_TO_SOLVER_MATRIX_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERFACE_COL_TO_SOLVER_COLS_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_COL_TO_SOLVER_COLS_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_COL_TO_SOLVER_COLS_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_COL_TO_SOLVER_COLS_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_COL_TO_SOLVER_COLS_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_COL_TO_SOLVER_COLS_MAP,1), MIN(LBOUND(Variable% &
      & INTERFACE_COL_TO_SOLVER_COLS_MAP,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_COL_TO_SOLVER_COLS_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_COL_TO_SOLVER_COLS_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE(Variable% &
          & INTERFACE_COL_TO_SOLVER_COLS_MAP(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_COL_TO_SOLVER_COLS_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MATRICES_LINEAR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: NullPtr1
  TYPE(SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: NullPtr4
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_TYPE), POINTER :: NullPtr6
  TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr8
  TYPE(REGION_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: NullPtr10

  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: Ptr0

  TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)

  
  ! Variable%EQUATIONS_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MATRICES_DYNAMIC_TYPE, SOLVER_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_MATRICES_RHS_TYPE, EQUATIONS_MATRICES_LINEAR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_MATRICES_SOURCE_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_MATRICES_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_LINEAR_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_MATRICES_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), EQUATIONS_TYPE (CheckVariable2), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EQUATIONS_MATRICES_DYNAMIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_DYNAMIC_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EQUATIONS_MATRICES_RHS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_RHS_TYPE
! - signature type EQUATIONS_MATRICES_LINEAR_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type EQUATIONS_MATRICES_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_SOURCE_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type EQUATIONS_MATRICES_NONLINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_NONLINEAR_TYPE

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_MATRICES
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MATRICES"
      CALL Print_EQUATIONS_MATRICES_TYPE(Variable% &
        & EQUATIONS_MATRICES, CheckVariable2, NullPtr0, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, NullPtr4, Variable2, &
        & NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LINEAR_MATRICES:       ", &
    & Variable%NUMBER_OF_LINEAR_MATRICES
  
  ! Variable%MATRICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MATRICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MATRICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRIX_PTR_TYPE), ALLOCATABLE :: " // &
      & "MATRICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MATRICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%MATRICES,1), MIN(LBOUND(Variable%MATRICES,1)+MaxArrayLength, UBOUND(Variable%MATRICES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_MATRIX_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MATRICES_LINEAR_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_MATRICES_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), EQUATIONS_TYPE (CheckVariable2), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATRICES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_MATRIX_PTR_TYPE(Variable%MATRICES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRIX_PTR_TYPE), ALLOCATABLE :: " // &
      & "MATRICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EQUATIONS_MATRICES_LINEAR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE(Variable, CheckVariable0, CheckVariable1, &
  & CheckVariable2, CheckVariable3, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr2
  TYPE(MESHES_TYPE), POINTER :: NullPtr3
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr4
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr5
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr6
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr7
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr8
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr9
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr10
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr11
  TYPE(CELLML_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr13
  TYPE(MESH_TYPE), POINTER :: NullPtr14
  TYPE(FIELDS_TYPE), POINTER :: NullPtr15
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr16
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr17
  TYPE(NODES_TYPE), POINTER :: NullPtr18
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr19
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr20
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr21
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr23
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr24
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr25
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr26
  TYPE(REGION_TYPE), POINTER :: NullPtr27

  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)

  
  ! Variable%INTERPOLATION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERPOLATION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: " // &
      & "INTERPOLATION " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_EQUATIONS_INTERPOLATION_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_EQUATIONS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_MAPPING_TYPE, FIELD_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_EQUATIONS_INTERPOLATION_TYPE (CheckVariable0), INTERFACE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), INTERFACE_EQUATIONS_TYPE (CheckVariable3), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable1

    ! if variable was already followed
    Ptr0 => Variable%INTERPOLATION
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERPOLATION"
      CALL Print_INTERFACE_EQUATIONS_INTERPOLATION_TYPE(Variable% &
        & INTERPOLATION, NullPtr0, CheckVariable3, NullPtr1, NullPtr2, CheckVariable2, CheckVariable1, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: " // &
      & "INTERPOLATION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%GEOMETRIC_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GEOMETRIC_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "GEOMETRIC_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_EQUATIONS_INTERPOLATION_TYPE (CheckVariable0), INTERFACE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), INTERFACE_EQUATIONS_TYPE (CheckVariable3), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr1 => Variable%GEOMETRIC_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GEOMETRIC_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & GEOMETRIC_FIELD, NullPtr3, NullPtr4, NullPtr1, NullPtr5, CheckVariable2, NullPtr6, NullPtr7, NullPtr8, &
        & CheckVariable1, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, &
        & NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "GEOMETRIC_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GEOMETRIC_INTERPOLATION_SETS: ", &
    & Variable%NUMBER_OF_GEOMETRIC_INTERPOLATION_SETS
  
  ! Variable%GEOMETRIC_INTERPOLATION(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GEOMETRIC_INTERPOLATION)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GEOMETRIC_INTERPOLATION),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE), ALLOCATABLE :: " // &
      & "GEOMETRIC_INTERPOLATION(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GEOMETRIC_INTERPOLATION, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%GEOMETRIC_INTERPOLATION,1), MIN(LBOUND(Variable% &
      & GEOMETRIC_INTERPOLATION,1)+MaxArrayLength, UBOUND(Variable%GEOMETRIC_INTERPOLATION,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_EQUATIONS_INTERPOLATION_TYPE (CheckVariable0), INTERFACE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), INTERFACE_EQUATIONS_TYPE (CheckVariable3), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GEOMETRIC_INTERPOLATION("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE(Variable% &
          & GEOMETRIC_INTERPOLATION(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE), ALLOCATABLE :: " // &
      & "GEOMETRIC_INTERPOLATION(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DEPENDENT_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DEPENDENT_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "DEPENDENT_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_EQUATIONS_INTERPOLATION_TYPE (CheckVariable0), INTERFACE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), INTERFACE_EQUATIONS_TYPE (CheckVariable3), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr1 => Variable%DEPENDENT_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DEPENDENT_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & DEPENDENT_FIELD, NullPtr3, NullPtr4, NullPtr1, NullPtr5, CheckVariable2, NullPtr6, NullPtr7, NullPtr8, &
        & CheckVariable1, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, &
        & NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "DEPENDENT_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DEPENDENT_INTERPOLATION_SETS: ", &
    & Variable%NUMBER_OF_DEPENDENT_INTERPOLATION_SETS
  
  ! Variable%DEPENDENT_INTERPOLATION(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DEPENDENT_INTERPOLATION)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DEPENDENT_INTERPOLATION),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE), ALLOCATABLE :: " // &
      & "DEPENDENT_INTERPOLATION(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DEPENDENT_INTERPOLATION, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%DEPENDENT_INTERPOLATION,1), MIN(LBOUND(Variable% &
      & DEPENDENT_INTERPOLATION,1)+MaxArrayLength, UBOUND(Variable%DEPENDENT_INTERPOLATION,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_EQUATIONS_INTERPOLATION_TYPE (CheckVariable0), INTERFACE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), INTERFACE_EQUATIONS_TYPE (CheckVariable3), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DEPENDENT_INTERPOLATION("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE(Variable% &
          & DEPENDENT_INTERPOLATION(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE), ALLOCATABLE :: " // &
      & "DEPENDENT_INTERPOLATION(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%PENALTY_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PENALTY_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "PENALTY_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_EQUATIONS_INTERPOLATION_TYPE (CheckVariable0), INTERFACE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), INTERFACE_EQUATIONS_TYPE (CheckVariable3), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr1 => Variable%PENALTY_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PENALTY_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & PENALTY_FIELD, NullPtr3, NullPtr4, NullPtr1, NullPtr5, CheckVariable2, NullPtr6, NullPtr7, NullPtr8, &
        & CheckVariable1, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, &
        & NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "PENALTY_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_PENALTY_INTERPOLATION_SETS: ", &
    & Variable%NUMBER_OF_PENALTY_INTERPOLATION_SETS
  
  ! Variable%PENALTY_INTERPOLATION(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%PENALTY_INTERPOLATION)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%PENALTY_INTERPOLATION),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE), ALLOCATABLE :: " // &
      & "PENALTY_INTERPOLATION(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%PENALTY_INTERPOLATION, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%PENALTY_INTERPOLATION,1), MIN(LBOUND(Variable% &
      & PENALTY_INTERPOLATION,1)+MaxArrayLength, UBOUND(Variable%PENALTY_INTERPOLATION,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_EQUATIONS_INTERPOLATION_TYPE (CheckVariable0), INTERFACE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), INTERFACE_EQUATIONS_TYPE (CheckVariable3), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PENALTY_INTERPOLATION("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE(Variable%PENALTY_INTERPOLATION(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE), ALLOCATABLE :: " // &
      & "PENALTY_INTERPOLATION(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_CONDITIONS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
  & CheckVariable24, CheckVariable25, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable25

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr0
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr1
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr3
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr4
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr8
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr9

  TYPE(INTERFACE_TYPE), POINTER :: Ptr0
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: Ptr1

  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable3)) THEN
    Variable2 => CheckVariable3
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  
  ! Variable%INTERFACE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITIONS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), GENERATED_MESH_PTR_TYPE (CheckVariable22), DATA_PROJECTION_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), REGION_TYPE (CheckVariable25), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable25

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE
    IF (ASSOCIATED(Ptr0, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE"
      CALL Print_INTERFACE_TYPE(Variable% &
        & INTERFACE, CheckVariable0, CheckVariable1, CheckVariable2, Variable2, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, NullPtr0, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, NullPtr1, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, NullPtr2, &
        & CheckVariable24, NullPtr3, CheckVariable25, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_INTERFACE_CONDITIONS:  ", &
    & Variable%NUMBER_OF_INTERFACE_CONDITIONS
  
  ! Variable%INTERFACE_CONDITIONS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%INTERFACE_CONDITIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITIONS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%INTERFACE_CONDITIONS,1), "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_CONDITIONS,1), MIN(LBOUND(Variable% &
      & INTERFACE_CONDITIONS,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_CONDITIONS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_CONDITION_PTR_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, SOLVER_EQUATIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, GENERATED_MESHES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITIONS_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), GENERATED_MESH_PTR_TYPE (CheckVariable22), DATA_PROJECTION_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), REGION_TYPE (CheckVariable25), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable14
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable25

      ! if variable was already followed
      Ptr1 => Variable%INTERFACE_CONDITIONS(I0)
      IF (ASSOCIATED(Ptr1, CheckVariable14)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_CONDITIONS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_CONDITION_PTR_TYPE(Variable% &
          & INTERFACE_CONDITIONS(I0), CheckVariable0, CheckVariable1, CheckVariable2, Variable2, CheckVariable6, &
          & CheckVariable8, CheckVariable9, CheckVariable11, CheckVariable13, CheckVariable14, CheckVariable15, NullPtr4, &
          & CheckVariable16, NullPtr5, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable23, NullPtr6, &
          & CheckVariable24, NullPtr7, NullPtr8, NullPtr9, CheckVariable17, CheckVariable25, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITIONS(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_CONDITIONS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MAPPING_SOURCE_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable3

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr4
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr5
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr6
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER :: NullPtr8
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr10
  TYPE(MESHES_TYPE), POINTER :: NullPtr11
  TYPE(FIELDS_TYPE), POINTER :: NullPtr12
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr13
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr16
  TYPE(CELLML_TYPE), POINTER :: NullPtr17
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr19
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr20
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr21
  TYPE(NODES_TYPE), POINTER :: NullPtr22
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr23

  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: Ptr0

  TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)

  
  ! Variable%EQUATIONS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MAPPING_LINEAR_TYPE, EQUATIONS_MAPPING_DYNAMIC_TYPE, EQUATIONS_MAPPING_RHS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, REGION_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_MAPPING_SOURCE_TYPE, EQUATIONS_MAPPING_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_SOURCE_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), REGION_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EQUATIONS_MAPPING_LINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_LINEAR_TYPE
! - signature type EQUATIONS_MAPPING_DYNAMIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_DYNAMIC_TYPE
! - signature type EQUATIONS_MAPPING_RHS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_RHS_TYPE
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type EQUATIONS_MAPPING_SOURCE_TYPE
!   is type of this print routine, use Variable2
! - signature type EQUATIONS_MAPPING_NONLINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_NONLINEAR_TYPE

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_MAPPING
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MAPPING"
      CALL Print_EQUATIONS_MAPPING_TYPE(Variable% &
        & EQUATIONS_MAPPING, CheckVariable0, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, CheckVariable2, &
        & NullPtr6, CheckVariable3, NullPtr7, Variable2, NullPtr8, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOURCE_VARIABLE_TYPE:            ", &
    & Variable%SOURCE_VARIABLE_TYPE
  
  ! Variable%SOURCE_VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOURCE_VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "SOURCE_VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_SOURCE_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), REGION_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOURCE_VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & SOURCE_VARIABLE, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, &
        & NullPtr17, NullPtr18, CheckVariable3, NullPtr19, NullPtr20, NullPtr21, NullPtr22, NullPtr7, CheckVariable2, &
        & NullPtr23, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "SOURCE_VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOURCE_VARIABLE_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOURCE_VARIABLE_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "SOURCE_VARIABLE_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MAPPING_SOURCE_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), REGION_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOURCE_VARIABLE_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%SOURCE_VARIABLE_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "SOURCE_VARIABLE_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "SOURCE_COEFFICIENT:          ", &
    & Variable%SOURCE_COEFFICIENT
  
  ! Variable%SOURCE_DOF_TO_EQUATIONS_ROW_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOURCE_DOF_TO_EQUATIONS_ROW_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOURCE_DOF_TO_EQUATIONS_ROW_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "SOURCE_DOF_TO_EQUATIONS_ROW_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOURCE_DOF_TO_EQUATIONS_ROW_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SOURCE_DOF_TO_EQUATIONS_ROW_MAP,1), MIN(LBOUND(Variable% &
      & SOURCE_DOF_TO_EQUATIONS_ROW_MAP,1)+MaxArrayLength, UBOUND(Variable%SOURCE_DOF_TO_EQUATIONS_ROW_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SOURCE_DOF_TO_EQUATIONS_ROW_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "SOURCE_DOF_TO_EQUATIONS_ROW_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_ROW_TO_SOURCE_DOF_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_ROW_TO_SOURCE_DOF_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_ROW_TO_SOURCE_DOF_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_ROW_TO_SOURCE_DOF_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_ROW_TO_SOURCE_DOF_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_ROW_TO_SOURCE_DOF_MAP,1), MIN(LBOUND(Variable% &
      & EQUATIONS_ROW_TO_SOURCE_DOF_MAP,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_ROW_TO_SOURCE_DOF_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_ROW_TO_SOURCE_DOF_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_ROW_TO_SOURCE_DOF_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EQUATIONS_MAPPING_SOURCE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BASIS_FUNCTIONS_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(BASIS_FUNCTIONS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(BASIS_TYPE), POINTER :: NullPtr0
  TYPE(BASIS_PTR_TYPE), POINTER :: NullPtr1


  TYPE(BASIS_FUNCTIONS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_BASIS_FUNCTIONS:          ", &
    & Variable%NUMBER_BASIS_FUNCTIONS
  
  ! Variable%BASES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%BASES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_PTR_TYPE), POINTER :: " // &
      & "BASES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%BASES,1), "): "
  
    DO I0 = LBOUND(Variable%BASES,1), MIN(LBOUND(Variable%BASES,1)+MaxArrayLength, UBOUND(Variable%BASES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_BASIS_PTR_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: BASIS_FUNCTIONS_TYPE (Variable)
! Available CheckVariables are: 
! - signature type BASIS_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_TYPE
! - signature type BASIS_PTR_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_PTR_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BASES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_BASIS_PTR_TYPE(Variable%BASES(I0), NullPtr0, NullPtr1, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_PTR_TYPE), POINTER :: " // &
      & "BASES(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_BASIS_FUNCTIONS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MATRIX_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(MATRIX_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(MATRIX_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ID:                              ", &
    & Variable%ID
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "MATRIX_FINISHED:                                 ", &
    & Variable%MATRIX_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "M:                               ", &
    & Variable%M
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "N:                               ", &
    & Variable%N
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAX_M:                           ", &
    & Variable%MAX_M
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAX_N:                           ", &
    & Variable%MAX_N
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DATA_TYPE:                       ", &
    & Variable%DATA_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "STORAGE_TYPE:                    ", &
    & Variable%STORAGE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_NON_ZEROS:                ", &
    & Variable%NUMBER_NON_ZEROS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SIZE:                            ", &
    & Variable%SIZE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_COLUMN_INDICES_PER_ROW:  ", &
    & Variable%MAXIMUM_COLUMN_INDICES_PER_ROW
  
  ! Variable%ROW_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ROW_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ROW_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ROW_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ROW_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ROW_INDICES,1), MIN(LBOUND(Variable%ROW_INDICES,1)+MaxArrayLength, UBOUND(Variable%ROW_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ROW_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ROW_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COLUMN_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COLUMN_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COLUMN_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLUMN_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COLUMN_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COLUMN_INDICES,1), MIN(LBOUND(Variable%COLUMN_INDICES,1)+MaxArrayLength, UBOUND(Variable% &
      & COLUMN_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COLUMN_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLUMN_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_INTG(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_INTG)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_INTG),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DATA_INTG(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_INTG, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_INTG,1), MIN(LBOUND(Variable%DATA_INTG,1)+MaxArrayLength, UBOUND(Variable%DATA_INTG,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_INTG(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DATA_INTG(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_SP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_SP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_SP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(SP), ALLOCATABLE :: " // &
      & "DATA_SP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_SP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(SP), ALLOCATABLE :: " // &
      & "DATA_SP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_DP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_DP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_DP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "DATA_DP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_DP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_DP,1), MIN(LBOUND(Variable%DATA_DP,1)+MaxArrayLength, UBOUND(Variable%DATA_DP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_DP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "DATA_DP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_L(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_L)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_L),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "DATA_L(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_L, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_L,1), MIN(LBOUND(Variable%DATA_L,1)+MaxArrayLength, UBOUND(Variable%DATA_L,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DATA_L(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "DATA_L(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_MATRIX_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACES_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable24

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr2
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr3
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr4
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr6

  TYPE(REGION_TYPE), POINTER :: Ptr0
  TYPE(INTERFACE_PTR_TYPE), POINTER :: Ptr1

  TYPE(INTERFACES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable18)) THEN
    Variable2 => CheckVariable18
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%PARENT_REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PARENT_REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "PARENT_REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACES_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), NODES_TYPE (CheckVariable17), INTERFACES_TYPE (CheckVariable18), DATA_POINTS_TYPE (CheckVariable19), GENERATED_MESH_PTR_TYPE (CheckVariable20), DATA_PROJECTION_TYPE (CheckVariable21), DECOMPOSITION_TYPE (CheckVariable22), EQUATIONS_SET_PTR_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is type of this print routine, use Variable2
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable24

    ! if variable was already followed
    Ptr0 => Variable%PARENT_REGION
    IF (ASSOCIATED(Ptr0, CheckVariable24)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PARENT_REGION"
      CALL Print_REGION_TYPE(Variable% &
        & PARENT_REGION, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr0, CheckVariable3, CheckVariable4, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, NullPtr1, CheckVariable10, &
        & CheckVariable11, CheckVariable12, NullPtr2, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
        & NullPtr3, CheckVariable17, NullPtr4, Variable2, CheckVariable19, CheckVariable20, CheckVariable21, NullPtr5, &
        & CheckVariable22, CheckVariable23, NullPtr6, CheckVariable24, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "PARENT_REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_INTERFACES:            ", &
    & Variable%NUMBER_OF_INTERFACES
  
  ! Variable%INTERFACES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%INTERFACES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_PTR_TYPE), POINTER :: " // &
      & "INTERFACES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%INTERFACES,1), "): "
  
    DO I0 = LBOUND(Variable%INTERFACES,1), MIN(LBOUND(Variable%INTERFACES,1)+MaxArrayLength, UBOUND(Variable%INTERFACES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_PTR_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, INTERFACES_TYPE, InterfacePointsConnectivityType, MESHES_TYPE, MESH_PTR_TYPE, FIELDS_TYPE, INTERFACE_CONDITIONS_TYPE, REGION_PTR_TYPE, MESH_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, INTERFACE_PTR_TYPE, GENERATED_MESHES_TYPE, FIELD_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, FIELD_PTR_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: INTERFACES_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), FIELDS_TYPE (CheckVariable15), GENERATED_MESHES_TYPE (CheckVariable16), NODES_TYPE (CheckVariable17), INTERFACES_TYPE (CheckVariable18), DATA_POINTS_TYPE (CheckVariable19), GENERATED_MESH_PTR_TYPE (CheckVariable20), DATA_PROJECTION_TYPE (CheckVariable21), DECOMPOSITION_TYPE (CheckVariable22), EQUATIONS_SET_PTR_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   is type of this print routine, use Variable2
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable10
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable19

      ! if variable was already followed
      Ptr1 => Variable%INTERFACES(I0)
      IF (ASSOCIATED(Ptr1, CheckVariable10)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_PTR_TYPE(Variable% &
          & INTERFACES(I0), CheckVariable21, Variable2, CheckVariable7, CheckVariable0, CheckVariable1, CheckVariable15, &
          & CheckVariable2, CheckVariable6, CheckVariable14, CheckVariable9, CheckVariable11, CheckVariable10, &
          & CheckVariable16, CheckVariable5, CheckVariable12, CheckVariable17, CheckVariable3, CheckVariable24, &
          & CheckVariable19, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_PTR_TYPE), POINTER :: " // &
      & "INTERFACES(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_MAPPING_VARIABLES_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_MAPPING_VARIABLES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(SOLVER_MAPPING_VARIABLES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_VARIABLES:             ", &
    & Variable%NUMBER_OF_VARIABLES
  
  ! Variable%VARIABLES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MAPPING_VARIABLE_TYPE), ALLOCATABLE :: " // &
      & "VARIABLES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%VARIABLES,1), MIN(LBOUND(Variable%VARIABLES,1)+MaxArrayLength, UBOUND(Variable%VARIABLES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_MAPPING_VARIABLE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: SOLVER_MAPPING_VARIABLES_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_MAPPING_VARIABLE_TYPE(Variable%VARIABLES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MAPPING_VARIABLE_TYPE), ALLOCATABLE :: " // &
      & "VARIABLES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_SOLVER_MAPPING_VARIABLES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_NEWTON_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable23

  ! iterator variables

  ! null pointers
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr6
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr8
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr12
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr13
  TYPE(FIELD_TYPE), POINTER :: NullPtr14
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr15
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr16

  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: Ptr0
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: Ptr1
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: Ptr2
  TYPE(SOLVER_TYPE), POINTER :: Ptr3

  TYPE(NEWTON_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable4)) THEN
    Variable2 => CheckVariable4
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)

  
  ! Variable%NONLINEAR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NONLINEAR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: " // &
      & "NONLINEAR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_NONLINEAR_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: NEWTON_SOLVER_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable1), QUASI_NEWTON_SOLVER_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), NEWTON_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), OPTIMISER_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable8), DYNAMIC_SOLVER_TYPE (CheckVariable9), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable10), GeometricTransformationSolverType (CheckVariable11), PROBLEM_TYPE (CheckVariable12), CELLML_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable16), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable17), HISTORY_TYPE (CheckVariable18), DAE_SOLVER_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), EIGENPROBLEM_SOLVER_TYPE (CheckVariable23), 
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable3
! - signature type NEWTON_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable11
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable12

    ! if variable was already followed
    Ptr0 => Variable%NONLINEAR_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable3)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NONLINEAR_SOLVER"
      CALL Print_NONLINEAR_SOLVER_TYPE(Variable% &
        & NONLINEAR_SOLVER, NullPtr0, CheckVariable0, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, CheckVariable2, &
        & CheckVariable3, Variable2, CheckVariable5, CheckVariable6, NullPtr4, NullPtr5, CheckVariable7, CheckVariable8, &
        & CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable23, NullPtr6, CheckVariable13, CheckVariable14, &
        & NullPtr7, CheckVariable15, CheckVariable16, CheckVariable17, NullPtr8, CheckVariable18, CheckVariable19, &
        & CheckVariable20, NullPtr9, CheckVariable21, NullPtr10, NullPtr11, NullPtr12, NullPtr13, CheckVariable22, &
        & CheckVariable12, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: " // &
      & "NONLINEAR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NEWTON_SOLVE_TYPE:               ", &
    & Variable%NEWTON_SOLVE_TYPE
  Comment = ""
  IF (Variable%SOLUTION_INITIALISE_TYPE == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%SOLUTION_INITIALISE_TYPE == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%SOLUTION_INITIALISE_TYPE == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLUTION_INITIALISE_TYPE:        ", &
    & Variable%SOLUTION_INITIALISE_TYPE, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS: ", &
    & Variable%TOTAL_NUMBER_OF_FUNCTION_EVALUATIONS, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS: ", &
    & Variable%TOTAL_NUMBER_OF_JACOBIAN_EVALUATIONS, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%MAXIMUM_NUMBER_OF_ITERATIONS == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%MAXIMUM_NUMBER_OF_ITERATIONS == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%MAXIMUM_NUMBER_OF_ITERATIONS == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_ITERATIONS:    ", &
    & Variable%MAXIMUM_NUMBER_OF_ITERATIONS, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS: ", &
    & Variable%MAXIMUM_NUMBER_OF_FUNCTION_EVALUATIONS, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%JACOBIAN_CALCULATION_TYPE == 1) THEN
    Comment = "SOLVER_NEWTON_JACOBIAN_NOT_CALCULATED " // & 
      & "!The Jacobian values will not be calculated for the nonlinear equations set"
  ENDIF
  IF (Variable%JACOBIAN_CALCULATION_TYPE == 2) THEN
    Comment = "SOLVER_NEWTON_JACOBIAN_EQUATIONS_CALCULATED " // & 
      & "!The Jacobian values will be calculated analytically for the nonlinear equations set"
  ENDIF
  IF (Variable%JACOBIAN_CALCULATION_TYPE == 3) THEN
    Comment = "SOLVER_NEWTON_JACOBIAN_FD_CALCULATED " // & 
      & "!The Jacobian values will be calculated using finite differences for the nonlinear equations set"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "JACOBIAN_CALCULATION_TYPE:       ", &
    & Variable%JACOBIAN_CALCULATION_TYPE, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%convergenceTestType == 1) THEN
    Comment = "SOLVER_NEWTON_CONVERGENCE_PETSC_DEFAULT " // & 
      & "!Petsc default convergence test"
  ENDIF
  IF (Variable%convergenceTestType == 2) THEN
    Comment = "SOLVER_NEWTON_CONVERGENCE_ENERGY_NORM " // & 
      & "!Energy norm convergence test"
  ENDIF
  IF (Variable%convergenceTestType == 3) THEN
    Comment = "SOLVER_NEWTON_CONVERGENCE_DIFFERENTIATED_RATIO " // & 
      & "!Sum of differentiated ratios of unconstrained to constrained residuals convergence test"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "convergenceTestType:             ", &
    & Variable%convergenceTestType, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "ABSOLUTE_TOLERANCE:          ", &
    & Variable%ABSOLUTE_TOLERANCE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "RELATIVE_TOLERANCE:          ", &
    & Variable%RELATIVE_TOLERANCE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "SOLUTION_TOLERANCE:          ", &
    & Variable%SOLUTION_TOLERANCE
  
  ! Variable%convergenceTest
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%convergenceTest)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NewtonSolverConvergenceTest), POINTER :: " // &
      & "convergenceTest " // &
      & "(associated): " 
  
! Signature of Print_NewtonSolverConvergenceTest has the following CheckVariable types: 
! The type to handle in this routine is: NEWTON_SOLVER_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable1), QUASI_NEWTON_SOLVER_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), NEWTON_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), OPTIMISER_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable8), DYNAMIC_SOLVER_TYPE (CheckVariable9), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable10), GeometricTransformationSolverType (CheckVariable11), PROBLEM_TYPE (CheckVariable12), CELLML_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable16), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable17), HISTORY_TYPE (CheckVariable18), DAE_SOLVER_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), EIGENPROBLEM_SOLVER_TYPE (CheckVariable23), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"convergenceTest"
      CALL Print_NewtonSolverConvergenceTest(Variable%convergenceTest, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NewtonSolverConvergenceTest), POINTER :: " // &
      & "convergenceTest (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%LINESEARCH_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINESEARCH_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: " // &
      & "LINESEARCH_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_NEWTON_LINESEARCH_SOLVER_TYPE has the following CheckVariable types: QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, NEWTON_SOLVER_TYPE, SOLVER_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, GeometricTransformationSolverType, NEWTON_LINESEARCH_SOLVER_TYPE, 
! The type to handle in this routine is: NEWTON_SOLVER_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable1), QUASI_NEWTON_SOLVER_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), NEWTON_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), OPTIMISER_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable8), DYNAMIC_SOLVER_TYPE (CheckVariable9), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable10), GeometricTransformationSolverType (CheckVariable11), PROBLEM_TYPE (CheckVariable12), CELLML_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable16), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable17), HISTORY_TYPE (CheckVariable18), DAE_SOLVER_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), EIGENPROBLEM_SOLVER_TYPE (CheckVariable23), 
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NEWTON_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable11
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1

    ! if variable was already followed
    Ptr1 => Variable%LINESEARCH_SOLVER
    IF (ASSOCIATED(Ptr1, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINESEARCH_SOLVER"
      CALL Print_NEWTON_LINESEARCH_SOLVER_TYPE(Variable% &
        & LINESEARCH_SOLVER, CheckVariable2, CheckVariable3, CheckVariable13, CheckVariable19, CheckVariable20, Variable2, &
        & CheckVariable21, CheckVariable22, CheckVariable15, CheckVariable7, CheckVariable14, CheckVariable9, &
        & CheckVariable10, CheckVariable16, CheckVariable23, CheckVariable11, CheckVariable1, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: " // &
      & "LINESEARCH_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%TRUSTREGION_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%TRUSTREGION_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: " // &
      & "TRUSTREGION_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_NEWTON_TRUSTREGION_SOLVER_TYPE has the following CheckVariable types: QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, NEWTON_SOLVER_TYPE, SOLVER_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, GeometricTransformationSolverType, NEWTON_LINESEARCH_SOLVER_TYPE, 
! The type to handle in this routine is: NEWTON_SOLVER_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable1), QUASI_NEWTON_SOLVER_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), NEWTON_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), OPTIMISER_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable8), DYNAMIC_SOLVER_TYPE (CheckVariable9), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable10), GeometricTransformationSolverType (CheckVariable11), PROBLEM_TYPE (CheckVariable12), CELLML_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable16), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable17), HISTORY_TYPE (CheckVariable18), DAE_SOLVER_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), EIGENPROBLEM_SOLVER_TYPE (CheckVariable23), 
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NEWTON_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable16
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable11
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1

    ! if variable was already followed
    Ptr2 => Variable%TRUSTREGION_SOLVER
    IF (ASSOCIATED(Ptr2, CheckVariable16)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TRUSTREGION_SOLVER"
      CALL Print_NEWTON_TRUSTREGION_SOLVER_TYPE(Variable% &
        & TRUSTREGION_SOLVER, CheckVariable2, CheckVariable3, CheckVariable13, CheckVariable19, CheckVariable20, Variable2, &
        & CheckVariable21, CheckVariable22, CheckVariable15, CheckVariable7, CheckVariable14, CheckVariable9, &
        & CheckVariable10, CheckVariable16, CheckVariable23, CheckVariable11, CheckVariable1, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: " // &
      & "TRUSTREGION_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%LINEAR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINEAR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "LINEAR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: NEWTON_SOLVER_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable1), QUASI_NEWTON_SOLVER_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), NEWTON_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), OPTIMISER_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable8), DYNAMIC_SOLVER_TYPE (CheckVariable9), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable10), GeometricTransformationSolverType (CheckVariable11), PROBLEM_TYPE (CheckVariable12), CELLML_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable16), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable17), HISTORY_TYPE (CheckVariable18), DAE_SOLVER_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), EIGENPROBLEM_SOLVER_TYPE (CheckVariable23), 
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type NEWTON_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable11
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable21
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable12

    ! if variable was already followed
    Ptr3 => Variable%LINEAR_SOLVER
    IF (ASSOCIATED(Ptr3, CheckVariable21)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINEAR_SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & LINEAR_SOLVER, NullPtr0, CheckVariable0, NullPtr14, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, CheckVariable2, &
        & CheckVariable3, Variable2, CheckVariable5, CheckVariable6, NullPtr4, NullPtr5, CheckVariable7, CheckVariable8, &
        & CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable23, NullPtr6, CheckVariable13, CheckVariable14, &
        & NullPtr11, NullPtr15, CheckVariable15, CheckVariable16, CheckVariable17, NullPtr8, CheckVariable18, &
        & CheckVariable19, CheckVariable20, NullPtr9, CheckVariable21, NullPtr10, NullPtr7, NullPtr12, NullPtr13, &
        & NullPtr16, CheckVariable22, CheckVariable12, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "LINEAR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CELLML_EVALUATOR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CELLML_EVALUATOR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "CELLML_EVALUATOR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: NEWTON_SOLVER_TYPE (Variable)
! Available CheckVariables are: CONTROL_LOOP_WHILE_TYPE (CheckVariable0), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable1), QUASI_NEWTON_SOLVER_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), NEWTON_SOLVER_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), OPTIMISER_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable8), DYNAMIC_SOLVER_TYPE (CheckVariable9), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable10), GeometricTransformationSolverType (CheckVariable11), PROBLEM_TYPE (CheckVariable12), CELLML_EQUATIONS_TYPE (CheckVariable13), CONTROL_LOOP_TYPE (CheckVariable14), SOLVER_EQUATIONS_TYPE (CheckVariable15), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable16), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable17), HISTORY_TYPE (CheckVariable18), DAE_SOLVER_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), LINEAR_SOLVER_TYPE (CheckVariable22), EIGENPROBLEM_SOLVER_TYPE (CheckVariable23), 
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type NEWTON_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable11
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable21
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable12

    ! if variable was already followed
    Ptr3 => Variable%CELLML_EVALUATOR_SOLVER
    IF (ASSOCIATED(Ptr3, CheckVariable21)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML_EVALUATOR_SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & CELLML_EVALUATOR_SOLVER, NullPtr0, CheckVariable0, NullPtr14, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, &
        & CheckVariable2, CheckVariable3, Variable2, CheckVariable5, CheckVariable6, NullPtr4, NullPtr5, CheckVariable7, &
        & CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable23, NullPtr6, CheckVariable13, &
        & CheckVariable14, NullPtr11, NullPtr15, CheckVariable15, CheckVariable16, CheckVariable17, NullPtr8, &
        & CheckVariable18, CheckVariable19, CheckVariable20, NullPtr9, CheckVariable21, NullPtr10, NullPtr7, NullPtr12, &
        & NullPtr13, NullPtr16, CheckVariable22, CheckVariable12, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "CELLML_EVALUATOR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_NEWTON_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_VAR_TO_EQUATIONS_COLUMN_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(VAR_TO_EQUATIONS_COLUMN_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(VAR_TO_EQUATIONS_COLUMN_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%COLUMN_DOF(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COLUMN_DOF)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COLUMN_DOF),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLUMN_DOF(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COLUMN_DOF, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COLUMN_DOF,1), MIN(LBOUND(Variable%COLUMN_DOF,1)+MaxArrayLength, UBOUND(Variable%COLUMN_DOF,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COLUMN_DOF(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLUMN_DOF(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_VAR_TO_EQUATIONS_COLUMN_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DISTRIBUTED_VECTOR_TRANSFER_TYPE(Variable, CheckVariable0, CheckVariable1, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(DISTRIBUTED_VECTOR_TRANSFER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER, INTENT(IN) :: CheckVariable1

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr0

  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: Ptr0

  TYPE(DISTRIBUTED_VECTOR_TRANSFER_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)

  
  ! Variable%CMISS_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CMISS_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: " // &
      & "CMISS_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_CMISS_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_CMISS_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_TYPE, 
! The type to handle in this routine is: DISTRIBUTED_VECTOR_TRANSFER_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_VECTOR_TYPE (CheckVariable0), DISTRIBUTED_VECTOR_CMISS_TYPE (CheckVariable1), 
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_TYPE
!   matches available passing type, use it as CheckVariable0

    ! if variable was already followed
    Ptr0 => Variable%CMISS_VECTOR
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CMISS_VECTOR"
      CALL Print_DISTRIBUTED_VECTOR_CMISS_TYPE(Variable% &
        & CMISS_VECTOR, CheckVariable1, NullPtr0, CheckVariable0, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: " // &
      & "CMISS_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DATA_TYPE:                       ", &
    & Variable%DATA_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SEND_BUFFER_SIZE:                ", &
    & Variable%SEND_BUFFER_SIZE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "RECEIVE_BUFFER_SIZE:             ", &
    & Variable%RECEIVE_BUFFER_SIZE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SEND_TAG_NUMBER:                 ", &
    & Variable%SEND_TAG_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "RECEIVE_TAG_NUMBER:              ", &
    & Variable%RECEIVE_TAG_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MPI_SEND_REQUEST:                ", &
    & Variable%MPI_SEND_REQUEST
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MPI_RECEIVE_REQUEST:             ", &
    & Variable%MPI_RECEIVE_REQUEST
  
  ! Variable%SEND_BUFFER_INTG(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SEND_BUFFER_INTG)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SEND_BUFFER_INTG),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "SEND_BUFFER_INTG(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SEND_BUFFER_INTG, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SEND_BUFFER_INTG,1), MIN(LBOUND(Variable%SEND_BUFFER_INTG,1)+MaxArrayLength, UBOUND(Variable% &
      & SEND_BUFFER_INTG,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SEND_BUFFER_INTG(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "SEND_BUFFER_INTG(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%SEND_BUFFER_DP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SEND_BUFFER_DP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SEND_BUFFER_DP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "SEND_BUFFER_DP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SEND_BUFFER_DP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SEND_BUFFER_DP,1), MIN(LBOUND(Variable%SEND_BUFFER_DP,1)+MaxArrayLength, UBOUND(Variable% &
      & SEND_BUFFER_DP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SEND_BUFFER_DP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "SEND_BUFFER_DP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%SEND_BUFFER_SP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SEND_BUFFER_SP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SEND_BUFFER_SP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(SP), ALLOCATABLE :: " // &
      & "SEND_BUFFER_SP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SEND_BUFFER_SP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(SP), ALLOCATABLE :: " // &
      & "SEND_BUFFER_SP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%SEND_BUFFER_L(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SEND_BUFFER_L)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SEND_BUFFER_L),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "SEND_BUFFER_L(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SEND_BUFFER_L, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SEND_BUFFER_L,1), MIN(LBOUND(Variable%SEND_BUFFER_L,1)+MaxArrayLength, UBOUND(Variable%SEND_BUFFER_L,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SEND_BUFFER_L(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "SEND_BUFFER_L(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%RECEIVE_BUFFER_INTG(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%RECEIVE_BUFFER_INTG)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%RECEIVE_BUFFER_INTG),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "RECEIVE_BUFFER_INTG(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%RECEIVE_BUFFER_INTG, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%RECEIVE_BUFFER_INTG,1), MIN(LBOUND(Variable% &
      & RECEIVE_BUFFER_INTG,1)+MaxArrayLength, UBOUND(Variable%RECEIVE_BUFFER_INTG,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%RECEIVE_BUFFER_INTG(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "RECEIVE_BUFFER_INTG(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%RECEIVE_BUFFER_DP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%RECEIVE_BUFFER_DP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%RECEIVE_BUFFER_DP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "RECEIVE_BUFFER_DP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%RECEIVE_BUFFER_DP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%RECEIVE_BUFFER_DP,1), MIN(LBOUND(Variable%RECEIVE_BUFFER_DP,1)+MaxArrayLength, UBOUND(Variable% &
      & RECEIVE_BUFFER_DP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%RECEIVE_BUFFER_DP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "RECEIVE_BUFFER_DP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%RECEIVE_BUFFER_SP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%RECEIVE_BUFFER_SP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%RECEIVE_BUFFER_SP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(SP), ALLOCATABLE :: " // &
      & "RECEIVE_BUFFER_SP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%RECEIVE_BUFFER_SP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(SP), ALLOCATABLE :: " // &
      & "RECEIVE_BUFFER_SP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%RECEIVE_BUFFER_L(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%RECEIVE_BUFFER_L)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%RECEIVE_BUFFER_L),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "RECEIVE_BUFFER_L(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%RECEIVE_BUFFER_L, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%RECEIVE_BUFFER_L,1), MIN(LBOUND(Variable%RECEIVE_BUFFER_L,1)+MaxArrayLength, UBOUND(Variable% &
      & RECEIVE_BUFFER_L,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%RECEIVE_BUFFER_L(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "RECEIVE_BUFFER_L(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DISTRIBUTED_VECTOR_TRANSFER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_TO_SOLVER_MAPS_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_TO_SOLVER_MAPS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr0
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr1
  TYPE(SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr3
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr4


  TYPE(EQUATIONS_TO_SOLVER_MAPS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "EQUATIONS_MATRIX_TYPE:           ", &
    & Variable%EQUATIONS_MATRIX_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "EQUATIONS_MATRIX_NUMBER:         ", &
    & Variable%EQUATIONS_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRIX_NUMBER:            ", &
    & Variable%SOLVER_MATRIX_NUMBER
  
  ! Variable%EQUATIONS_MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRIX_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRIX " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRIX_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_TO_SOLVER_MAPS_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MATRIX"
      CALL Print_EQUATIONS_MATRIX_TYPE(Variable%EQUATIONS_MATRIX, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRIX_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOLVER_MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MATRIX_TYPE), POINTER :: " // &
      & "SOLVER_MATRIX " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MATRIX_TYPE has the following CheckVariable types: SOLVER_MATRICES_TYPE, SOLVERS_TYPE, SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, 
! The type to handle in this routine is: EQUATIONS_TO_SOLVER_MAPS_TYPE (Variable)
! Available CheckVariables are: 
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MATRIX"
      CALL Print_SOLVER_MATRIX_TYPE(Variable% &
        & SOLVER_MATRIX, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MATRIX_TYPE), POINTER :: " // &
      & "SOLVER_MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%EQUATIONS_COL_TO_SOLVER_COLS_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_COL_TO_SOLVER_COLS_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_COL_TO_SOLVER_COLS_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_COL_TO_SOLVER_COLS_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_COL_TO_SOLVER_COLS_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_COL_TO_SOLVER_COLS_MAP,1), MIN(LBOUND(Variable% &
      & EQUATIONS_COL_TO_SOLVER_COLS_MAP,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_COL_TO_SOLVER_COLS_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_TO_SOLVER_MAPS_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_COL_TO_SOLVER_COLS_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE(Variable% &
          & EQUATIONS_COL_TO_SOLVER_COLS_MAP(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_COL_TO_SOLVER_COLS_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EQUATIONS_TO_SOLVER_MAPS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EXTERNAL_DAE_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, Depth, MaxDepth, MaxArrayLength)
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable19

  ! iterator variables

  ! null pointers
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr0
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr6
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr8
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr10
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(HISTORY_TYPE), POINTER :: NullPtr13
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr14
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr15
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr16

  TYPE(DAE_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)

  
  ! Variable%DAE_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DAE_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_DAE_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: EXTERNAL_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), CELLML_EQUATIONS_TYPE (CheckVariable2), SOLVERS_TYPE (CheckVariable3), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable4), SOLVER_TYPE (CheckVariable5), GeometricTransformationSolverType (CheckVariable6), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable7), EULER_DAE_SOLVER_TYPE (CheckVariable8), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable9), LINEAR_SOLVER_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), BDF_DAE_SOLVER_TYPE (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable18), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable19), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BACKWARD_EULER_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type FORWARD_EULER_DAE_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable6
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type IMPROVED_EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DAE_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DAE_SOLVER"
      CALL Print_DAE_SOLVER_TYPE(Variable% &
        & DAE_SOLVER, CheckVariable16, NullPtr0, CheckVariable18, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, NullPtr4, &
        & NullPtr5, NullPtr6, Variable2, CheckVariable19, CheckVariable12, NullPtr7, NullPtr8, CheckVariable14, &
        & CheckVariable15, NullPtr9, CheckVariable6, CheckVariable17, NullPtr10, CheckVariable2, CheckVariable13, &
        & CheckVariable9, CheckVariable11, NullPtr11, NullPtr12, NullPtr13, CheckVariable0, CheckVariable3, CheckVariable4, &
        & CheckVariable5, NullPtr14, CheckVariable8, CheckVariable10, NullPtr15, NullPtr16, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EXTERNAL_DAE_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_FIELD_MAPS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable15

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_MODEL_TYPE), POINTER :: NullPtr2
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr3
  TYPE(NODES_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr5
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr6
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr9
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr10
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr11
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr12
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr14
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr15
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr16
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr17
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr18
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: NullPtr19
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr20
  TYPE(DOMAIN_LINES_TYPE), POINTER :: NullPtr21
  TYPE(DOMAIN_DOFS_TYPE), POINTER :: NullPtr22
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: NullPtr23
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: NullPtr24
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr25
  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: NullPtr26
  TYPE(DOMAIN_FACES_TYPE), POINTER :: NullPtr27
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: NullPtr28
  TYPE(DecompositionDataPointsType), POINTER :: NullPtr29
  TYPE(DOMAIN_NODES_TYPE), POINTER :: NullPtr30
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: NullPtr31

  TYPE(CELLML_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: Ptr2
  TYPE(DOMAIN_TYPE), POINTER :: Ptr3

  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable6)) THEN
    Variable2 => CheckVariable6
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)
  Nullify(NullPtr29)
  Nullify(NullPtr30)
  Nullify(NullPtr31)

  
  ! Variable%CELLML
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CELLML)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML " // &
      & "(associated): " 
  
! Signature of Print_CELLML_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, CELLML_MODEL_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_FIELD_MAPS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), FIELDS_TYPE (CheckVariable4), DECOMPOSITION_TYPE (CheckVariable5), CELLML_FIELD_MAPS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CELLML_STATE_FIELD_TYPE (CheckVariable9), FIELD_TYPE (CheckVariable10), CELLML_TYPE (CheckVariable11), FIELD_VARIABLE_TYPE (CheckVariable12), CELLML_MODELS_FIELD_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable15), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable11
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CELLML_FIELD_MAPS_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_MODEL_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_MODEL_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr0 => Variable%CELLML
    IF (ASSOCIATED(Ptr0, CheckVariable11)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML"
      CALL Print_CELLML_TYPE(Variable% &
        & CELLML, NullPtr0, CheckVariable10, NullPtr1, CheckVariable13, CheckVariable15, CheckVariable7, CheckVariable3, &
        & CheckVariable8, CheckVariable9, CheckVariable11, CheckVariable2, CheckVariable4, Variable2, NullPtr2, NullPtr3, &
        & NullPtr4, NullPtr5, NullPtr6, CheckVariable0, CheckVariable1, CheckVariable5, CheckVariable12, CheckVariable14, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "CELLML_FIELD_MAPS_FINISHED:                      ", &
    & Variable%CELLML_FIELD_MAPS_FINISHED
  
  ! Variable%SOURCE_GEOMETRIC_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOURCE_GEOMETRIC_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "SOURCE_GEOMETRIC_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_FIELD_MAPS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), FIELDS_TYPE (CheckVariable4), DECOMPOSITION_TYPE (CheckVariable5), CELLML_FIELD_MAPS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CELLML_STATE_FIELD_TYPE (CheckVariable9), FIELD_TYPE (CheckVariable10), CELLML_TYPE (CheckVariable11), FIELD_VARIABLE_TYPE (CheckVariable12), CELLML_MODELS_FIELD_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable15), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable10
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr1 => Variable%SOURCE_GEOMETRIC_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable10)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOURCE_GEOMETRIC_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & SOURCE_GEOMETRIC_FIELD, NullPtr0, NullPtr7, NullPtr8, NullPtr9, CheckVariable10, NullPtr1, NullPtr10, NullPtr11, &
        & CheckVariable7, NullPtr12, CheckVariable8, NullPtr13, CheckVariable11, NullPtr14, CheckVariable2, CheckVariable4, &
        & NullPtr3, NullPtr15, NullPtr4, NullPtr16, NullPtr5, NullPtr6, CheckVariable0, NullPtr17, CheckVariable5, &
        & NullPtr18, CheckVariable12, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "SOURCE_GEOMETRIC_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOURCE_FIELD_VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOURCE_FIELD_VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "SOURCE_FIELD_VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: CELLML_FIELD_MAPS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), FIELDS_TYPE (CheckVariable4), DECOMPOSITION_TYPE (CheckVariable5), CELLML_FIELD_MAPS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CELLML_STATE_FIELD_TYPE (CheckVariable9), FIELD_TYPE (CheckVariable10), CELLML_TYPE (CheckVariable11), FIELD_VARIABLE_TYPE (CheckVariable12), CELLML_MODELS_FIELD_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable15), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE

    ! if variable was already followed
    Ptr2 => Variable%SOURCE_FIELD_VARIABLE
    IF (ASSOCIATED(Ptr2, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOURCE_FIELD_VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & SOURCE_FIELD_VARIABLE, CheckVariable0, NullPtr17, NullPtr0, CheckVariable4, CheckVariable5, NullPtr1, NullPtr9, &
        & NullPtr3, CheckVariable11, CheckVariable12, CheckVariable10, NullPtr5, CheckVariable7, CheckVariable8, NullPtr4, &
        & NullPtr11, CheckVariable14, NullPtr6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "SOURCE_FIELD_VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOURCE_FIELD_DOMAIN
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOURCE_FIELD_DOMAIN)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "SOURCE_FIELD_DOMAIN " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_TYPE has the following CheckVariable types: DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, DOMAIN_LINES_TYPE, FIELD_TYPE, DOMAIN_DOFS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_FACES_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_ELEMENTS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_FACES_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DOMAIN_NODES_TYPE, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_FIELD_MAPS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), FIELDS_TYPE (CheckVariable4), DECOMPOSITION_TYPE (CheckVariable5), CELLML_FIELD_MAPS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CELLML_STATE_FIELD_TYPE (CheckVariable9), FIELD_TYPE (CheckVariable10), CELLML_TYPE (CheckVariable11), FIELD_VARIABLE_TYPE (CheckVariable12), CELLML_MODELS_FIELD_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable15), 
! - signature type DOMAIN_MAPPINGS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_MAPPINGS_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type DOMAIN_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_LINES_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_DOFS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_DOFS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DOMAIN_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable3
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DECOMPOSITION_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_FACES_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_ELEMENTS_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type DOMAIN_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_ELEMENTS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type DOMAIN_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_FACES_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TOPOLOGY_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DecompositionDataPointsType
!   is not available in passing variables, use NullPtr of type DecompositionDataPointsType
! - signature type DOMAIN_NODES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_NODES_TYPE
! - signature type DECOMPOSITION_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_LINES_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr3 => Variable%SOURCE_FIELD_DOMAIN
    IF (ASSOCIATED(Ptr3, CheckVariable3)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOURCE_FIELD_DOMAIN"
      CALL Print_DOMAIN_TYPE(Variable% &
        & SOURCE_FIELD_DOMAIN, NullPtr19, NullPtr20, NullPtr9, NullPtr21, CheckVariable10, NullPtr22, CheckVariable7, &
        & CheckVariable3, CheckVariable4, NullPtr23, CheckVariable8, CheckVariable11, NullPtr24, CheckVariable2, NullPtr25, &
        & NullPtr26, NullPtr15, NullPtr16, NullPtr27, CheckVariable0, NullPtr28, CheckVariable5, NullPtr29, NullPtr30, &
        & NullPtr31, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "SOURCE_FIELD_DOMAIN (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOURCE_FIELD_INTERPOLATION_TYPE: ", &
    & Variable%SOURCE_FIELD_INTERPOLATION_TYPE
  
  ! Variable%MODEL_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MODEL_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MODEL_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_MODEL_MAPS_PTR_TYPE), ALLOCATABLE :: " // &
      & "MODEL_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MODEL_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%MODEL_MAPS,1), MIN(LBOUND(Variable%MODEL_MAPS,1)+MaxArrayLength, UBOUND(Variable%MODEL_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_CELLML_MODEL_MAPS_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: CELLML_FIELD_MAPS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), FIELDS_TYPE (CheckVariable4), DECOMPOSITION_TYPE (CheckVariable5), CELLML_FIELD_MAPS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CELLML_STATE_FIELD_TYPE (CheckVariable9), FIELD_TYPE (CheckVariable10), CELLML_TYPE (CheckVariable11), FIELD_VARIABLE_TYPE (CheckVariable12), CELLML_MODELS_FIELD_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable15), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MODEL_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_CELLML_MODEL_MAPS_PTR_TYPE(Variable%MODEL_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_MODEL_MAPS_PTR_TYPE), ALLOCATABLE :: " // &
      & "MODEL_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_CELLML_FIELD_MAPS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_ELEMENT_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_ELEMENT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers
  TYPE(BASIS_TYPE), POINTER :: NullPtr0
  TYPE(BASIS_PTR_TYPE), POINTER :: NullPtr1


  TYPE(DOMAIN_ELEMENT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER:                          ", &
    & Variable%NUMBER
  
  ! Variable%BASIS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%BASIS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_TYPE), POINTER :: " // &
      & "BASIS " // &
      & "(associated): " 
  
! Signature of Print_BASIS_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: DOMAIN_ELEMENT_TYPE (Variable)
! Available CheckVariables are: 
! - signature type BASIS_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_TYPE
! - signature type BASIS_PTR_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_PTR_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BASIS"
      CALL Print_BASIS_TYPE(Variable%BASIS, NullPtr0, NullPtr1, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_TYPE), POINTER :: " // &
      & "BASIS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%ELEMENT_NODES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_NODES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_NODES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_NODES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_NODES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENT_NODES,1), MIN(LBOUND(Variable%ELEMENT_NODES,1)+MaxArrayLength, UBOUND(Variable%ELEMENT_NODES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ELEMENT_NODES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_NODES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ELEMENT_DERIVATIVES(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_DERIVATIVES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_DERIVATIVES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_DERIVATIVES(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_DERIVATIVES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENT_DERIVATIVES,1), MIN(LBOUND(Variable% &
      & ELEMENT_DERIVATIVES,1)+MaxArrayLength, UBOUND(Variable%ELEMENT_DERIVATIVES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%ELEMENT_DERIVATIVES,2), MIN(LBOUND(Variable% &
        & ELEMENT_DERIVATIVES,2)+MaxArrayLength, UBOUND(Variable%ELEMENT_DERIVATIVES,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%ELEMENT_DERIVATIVES(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_DERIVATIVES(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%elementVersions(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%elementVersions)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%elementVersions),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "elementVersions(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%elementVersions, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%elementVersions,1), MIN(LBOUND(Variable%elementVersions,1)+MaxArrayLength, UBOUND(Variable% &
      & elementVersions,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%elementVersions,2), MIN(LBOUND(Variable%elementVersions,2)+MaxArrayLength, UBOUND(Variable% &
        & elementVersions,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%elementVersions(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "elementVersions(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DOMAIN_ELEMENT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_QUADRATURE_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(QUADRATURE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BASIS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(QUADRATURE_SCHEME_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(QUADRATURE_SCHEME_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(BASIS_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers

  TYPE(BASIS_TYPE), POINTER :: Ptr0
  TYPE(QUADRATURE_SCHEME_PTR_TYPE), POINTER :: Ptr1

  TYPE(QUADRATURE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TYPE:                            ", &
    & Variable%TYPE
  
  ! Variable%BASIS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%BASIS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_TYPE), POINTER :: " // &
      & "BASIS " // &
      & "(associated): " 
  
! Signature of Print_BASIS_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: QUADRATURE_TYPE (Variable)
! Available CheckVariables are: BASIS_TYPE (CheckVariable0), QUADRATURE_SCHEME_PTR_TYPE (CheckVariable1), QUADRATURE_SCHEME_TYPE (CheckVariable2), BASIS_PTR_TYPE (CheckVariable3), 
! - signature type BASIS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type BASIS_PTR_TYPE
!   matches available passing type, use it as CheckVariable3

    ! if variable was already followed
    Ptr0 => Variable%BASIS
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BASIS"
      CALL Print_BASIS_TYPE(Variable%BASIS, CheckVariable0, CheckVariable3, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_TYPE), POINTER :: " // &
      & "BASIS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%NUMBER_OF_GAUSS_XI(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_GAUSS_XI)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_GAUSS_XI),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_GAUSS_XI(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_GAUSS_XI, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_GAUSS_XI,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_GAUSS_XI,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_GAUSS_XI,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_GAUSS_XI(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_GAUSS_XI(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GAUSS_ORDER:                     ", &
    & Variable%GAUSS_ORDER
  
  ! Variable%QUADRATURE_SCHEME_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%QUADRATURE_SCHEME_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%QUADRATURE_SCHEME_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(QUADRATURE_SCHEME_PTR_TYPE), ALLOCATABLE :: " // &
      & "QUADRATURE_SCHEME_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%QUADRATURE_SCHEME_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%QUADRATURE_SCHEME_MAP,1), MIN(LBOUND(Variable% &
      & QUADRATURE_SCHEME_MAP,1)+MaxArrayLength, UBOUND(Variable%QUADRATURE_SCHEME_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_QUADRATURE_SCHEME_PTR_TYPE has the following CheckVariable types: BASIS_TYPE, QUADRATURE_SCHEME_TYPE, 
! The type to handle in this routine is: QUADRATURE_TYPE (Variable)
! Available CheckVariables are: BASIS_TYPE (CheckVariable0), QUADRATURE_SCHEME_PTR_TYPE (CheckVariable1), QUADRATURE_SCHEME_TYPE (CheckVariable2), BASIS_PTR_TYPE (CheckVariable3), 
! - signature type BASIS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type QUADRATURE_SCHEME_TYPE
!   matches available passing type, use it as CheckVariable2

      ! if variable was already followed
      Ptr1 => Variable%QUADRATURE_SCHEME_MAP(I0)
      IF (ASSOCIATED(Ptr1, CheckVariable1)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"QUADRATURE_SCHEME_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_QUADRATURE_SCHEME_PTR_TYPE(Variable% &
          & QUADRATURE_SCHEME_MAP(I0), CheckVariable0, CheckVariable2, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(QUADRATURE_SCHEME_PTR_TYPE), ALLOCATABLE :: " // &
      & "QUADRATURE_SCHEME_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SCHEMES:               ", &
    & Variable%NUMBER_OF_SCHEMES
  
  ! Variable%SCHEMES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%SCHEMES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(QUADRATURE_SCHEME_PTR_TYPE), POINTER :: " // &
      & "SCHEMES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%SCHEMES,1), "): "
  
    DO I0 = LBOUND(Variable%SCHEMES,1), MIN(LBOUND(Variable%SCHEMES,1)+MaxArrayLength, UBOUND(Variable%SCHEMES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_QUADRATURE_SCHEME_PTR_TYPE has the following CheckVariable types: BASIS_TYPE, QUADRATURE_SCHEME_TYPE, 
! The type to handle in this routine is: QUADRATURE_TYPE (Variable)
! Available CheckVariables are: BASIS_TYPE (CheckVariable0), QUADRATURE_SCHEME_PTR_TYPE (CheckVariable1), QUADRATURE_SCHEME_TYPE (CheckVariable2), BASIS_PTR_TYPE (CheckVariable3), 
! - signature type BASIS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type QUADRATURE_SCHEME_TYPE
!   matches available passing type, use it as CheckVariable2

      ! if variable was already followed
      Ptr1 => Variable%SCHEMES(I0)
      IF (ASSOCIATED(Ptr1, CheckVariable1)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SCHEMES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_QUADRATURE_SCHEME_PTR_TYPE(Variable% &
          & SCHEMES(I0), CheckVariable0, CheckVariable2, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(QUADRATURE_SCHEME_PTR_TYPE), POINTER :: " // &
      & "SCHEMES(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "EVALUATE_FACE_GAUSS:                             ", &
    & Variable%EVALUATE_FACE_GAUSS

  
END SUBROUTINE Print_QUADRATURE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "EQUATIONS_MATRIX_NUMBER:         ", &
    & Variable%EQUATIONS_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SOLVER_MATRICES:       ", &
    & Variable%NUMBER_OF_SOLVER_MATRICES
  
  ! Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_TO_SOLVER_MATRIX_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS,1), MIN(LBOUND(Variable% &
      & EQUATIONS_TO_SOLVER_MATRIX_MAPS,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_TO_SOLVER_MATRIX_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE(Variable% &
          & EQUATIONS_TO_SOLVER_MATRIX_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_TO_SOLVER_MATRIX_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_PHYSICAL_POINT_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%FIELD_INTERPOLATED_POINT
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELD_INTERPOLATED_POINT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: " // &
      & "FIELD_INTERPOLATED_POINT " // &
      & "(associated): " 
  
! Signature of Print_FIELD_INTERPOLATED_POINT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_PHYSICAL_POINT_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELD_INTERPOLATED_POINT"
      CALL Print_FIELD_INTERPOLATED_POINT_TYPE(Variable%FIELD_INTERPOLATED_POINT, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: " // &
      & "FIELD_INTERPOLATED_POINT (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%GEOMETRIC_INTERPOLATED_POINT
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GEOMETRIC_INTERPOLATED_POINT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: " // &
      & "GEOMETRIC_INTERPOLATED_POINT " // &
      & "(associated): " 
  
! Signature of Print_FIELD_INTERPOLATED_POINT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_PHYSICAL_POINT_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GEOMETRIC_INTERPOLATED_POINT"
      CALL Print_FIELD_INTERPOLATED_POINT_TYPE(Variable%GEOMETRIC_INTERPOLATED_POINT, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: " // &
      & "GEOMETRIC_INTERPOLATED_POINT (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%PHYSICAL_DERIVATIVE_TYPE == 2) THEN
    Comment = "MAXIMUM_PHYSICAL_DERIV_NUMBER " // & 
      & "!The maximum physical derivative number"
  ENDIF
  IF (Variable%PHYSICAL_DERIVATIVE_TYPE == 1) THEN
    Comment = "NO_PHYSICAL_DERIV " // & 
      & "!No physical derivative i.e., u"
  ENDIF
  IF (Variable%PHYSICAL_DERIVATIVE_TYPE == 2) THEN
    Comment = "GRADIENT_PHYSICAL_DERIV " // & 
      & "!Gradient physical derivative i.e., grad u"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "PHYSICAL_DERIVATIVE_TYPE:        ", &
    & Variable%PHYSICAL_DERIVATIVE_TYPE, " ", TRIM(Comment)
  
  ! Variable%VALUES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VALUES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VALUES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "VALUES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VALUES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%VALUES,1), MIN(LBOUND(Variable%VALUES,1)+MaxArrayLength, UBOUND(Variable%VALUES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%VALUES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "VALUES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_PHYSICAL_POINT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_VARIABLE_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_VARIABLE_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable8

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr1
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr2
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr5
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr6
  TYPE(NODES_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr8

  TYPE(FIELD_VARIABLE_TYPE), POINTER :: Ptr0

  TYPE(FIELD_VARIABLE_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: FIELD_VARIABLE_PTR_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_VARIABLE_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), DATA_POINTS_TYPE (CheckVariable8), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable8

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & PTR, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, NullPtr1, NullPtr2, CheckVariable3, NullPtr3, &
        & NullPtr4, CheckVariable4, CheckVariable5, NullPtr5, CheckVariable6, NullPtr6, NullPtr7, NullPtr8, CheckVariable7, &
        & CheckVariable8, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELD_VARIABLE_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE_TYPE(Variable, CheckVariable0, CheckVariable1, &
  & CheckVariable2, CheckVariable3, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable3

  ! iterator variables

  ! null pointers
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr0
  TYPE(MESHES_TYPE), POINTER :: NullPtr1
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr2
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_TYPE), POINTER :: NullPtr4
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr5
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr7
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr8
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr9
  TYPE(MESH_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: NullPtr11
  TYPE(FIELDS_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: NullPtr13
  TYPE(NODES_TYPE), POINTER :: NullPtr14
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr15
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr16
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr17
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr18
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr19
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: NullPtr20
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr21
  TYPE(INTERFACE_PENALTY_TYPE), POINTER :: NullPtr22
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr23
  TYPE(REGION_TYPE), POINTER :: NullPtr24


  TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INTERFACE_CONDITION_INDEX:       ", &
    & Variable%INTERFACE_CONDITION_INDEX
  
  ! Variable%INTERFACE_CONDITION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_CONDITION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITION " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_CONDITION_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, SOLVER_EQUATIONS_TYPE, INTERFACE_LAGRANGE_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, INTERFACE_PENALTY_TYPE, GENERATED_MESHES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE_TYPE (Variable)
! Available CheckVariables are: SOLVER_TYPE (CheckVariable0), SOLVER_EQUATIONS_TYPE (CheckVariable1), BOUNDARY_CONDITIONS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_LAGRANGE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_LAGRANGE_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type INTERFACE_DEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_DEPENDENT_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type INTERFACE_PENALTY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PENALTY_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_CONDITION"
      CALL Print_INTERFACE_CONDITION_TYPE(Variable% &
        & INTERFACE_CONDITION, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, &
        & NullPtr9, NullPtr10, CheckVariable2, NullPtr11, NullPtr12, CheckVariable1, NullPtr13, NullPtr14, NullPtr15, &
        & NullPtr16, NullPtr17, NullPtr18, NullPtr19, CheckVariable0, NullPtr20, CheckVariable3, NullPtr21, NullPtr22, &
        & NullPtr23, NullPtr24, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INTERFACE_MATRIX_NUMBER:         ", &
    & Variable%INTERFACE_MATRIX_NUMBER

  
END SUBROUTINE Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_RUNGE_KUTTA_DAE_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, Depth, MaxDepth, MaxArrayLength)
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable19

  ! iterator variables

  ! null pointers
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr0
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr6
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr8
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr10
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(HISTORY_TYPE), POINTER :: NullPtr13
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr14
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr15
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr16

  TYPE(DAE_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable19)) THEN
    Variable2 => CheckVariable19
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)

  
  ! Variable%DAE_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DAE_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_DAE_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: RUNGE_KUTTA_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), CELLML_EQUATIONS_TYPE (CheckVariable2), SOLVERS_TYPE (CheckVariable3), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable4), SOLVER_TYPE (CheckVariable5), GeometricTransformationSolverType (CheckVariable6), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable7), EULER_DAE_SOLVER_TYPE (CheckVariable8), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable9), LINEAR_SOLVER_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), BDF_DAE_SOLVER_TYPE (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable18), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable19), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BACKWARD_EULER_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type FORWARD_EULER_DAE_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable6
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type IMPROVED_EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DAE_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DAE_SOLVER"
      CALL Print_DAE_SOLVER_TYPE(Variable% &
        & DAE_SOLVER, CheckVariable16, NullPtr0, CheckVariable18, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, NullPtr4, &
        & NullPtr5, NullPtr6, CheckVariable7, Variable2, CheckVariable12, NullPtr7, NullPtr8, CheckVariable14, &
        & CheckVariable15, NullPtr9, CheckVariable6, CheckVariable17, NullPtr10, CheckVariable2, CheckVariable13, &
        & CheckVariable9, CheckVariable11, NullPtr11, NullPtr12, NullPtr13, CheckVariable0, CheckVariable3, CheckVariable4, &
        & CheckVariable5, NullPtr14, CheckVariable8, CheckVariable10, NullPtr15, NullPtr16, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)

  
END SUBROUTINE Print_RUNGE_KUTTA_DAE_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_FACE_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_FACE_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(DOMAIN_FACE_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_FACE_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_FACE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DOMAIN_FACE_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_DOMAIN_FACE_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_FACE_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DOMAIN_FACE_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_ELEMENTS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable4

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_LINES_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_TYPE), POINTER :: NullPtr3
  TYPE(DOMAIN_DOFS_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr5
  TYPE(FIELDS_TYPE), POINTER :: NullPtr6
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr8
  TYPE(CELLML_TYPE), POINTER :: NullPtr9
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: NullPtr10
  TYPE(MESH_TYPE), POINTER :: NullPtr11
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr12
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr13
  TYPE(DOMAIN_FACES_TYPE), POINTER :: NullPtr14
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr15
  TYPE(DecompositionDataPointsType), POINTER :: NullPtr16
  TYPE(DOMAIN_NODES_TYPE), POINTER :: NullPtr17
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: NullPtr18
  TYPE(REGION_TYPE), POINTER :: NullPtr19

  TYPE(DOMAIN_TYPE), POINTER :: Ptr0

  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)

  
  ! Variable%DOMAIN
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DOMAIN)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_TYPE has the following CheckVariable types: DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, DOMAIN_LINES_TYPE, FIELD_TYPE, DOMAIN_DOFS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_FACES_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_ELEMENTS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_FACES_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DOMAIN_NODES_TYPE, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DOMAIN_ELEMENTS_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TOPOLOGY_TYPE (CheckVariable0), DECOMPOSITION_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DOMAIN_PTR_TYPE (CheckVariable3), DOMAIN_TYPE (CheckVariable4), 
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type DOMAIN_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_LINES_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type DOMAIN_DOFS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_DOFS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_FACES_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_ELEMENTS_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type DOMAIN_ELEMENTS_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DOMAIN_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_FACES_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DecompositionDataPointsType
!   is not available in passing variables, use NullPtr of type DecompositionDataPointsType
! - signature type DOMAIN_NODES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_NODES_TYPE
! - signature type DECOMPOSITION_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_LINES_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DOMAIN
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOMAIN"
      CALL Print_DOMAIN_TYPE(Variable% &
        & DOMAIN, CheckVariable2, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, CheckVariable4, NullPtr6, &
        & NullPtr7, NullPtr8, NullPtr9, NullPtr10, NullPtr11, NullPtr12, Variable2, NullPtr13, CheckVariable3, NullPtr14, &
        & NullPtr15, CheckVariable0, CheckVariable1, NullPtr16, NullPtr17, NullPtr18, NullPtr19, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ELEMENTS:              ", &
    & Variable%NUMBER_OF_ELEMENTS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_ELEMENTS:        ", &
    & Variable%TOTAL_NUMBER_OF_ELEMENTS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_ELEMENTS:       ", &
    & Variable%NUMBER_OF_GLOBAL_ELEMENTS
  
  ! Variable%ELEMENTS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%ELEMENTS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_ELEMENT_TYPE), POINTER :: " // &
      & "ELEMENTS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%ELEMENTS,1), "): "
  
    DO I0 = LBOUND(Variable%ELEMENTS,1), MIN(LBOUND(Variable%ELEMENTS,1)+MaxArrayLength, UBOUND(Variable%ELEMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DOMAIN_ELEMENT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DOMAIN_ELEMENTS_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TOPOLOGY_TYPE (CheckVariable0), DECOMPOSITION_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DOMAIN_PTR_TYPE (CheckVariable3), DOMAIN_TYPE (CheckVariable4), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ELEMENTS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DOMAIN_ELEMENT_TYPE(Variable%ELEMENTS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_ELEMENT_TYPE), POINTER :: " // &
      & "ELEMENTS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_ELEMENT_PARAMETERS: ", &
    & Variable%MAXIMUM_NUMBER_OF_ELEMENT_PARAMETERS

  
END SUBROUTINE Print_DOMAIN_ELEMENTS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BoundaryConditionsCoupledDofsPtrType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(BoundaryConditionsCoupledDofsPtrType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(BoundaryConditionsCoupledDofsPtrType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%ptr
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ptr)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BoundaryConditionsCoupledDofsType), POINTER :: " // &
      & "ptr " // &
      & "(associated): " 
  
! Signature of Print_BoundaryConditionsCoupledDofsType has the following CheckVariable types: 
! The type to handle in this routine is: BoundaryConditionsCoupledDofsPtrType (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ptr"
      CALL Print_BoundaryConditionsCoupledDofsType(Variable%ptr, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BoundaryConditionsCoupledDofsType), POINTER :: " // &
      & "ptr (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_BoundaryConditionsCoupledDofsPtrType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_GENERATED_MESH_ELLIPSOID_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, Depth, MaxDepth, MaxArrayLength)
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable17

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MeshComponentTopologyType), POINTER :: NullPtr0
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr2
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr4
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr5
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr6
  TYPE(NODES_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(BASIS_TYPE), POINTER :: NullPtr10
  TYPE(BASIS_PTR_TYPE), POINTER :: NullPtr11

  TYPE(GENERATED_MESH_TYPE), POINTER :: Ptr0

  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable8)) THEN
    Variable2 => CheckVariable8
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)

  
  ! Variable%GENERATED_MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GENERATED_MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GENERATED_MESH_TYPE), POINTER :: " // &
      & "GENERATED_MESH " // &
      & "(associated): " 
  
! Signature of Print_GENERATED_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, DECOMPOSITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_ELLIPSOID_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), GENERATED_MESH_REGULAR_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), MESHES_TYPE (CheckVariable3), GENERATED_MESH_CYLINDER_TYPE (CheckVariable4), MESH_PTR_TYPE (CheckVariable5), FIELDS_TYPE (CheckVariable6), DECOMPOSITION_TYPE (CheckVariable7), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable8), REGION_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), GENERATED_MESH_TYPE (CheckVariable11), GENERATED_MESHES_TYPE (CheckVariable12), FIELD_TYPE (CheckVariable13), DECOMPOSITIONS_TYPE (CheckVariable14), InterfacePointsConnectivityType (CheckVariable15), INTERFACE_TYPE (CheckVariable16), GENERATED_MESH_PTR_TYPE (CheckVariable17), 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable11
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type GENERATED_MESH_REGULAR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable9

    ! if variable was already followed
    Ptr0 => Variable%GENERATED_MESH
    IF (ASSOCIATED(Ptr0, CheckVariable11)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GENERATED_MESH"
      CALL Print_GENERATED_MESH_TYPE(Variable% &
        & GENERATED_MESH, NullPtr0, CheckVariable3, CheckVariable4, CheckVariable5, NullPtr1, Variable2, NullPtr2, &
        & CheckVariable11, CheckVariable13, NullPtr3, CheckVariable15, CheckVariable16, CheckVariable10, NullPtr4, &
        & NullPtr5, CheckVariable2, NullPtr6, CheckVariable6, CheckVariable12, CheckVariable14, NullPtr7, NullPtr8, &
        & NullPtr9, CheckVariable17, CheckVariable0, CheckVariable1, CheckVariable7, CheckVariable9, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GENERATED_MESH_TYPE), POINTER :: " // &
      & "GENERATED_MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%ORIGIN(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ORIGIN)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ORIGIN),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "ORIGIN(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ORIGIN, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ORIGIN,1), MIN(LBOUND(Variable%ORIGIN,1)+MaxArrayLength, UBOUND(Variable%ORIGIN,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ORIGIN(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "ORIGIN(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ELLIPSOID_EXTENT(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELLIPSOID_EXTENT)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELLIPSOID_EXTENT),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "ELLIPSOID_EXTENT(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELLIPSOID_EXTENT, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELLIPSOID_EXTENT,1), MIN(LBOUND(Variable%ELLIPSOID_EXTENT,1)+MaxArrayLength, UBOUND(Variable% &
      & ELLIPSOID_EXTENT,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ELLIPSOID_EXTENT(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "ELLIPSOID_EXTENT(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MESH_DIMENSION:                  ", &
    & Variable%MESH_DIMENSION
  
  ! Variable%NUMBER_OF_ELEMENTS_XI(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_ELEMENTS_XI)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_ELEMENTS_XI),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_ELEMENTS_XI(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_ELEMENTS_XI, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_ELEMENTS_XI,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_ELEMENTS_XI,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_ELEMENTS_XI,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_ELEMENTS_XI(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_ELEMENTS_XI(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%BASES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%BASES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%BASES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_PTR_TYPE), ALLOCATABLE :: " // &
      & "BASES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%BASES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%BASES,1), MIN(LBOUND(Variable%BASES,1)+MaxArrayLength, UBOUND(Variable%BASES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_BASIS_PTR_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_ELLIPSOID_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), GENERATED_MESH_REGULAR_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), MESHES_TYPE (CheckVariable3), GENERATED_MESH_CYLINDER_TYPE (CheckVariable4), MESH_PTR_TYPE (CheckVariable5), FIELDS_TYPE (CheckVariable6), DECOMPOSITION_TYPE (CheckVariable7), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable8), REGION_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), GENERATED_MESH_TYPE (CheckVariable11), GENERATED_MESHES_TYPE (CheckVariable12), FIELD_TYPE (CheckVariable13), DECOMPOSITIONS_TYPE (CheckVariable14), InterfacePointsConnectivityType (CheckVariable15), INTERFACE_TYPE (CheckVariable16), GENERATED_MESH_PTR_TYPE (CheckVariable17), 
! - signature type BASIS_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_TYPE
! - signature type BASIS_PTR_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_PTR_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BASES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_BASIS_PTR_TYPE(Variable%BASES(I0), NullPtr10, NullPtr11, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_PTR_TYPE), ALLOCATABLE :: " // &
      & "BASES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "APPEND_LINEAR_COMPONENT:                         ", &
    & Variable%APPEND_LINEAR_COMPONENT

  
END SUBROUTINE Print_GENERATED_MESH_ELLIPSOID_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_GEOMETRY_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_GEOMETRY_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(INTERFACE_PENALTY_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable13

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr2
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr3
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr4
  TYPE(MESH_TYPE), POINTER :: NullPtr5
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr6
  TYPE(NODES_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr12
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr13
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr16
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr18
  TYPE(CELLML_TYPE), POINTER :: NullPtr19
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr20
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr21
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr22
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr23
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr24

  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(INTERFACE_GEOMETRY_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  
  ! Variable%INTERFACE_CONDITION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_CONDITION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITION " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_CONDITION_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, SOLVER_EQUATIONS_TYPE, INTERFACE_LAGRANGE_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, INTERFACE_PENALTY_TYPE, GENERATED_MESHES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_GEOMETRY_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), INTERFACE_CONDITION_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), FIELDS_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), INTERFACE_DEPENDENT_TYPE (CheckVariable5), REGION_TYPE (CheckVariable6), INTERFACE_PENALTY_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITION_TYPE (CheckVariable10), INTERFACE_LAGRANGE_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), INTERFACE_TYPE (CheckVariable13), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_LAGRANGE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type INTERFACE_DEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type INTERFACE_PENALTY_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable6

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_CONDITION
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_CONDITION"
      CALL Print_INTERFACE_CONDITION_TYPE(Variable% &
        & INTERFACE_CONDITION, CheckVariable1, NullPtr0, NullPtr1, CheckVariable4, CheckVariable9, NullPtr2, &
        & CheckVariable13, NullPtr3, NullPtr4, CheckVariable12, NullPtr5, NullPtr6, CheckVariable2, CheckVariable3, &
        & CheckVariable8, CheckVariable11, NullPtr7, NullPtr8, NullPtr9, CheckVariable0, NullPtr10, CheckVariable10, &
        & NullPtr11, CheckVariable5, NullPtr12, NullPtr13, CheckVariable7, NullPtr14, CheckVariable6, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_CONDITION_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%GEOMETRIC_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GEOMETRIC_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "GEOMETRIC_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_GEOMETRY_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), INTERFACE_CONDITION_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), FIELDS_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), INTERFACE_DEPENDENT_TYPE (CheckVariable5), REGION_TYPE (CheckVariable6), INTERFACE_PENALTY_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITION_TYPE (CheckVariable10), INTERFACE_LAGRANGE_TYPE (CheckVariable11), INTERFACE_CONDITION_PTR_TYPE (CheckVariable12), INTERFACE_TYPE (CheckVariable13), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable6

    ! if variable was already followed
    Ptr1 => Variable%GEOMETRIC_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GEOMETRIC_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & GEOMETRIC_FIELD, NullPtr0, NullPtr1, CheckVariable4, NullPtr15, CheckVariable9, NullPtr16, NullPtr2, NullPtr17, &
        & CheckVariable13, NullPtr3, NullPtr18, NullPtr4, NullPtr19, CheckVariable12, NullPtr5, CheckVariable3, NullPtr14, &
        & NullPtr20, NullPtr7, NullPtr21, NullPtr8, NullPtr9, CheckVariable0, NullPtr22, CheckVariable10, NullPtr23, &
        & NullPtr24, CheckVariable6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "GEOMETRIC_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_GEOMETRY_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_VAR_TO_EQUATIONS_JACOBIAN_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(VAR_TO_EQUATIONS_JACOBIAN_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr1
  TYPE(MESHES_TYPE), POINTER :: NullPtr2
  TYPE(FIELDS_TYPE), POINTER :: NullPtr3
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr4
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr6
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr11
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr12
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr13
  TYPE(NODES_TYPE), POINTER :: NullPtr14
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr15
  TYPE(REGION_TYPE), POINTER :: NullPtr16
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr17


  TYPE(VAR_TO_EQUATIONS_JACOBIAN_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "JACOBIAN_NUMBER:                 ", &
    & Variable%JACOBIAN_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "VARIABLE_TYPE:                   ", &
    & Variable%VARIABLE_TYPE
  
  ! Variable%VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: VAR_TO_EQUATIONS_JACOBIAN_MAP_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & VARIABLE, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DOF_TO_COLUMNS_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOF_TO_COLUMNS_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOF_TO_COLUMNS_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_TO_COLUMNS_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOF_TO_COLUMNS_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DOF_TO_COLUMNS_MAP,1), MIN(LBOUND(Variable% &
      & DOF_TO_COLUMNS_MAP,1)+MaxArrayLength, UBOUND(Variable%DOF_TO_COLUMNS_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DOF_TO_COLUMNS_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_TO_COLUMNS_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DOF_TO_ROWS_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOF_TO_ROWS_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOF_TO_ROWS_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_TO_ROWS_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOF_TO_ROWS_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DOF_TO_ROWS_MAP,1), MIN(LBOUND(Variable%DOF_TO_ROWS_MAP,1)+MaxArrayLength, UBOUND(Variable% &
      & DOF_TO_ROWS_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DOF_TO_ROWS_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_TO_ROWS_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_VAR_TO_EQUATIONS_JACOBIAN_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_CONDITION_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
  & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(INTERFACE_PENALTY_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable28

  ! iterator variables

  ! null pointers
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr0
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr1
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr2
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr4
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr5
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr6
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr7
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr8
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACE_MATRICES_TYPE), POINTER :: NullPtr11
  TYPE(INTERFACE_MAPPING_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: NullPtr13
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr14
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr15
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr16
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr17
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr18
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr19
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr20
  TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER :: NullPtr21
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr22
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr23
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr24

  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: Ptr0
  TYPE(INTERFACE_TYPE), POINTER :: Ptr1
  TYPE(INTERFACE_PENALTY_TYPE), POINTER :: Ptr2
  TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: Ptr3
  TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: Ptr4
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: Ptr5
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: Ptr6

  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable0)) THEN
    Variable2 => CheckVariable0
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "INTERFACE_CONDITION_FINISHED:                    ", &
    & Variable%INTERFACE_CONDITION_FINISHED
  
  ! Variable%INTERFACE_CONDITIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_CONDITIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITIONS " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_CONDITIONS_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), InterfacePointsConnectivityType (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable7), CONTROL_LOOP_TYPE (CheckVariable8), INTERFACE_CONDITION_PTR_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), INTERFACE_EQUATIONS_TYPE (CheckVariable12), FIELDS_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), INTERFACE_LAGRANGE_TYPE (CheckVariable15), NODES_TYPE (CheckVariable16), INTERFACES_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), SOLVER_TYPE (CheckVariable22), INTERFACE_DEPENDENT_TYPE (CheckVariable23), SOLVER_MAPPING_TYPE (CheckVariable24), SOLVER_MATRICES_TYPE (CheckVariable25), INTERFACE_PENALTY_TYPE (CheckVariable26), GENERATED_MESHES_TYPE (CheckVariable27), REGION_TYPE (CheckVariable28), 
! - signature type INTERFACE_CONDITION_TYPE
!   is type of this print routine, use Variable2
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable28

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_CONDITIONS
    IF (ASSOCIATED(Ptr0, CheckVariable3)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_CONDITIONS"
      CALL Print_INTERFACE_CONDITIONS_TYPE(Variable% &
        & INTERFACE_CONDITIONS, Variable2, CheckVariable1, CheckVariable2, CheckVariable3, NullPtr0, NullPtr1, &
        & CheckVariable4, NullPtr2, CheckVariable5, CheckVariable6, NullPtr3, CheckVariable7, NullPtr4, CheckVariable8, &
        & CheckVariable9, CheckVariable10, CheckVariable13, CheckVariable27, NullPtr5, CheckVariable16, CheckVariable17, &
        & CheckVariable18, NullPtr6, CheckVariable19, CheckVariable21, CheckVariable28, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: " // &
      & "INTERFACE_CONDITIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), InterfacePointsConnectivityType (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable7), CONTROL_LOOP_TYPE (CheckVariable8), INTERFACE_CONDITION_PTR_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), INTERFACE_EQUATIONS_TYPE (CheckVariable12), FIELDS_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), INTERFACE_LAGRANGE_TYPE (CheckVariable15), NODES_TYPE (CheckVariable16), INTERFACES_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), SOLVER_TYPE (CheckVariable22), INTERFACE_DEPENDENT_TYPE (CheckVariable23), SOLVER_MAPPING_TYPE (CheckVariable24), SOLVER_MATRICES_TYPE (CheckVariable25), INTERFACE_PENALTY_TYPE (CheckVariable26), GENERATED_MESHES_TYPE (CheckVariable27), REGION_TYPE (CheckVariable28), 
! - signature type INTERFACE_CONDITION_TYPE
!   is type of this print routine, use Variable2
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable5
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable6
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable28

    ! if variable was already followed
    Ptr1 => Variable%INTERFACE
    IF (ASSOCIATED(Ptr1, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE"
      CALL Print_INTERFACE_TYPE(Variable% &
        & INTERFACE, Variable2, CheckVariable1, CheckVariable2, CheckVariable3, NullPtr0, NullPtr1, CheckVariable4, &
        & NullPtr2, CheckVariable5, NullPtr7, CheckVariable6, NullPtr3, CheckVariable7, NullPtr4, CheckVariable8, &
        & CheckVariable9, CheckVariable10, NullPtr8, CheckVariable13, CheckVariable27, NullPtr5, CheckVariable16, &
        & CheckVariable17, CheckVariable18, NullPtr6, CheckVariable19, NullPtr9, CheckVariable21, NullPtr10, &
        & CheckVariable28, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "METHOD:                          ", &
    & Variable%METHOD
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "OPERATOR:                        ", &
    & Variable%OPERATOR
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "integrationType:                 ", &
    & Variable%integrationType
  
  ! Variable%PENALTY
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PENALTY)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_PENALTY_TYPE), POINTER :: " // &
      & "PENALTY " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_PENALTY_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, INTERFACE_CONDITION_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, INTERFACE_CONDITIONS_TYPE, INTERFACE_DEPENDENT_TYPE, REGION_TYPE, INTERFACE_PENALTY_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, DECOMPOSITION_TYPE, INTERFACE_LAGRANGE_TYPE, INTERFACE_CONDITION_PTR_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), InterfacePointsConnectivityType (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable7), CONTROL_LOOP_TYPE (CheckVariable8), INTERFACE_CONDITION_PTR_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), INTERFACE_EQUATIONS_TYPE (CheckVariable12), FIELDS_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), INTERFACE_LAGRANGE_TYPE (CheckVariable15), NODES_TYPE (CheckVariable16), INTERFACES_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), SOLVER_TYPE (CheckVariable22), INTERFACE_DEPENDENT_TYPE (CheckVariable23), SOLVER_MAPPING_TYPE (CheckVariable24), SOLVER_MATRICES_TYPE (CheckVariable25), INTERFACE_PENALTY_TYPE (CheckVariable26), GENERATED_MESHES_TYPE (CheckVariable27), REGION_TYPE (CheckVariable28), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type INTERFACE_CONDITION_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_DEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type INTERFACE_PENALTY_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable26
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACE_LAGRANGE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6

    ! if variable was already followed
    Ptr2 => Variable%PENALTY
    IF (ASSOCIATED(Ptr2, CheckVariable26)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PENALTY"
      CALL Print_INTERFACE_PENALTY_TYPE(Variable% &
        & PENALTY, CheckVariable19, Variable2, CheckVariable12, CheckVariable13, CheckVariable3, CheckVariable23, &
        & CheckVariable28, CheckVariable26, CheckVariable14, CheckVariable4, CheckVariable21, CheckVariable15, &
        & CheckVariable9, CheckVariable6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_PENALTY_TYPE), POINTER :: " // &
      & "PENALTY (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%LAGRANGE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LAGRANGE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: " // &
      & "LAGRANGE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_LAGRANGE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, INTERFACE_CONDITION_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, INTERFACE_CONDITIONS_TYPE, INTERFACE_DEPENDENT_TYPE, REGION_TYPE, INTERFACE_PENALTY_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, DECOMPOSITION_TYPE, INTERFACE_LAGRANGE_TYPE, INTERFACE_CONDITION_PTR_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), InterfacePointsConnectivityType (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable7), CONTROL_LOOP_TYPE (CheckVariable8), INTERFACE_CONDITION_PTR_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), INTERFACE_EQUATIONS_TYPE (CheckVariable12), FIELDS_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), INTERFACE_LAGRANGE_TYPE (CheckVariable15), NODES_TYPE (CheckVariable16), INTERFACES_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), SOLVER_TYPE (CheckVariable22), INTERFACE_DEPENDENT_TYPE (CheckVariable23), SOLVER_MAPPING_TYPE (CheckVariable24), SOLVER_MATRICES_TYPE (CheckVariable25), INTERFACE_PENALTY_TYPE (CheckVariable26), GENERATED_MESHES_TYPE (CheckVariable27), REGION_TYPE (CheckVariable28), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type INTERFACE_CONDITION_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_DEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type INTERFACE_PENALTY_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACE_LAGRANGE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable15
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6

    ! if variable was already followed
    Ptr3 => Variable%LAGRANGE
    IF (ASSOCIATED(Ptr3, CheckVariable15)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LAGRANGE"
      CALL Print_INTERFACE_LAGRANGE_TYPE(Variable% &
        & LAGRANGE, CheckVariable19, Variable2, CheckVariable12, CheckVariable13, CheckVariable3, CheckVariable23, &
        & CheckVariable28, CheckVariable26, CheckVariable14, CheckVariable4, CheckVariable21, CheckVariable15, &
        & CheckVariable9, CheckVariable6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: " // &
      & "LAGRANGE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DEPENDENT
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DEPENDENT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: " // &
      & "DEPENDENT " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_DEPENDENT_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, INTERFACE_CONDITIONS_TYPE, INTERFACE_DEPENDENT_TYPE, INTERFACE_PENALTY_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_LAGRANGE_TYPE, INTERFACE_CONDITION_PTR_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), InterfacePointsConnectivityType (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable7), CONTROL_LOOP_TYPE (CheckVariable8), INTERFACE_CONDITION_PTR_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), INTERFACE_EQUATIONS_TYPE (CheckVariable12), FIELDS_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), INTERFACE_LAGRANGE_TYPE (CheckVariable15), NODES_TYPE (CheckVariable16), INTERFACES_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), SOLVER_TYPE (CheckVariable22), INTERFACE_DEPENDENT_TYPE (CheckVariable23), SOLVER_MAPPING_TYPE (CheckVariable24), SOLVER_MATRICES_TYPE (CheckVariable25), INTERFACE_PENALTY_TYPE (CheckVariable26), GENERATED_MESHES_TYPE (CheckVariable27), REGION_TYPE (CheckVariable28), 
! - signature type INTERFACE_CONDITION_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_DEPENDENT_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable23
! - signature type INTERFACE_PENALTY_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACE_LAGRANGE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6

    ! if variable was already followed
    Ptr4 => Variable%DEPENDENT
    IF (ASSOCIATED(Ptr4, CheckVariable23)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DEPENDENT"
      CALL Print_INTERFACE_DEPENDENT_TYPE(Variable% &
        & DEPENDENT, Variable2, CheckVariable12, CheckVariable13, CheckVariable3, CheckVariable23, CheckVariable26, &
        & CheckVariable14, CheckVariable4, CheckVariable15, CheckVariable9, CheckVariable6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: " // &
      & "DEPENDENT (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE_EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_EQUATIONS_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_LAGRANGE_TYPE, BOUNDARY_CONDITIONS_TYPE, INTERFACE_MATRICES_TYPE, INTERFACE_EQUATIONS_TYPE, FIELDS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_TYPE, INTERFACE_DEPENDENT_TYPE, SOLVER_MAPPING_TYPE, INTERFACE_MAPPING_TYPE, INTERFACE_PENALTY_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_EQUATIONS_INTERPOLATION_TYPE, INTERFACE_CONDITION_PTR_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), InterfacePointsConnectivityType (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable7), CONTROL_LOOP_TYPE (CheckVariable8), INTERFACE_CONDITION_PTR_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), INTERFACE_EQUATIONS_TYPE (CheckVariable12), FIELDS_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), INTERFACE_LAGRANGE_TYPE (CheckVariable15), NODES_TYPE (CheckVariable16), INTERFACES_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), SOLVER_TYPE (CheckVariable22), INTERFACE_DEPENDENT_TYPE (CheckVariable23), SOLVER_MAPPING_TYPE (CheckVariable24), SOLVER_MATRICES_TYPE (CheckVariable25), INTERFACE_PENALTY_TYPE (CheckVariable26), GENERATED_MESHES_TYPE (CheckVariable27), REGION_TYPE (CheckVariable28), 
! - signature type INTERFACE_CONDITION_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_LAGRANGE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MATRICES_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type INTERFACE_DEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type INTERFACE_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MAPPING_TYPE
! - signature type INTERFACE_PENALTY_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACE_EQUATIONS_INTERPOLATION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_INTERPOLATION_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6

    ! if variable was already followed
    Ptr5 => Variable%INTERFACE_EQUATIONS
    IF (ASSOCIATED(Ptr5, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_EQUATIONS"
      CALL Print_INTERFACE_EQUATIONS_TYPE(Variable% &
        & INTERFACE_EQUATIONS, Variable2, CheckVariable15, CheckVariable11, NullPtr11, CheckVariable12, CheckVariable13, &
        & CheckVariable3, CheckVariable22, CheckVariable23, CheckVariable24, NullPtr12, CheckVariable26, CheckVariable14, &
        & CheckVariable4, NullPtr13, CheckVariable9, CheckVariable6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: " // &
      & "INTERFACE_EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%BOUNDARY_CONDITIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%BOUNDARY_CONDITIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: " // &
      & "BOUNDARY_CONDITIONS " // &
      & "(associated): " 
  
! Signature of Print_BOUNDARY_CONDITIONS_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, EQUATIONS_SET_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, INTERFACE_CONDITION_TYPE, SOLVERS_TYPE, REGION_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, FIELD_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, BOUNDARY_CONDITIONS_VARIABLE_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: INTERFACE_CONDITION_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), InterfacePointsConnectivityType (CheckVariable5), INTERFACE_TYPE (CheckVariable6), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable7), CONTROL_LOOP_TYPE (CheckVariable8), INTERFACE_CONDITION_PTR_TYPE (CheckVariable9), MESH_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), INTERFACE_EQUATIONS_TYPE (CheckVariable12), FIELDS_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), INTERFACE_LAGRANGE_TYPE (CheckVariable15), NODES_TYPE (CheckVariable16), INTERFACES_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), DATA_PROJECTION_TYPE (CheckVariable19), SOLVERS_TYPE (CheckVariable20), DECOMPOSITION_TYPE (CheckVariable21), SOLVER_TYPE (CheckVariable22), INTERFACE_DEPENDENT_TYPE (CheckVariable23), SOLVER_MAPPING_TYPE (CheckVariable24), SOLVER_MATRICES_TYPE (CheckVariable25), INTERFACE_PENALTY_TYPE (CheckVariable26), GENERATED_MESHES_TYPE (CheckVariable27), REGION_TYPE (CheckVariable28), 
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable11
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type INTERFACE_CONDITION_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_VARIABLE_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE

    ! if variable was already followed
    Ptr6 => Variable%BOUNDARY_CONDITIONS
    IF (ASSOCIATED(Ptr6, CheckVariable11)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BOUNDARY_CONDITIONS"
      CALL Print_BOUNDARY_CONDITIONS_TYPE(Variable% &
        & BOUNDARY_CONDITIONS, NullPtr14, NullPtr15, NullPtr16, CheckVariable11, NullPtr17, Variable2, CheckVariable20, &
        & CheckVariable28, CheckVariable22, CheckVariable24, CheckVariable25, NullPtr18, CheckVariable14, NullPtr19, &
        & CheckVariable4, CheckVariable8, NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: " // &
      & "BOUNDARY_CONDITIONS (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_CONDITION_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_MATRIX_TYPE(Variable, CheckVariable0, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_MATRIX_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable0

  ! iterator variables

  ! null pointers
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: NullPtr1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr2
  TYPE(SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr4
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_RHS_TYPE), POINTER :: NullPtr6
  TYPE(FIELD_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACE_MAPPING_TYPE), POINTER :: NullPtr8
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr9
  TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER :: NullPtr10
  TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER :: NullPtr11
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: NullPtr12
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr13
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: NullPtr14

  TYPE(INTERFACE_MATRICES_TYPE), POINTER :: Ptr0

  TYPE(INTERFACE_MATRIX_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)

  
  ! Variable%INTERFACE_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MATRICES_TYPE), POINTER :: " // &
      & "INTERFACE_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_MATRICES_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_EQUATIONS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_EQUATIONS_TYPE, INTERFACE_RHS_TYPE, FIELD_TYPE, INTERFACE_MAPPING_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRIX_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MATRICES_TYPE (CheckVariable0), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type INTERFACE_RHS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_RHS_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACE_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MAPPING_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_MATRICES
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_MATRICES"
      CALL Print_INTERFACE_MATRICES_TYPE(Variable% &
        & INTERFACE_MATRICES, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, &
        & NullPtr9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MATRICES_TYPE), POINTER :: " // &
      & "INTERFACE_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MATRIX_NUMBER:                   ", &
    & Variable%MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "STORAGE_TYPE:                    ", &
    & Variable%STORAGE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "STRUCTURE_TYPE:                  ", &
    & Variable%STRUCTURE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ROWS:                  ", &
    & Variable%NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_ROWS:            ", &
    & Variable%TOTAL_NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INTERFACE_MATRIX_TIME_DEPENDENCE_TYPE: ", &
    & Variable%INTERFACE_MATRIX_TIME_DEPENDENCE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INTERFACE_MATRIX_TRANSPOSE_TIME_DEPENDENCE_TYPE: ", &
    & Variable%INTERFACE_MATRIX_TRANSPOSE_TIME_DEPENDENCE_TYPE
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "UPDATE_MATRIX:                                   ", &
    & Variable%UPDATE_MATRIX
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "FIRST_ASSEMBLY:                                  ", &
    & Variable%FIRST_ASSEMBLY
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "HAS_TRANSPOSE:                                   ", &
    & Variable%HAS_TRANSPOSE
  
  ! Variable%MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "MATRIX " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_MATRIX_TYPE has the following CheckVariable types: DISTRIBUTED_MATRIX_CMISS_TYPE, DISTRIBUTED_MATRIX_PETSC_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRIX_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MATRICES_TYPE (CheckVariable0), 
! - signature type DISTRIBUTED_MATRIX_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_CMISS_TYPE
! - signature type DISTRIBUTED_MATRIX_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_PETSC_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATRIX"
      CALL Print_DISTRIBUTED_MATRIX_TYPE(Variable%MATRIX, NullPtr10, NullPtr11, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MATRIX_TRANSPOSE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MATRIX_TRANSPOSE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "MATRIX_TRANSPOSE " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_MATRIX_TYPE has the following CheckVariable types: DISTRIBUTED_MATRIX_CMISS_TYPE, DISTRIBUTED_MATRIX_PETSC_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRIX_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MATRICES_TYPE (CheckVariable0), 
! - signature type DISTRIBUTED_MATRIX_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_CMISS_TYPE
! - signature type DISTRIBUTED_MATRIX_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_PETSC_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATRIX_TRANSPOSE"
      CALL Print_DISTRIBUTED_MATRIX_TYPE(Variable%MATRIX_TRANSPOSE, NullPtr10, NullPtr11, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "MATRIX_TRANSPOSE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%TEMP_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%TEMP_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "TEMP_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRIX_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MATRICES_TYPE (CheckVariable0), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TEMP_VECTOR"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%TEMP_VECTOR, NullPtr12, NullPtr13, NullPtr14, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "TEMP_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%TEMP_TRANSPOSE_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%TEMP_TRANSPOSE_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "TEMP_TRANSPOSE_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRIX_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MATRICES_TYPE (CheckVariable0), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TEMP_TRANSPOSE_VECTOR"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable% &
        & TEMP_TRANSPOSE_VECTOR, NullPtr12, NullPtr13, NullPtr14, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "TEMP_TRANSPOSE_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_MATRIX_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_SET_TO_SOLVER_MAP_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_SET_TO_SOLVER_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable7

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr0
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr2
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(SOLVER_MATRIX_TYPE), POINTER :: NullPtr6
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr11
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr12
  TYPE(EquationsSetDerivedType), POINTER :: NullPtr13
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: NullPtr14
  TYPE(FIELDS_TYPE), POINTER :: NullPtr15
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr16
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: NullPtr17
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: NullPtr18
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: NullPtr19
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr20
  TYPE(FIELD_TYPE), POINTER :: NullPtr21
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr22
  TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: NullPtr23
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr24
  TYPE(REGION_TYPE), POINTER :: NullPtr25
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: NullPtr26

  TYPE(SOLVER_MAPPING_TYPE), POINTER :: Ptr0
  TYPE(EQUATIONS_TYPE), POINTER :: Ptr1

  TYPE(EQUATIONS_SET_TO_SOLVER_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "EQUATIONS_SET_INDEX:             ", &
    & Variable%EQUATIONS_SET_INDEX
  
  ! Variable%SOLVER_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MAPPING_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, DAE_SOLVER_TYPE, EQUATIONS_SET_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, EQUATIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, INTERFACE_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, SOLVER_MATRIX_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MATRIX_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRIX_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE

    ! if variable was already followed
    Ptr0 => Variable%SOLVER_MAPPING
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MAPPING"
      CALL Print_SOLVER_MAPPING_TYPE(Variable% &
        & SOLVER_MAPPING, NullPtr0, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, NullPtr4, CheckVariable0, CheckVariable2, &
        & CheckVariable3, NullPtr5, CheckVariable4, CheckVariable5, NullPtr6, NullPtr7, CheckVariable6, NullPtr8, &
        & CheckVariable7, NullPtr9, NullPtr10, NullPtr11, NullPtr12, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, BOUNDARY_CONDITIONS_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_SET_MATERIALS_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_TYPE, EQUATIONS_INTERPOLATION_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
! - signature type EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EquationsSetDerivedType
!   is not available in passing variables, use NullPtr of type EquationsSetDerivedType
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_ANALYTIC_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_MATERIALS_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type EQUATIONS_INTERPOLATION_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_INTERPOLATION_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_INDEPENDENT_TYPE

    ! if variable was already followed
    Ptr1 => Variable%EQUATIONS
    IF (ASSOCIATED(Ptr1, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS"
      CALL Print_EQUATIONS_TYPE(Variable% &
        & EQUATIONS, CheckVariable0, NullPtr2, NullPtr13, CheckVariable1, NullPtr14, NullPtr15, NullPtr16, CheckVariable3, &
        & NullPtr17, NullPtr18, CheckVariable4, NullPtr19, NullPtr20, CheckVariable6, NullPtr21, NullPtr22, NullPtr23, &
        & NullPtr24, NullPtr25, NullPtr26, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_INTERFACE_CONDITIONS:  ", &
    & Variable%NUMBER_OF_INTERFACE_CONDITIONS
  
  ! Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE,1), MIN(LBOUND(Variable% &
      & EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE_TYPE has the following CheckVariable types: SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, BOUNDARY_CONDITIONS_TYPE, SOLVER_MAPPING_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE_TYPE(Variable% &
          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE(I0), CheckVariable3, CheckVariable6, CheckVariable1, CheckVariable4, &
          & Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM,1), MIN(LBOUND(Variable% &
      & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_SET_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE(Variable% &
          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM,1), MIN(LBOUND(Variable% &
      & EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_SET_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM_TYPE(Variable% &
          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_JM(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_JM)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_JM),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(JACOBIAN_TO_SOLVER_MAP_PTR_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_TO_SOLVER_MATRIX_MAPS_JM(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_JM, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_JM,1), MIN(LBOUND(Variable% &
      & EQUATIONS_TO_SOLVER_MATRIX_MAPS_JM,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_TO_SOLVER_MATRIX_MAPS_JM,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_JACOBIAN_TO_SOLVER_MAP_PTR_TYPE has the following CheckVariable types: SOLVER_MATRICES_TYPE, SOLVER_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_TO_SOLVER_MATRIX_MAPS_JM("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_JACOBIAN_TO_SOLVER_MAP_PTR_TYPE(Variable% &
          & EQUATIONS_TO_SOLVER_MATRIX_MAPS_JM(I0), CheckVariable5, CheckVariable6, CheckVariable4, Depth+1, MaxDepth, &
          & MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(JACOBIAN_TO_SOLVER_MAP_PTR_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_TO_SOLVER_MATRIX_MAPS_JM(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_ROW_TO_SOLVER_ROWS_MAP_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS,1), MIN(LBOUND(Variable% &
      & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_ROW_TO_SOLVER_ROWS_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_SET_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVER_MATRICES_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_ROW_TO_SOLVER_ROWS_MAP_TYPE(Variable% &
          & EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_ROW_TO_SOLVER_ROWS_MAP_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_ROW_TO_SOLVER_ROWS_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EQUATIONS_SET_TO_SOLVER_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MATRICES_DYNAMIC_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: NullPtr4
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_TYPE), POINTER :: NullPtr6
  TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr8
  TYPE(REGION_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: NullPtr10
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: NullPtr11
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr12
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: NullPtr13

  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: Ptr0

  TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)

  
  ! Variable%EQUATIONS_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MATRICES_DYNAMIC_TYPE, SOLVER_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_MATRICES_RHS_TYPE, EQUATIONS_MATRICES_LINEAR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_MATRICES_SOURCE_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_MATRICES_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_DYNAMIC_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_MATRICES_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), EQUATIONS_TYPE (CheckVariable2), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EQUATIONS_MATRICES_DYNAMIC_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EQUATIONS_MATRICES_RHS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_RHS_TYPE
! - signature type EQUATIONS_MATRICES_LINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_LINEAR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type EQUATIONS_MATRICES_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_SOURCE_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type EQUATIONS_MATRICES_NONLINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_NONLINEAR_TYPE

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_MATRICES
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MATRICES"
      CALL Print_EQUATIONS_MATRICES_TYPE(Variable% &
        & EQUATIONS_MATRICES, CheckVariable2, NullPtr0, Variable2, NullPtr1, NullPtr2, CheckVariable1, NullPtr3, NullPtr4, &
        & NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DYNAMIC_MATRICES:      ", &
    & Variable%NUMBER_OF_DYNAMIC_MATRICES
  
  ! Variable%MATRICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MATRICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MATRICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRIX_PTR_TYPE), ALLOCATABLE :: " // &
      & "MATRICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MATRICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%MATRICES,1), MIN(LBOUND(Variable%MATRICES,1)+MaxArrayLength, UBOUND(Variable%MATRICES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_MATRIX_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MATRICES_DYNAMIC_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_MATRICES_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), EQUATIONS_TYPE (CheckVariable2), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATRICES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_MATRIX_PTR_TYPE(Variable%MATRICES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRIX_PTR_TYPE), ALLOCATABLE :: " // &
      & "MATRICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%TEMP_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%TEMP_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "TEMP_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_DYNAMIC_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_MATRICES_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), EQUATIONS_TYPE (CheckVariable2), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TEMP_VECTOR"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%TEMP_VECTOR, NullPtr11, NullPtr12, NullPtr13, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "TEMP_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_MATRICES_DYNAMIC_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable18

  ! iterator variables

  ! null pointers
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr0
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr3
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr4
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr5
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr6
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr7
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr8
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr10

  TYPE(INTERFACE_TYPE), POINTER :: Ptr0

  TYPE(INTERFACE_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable11)) THEN
    Variable2 => CheckVariable11
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: INTERFACE_PTR_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), INTERFACES_TYPE (CheckVariable1), InterfacePointsConnectivityType (CheckVariable2), MESHES_TYPE (CheckVariable3), MESH_PTR_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), INTERFACE_CONDITIONS_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), MESH_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), INTERFACE_PTR_TYPE (CheckVariable11), GENERATED_MESHES_TYPE (CheckVariable12), FIELD_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), NODES_TYPE (CheckVariable15), FIELD_PTR_TYPE (CheckVariable16), REGION_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type INTERFACE_PTR_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable17

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_INTERFACE_TYPE(Variable% &
        & PTR, NullPtr0, CheckVariable3, CheckVariable4, CheckVariable6, CheckVariable16, NullPtr1, CheckVariable13, &
        & CheckVariable7, CheckVariable2, NullPtr2, CheckVariable9, Variable2, CheckVariable10, CheckVariable14, NullPtr3, &
        & NullPtr4, CheckVariable8, NullPtr5, CheckVariable5, CheckVariable12, NullPtr6, CheckVariable15, CheckVariable1, &
        & CheckVariable18, NullPtr7, CheckVariable0, NullPtr8, NullPtr9, NullPtr10, CheckVariable17, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MATRICES_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER, INTENT(IN) :: CheckVariable13

  ! iterator variables

  ! null pointers
  TYPE(EquationsSetDerivedType), POINTER :: NullPtr0
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: NullPtr2
  TYPE(FIELDS_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: NullPtr4
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: NullPtr5
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: NullPtr8
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER :: NullPtr10
  TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER :: NullPtr11
  TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER :: NullPtr12
  TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER :: NullPtr13
  TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER :: NullPtr14
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr15
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr16
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr18
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr19
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: NullPtr20
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr21
  TYPE(SOLVER_MATRIX_TYPE), POINTER :: NullPtr22
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr23
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr24
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr25
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr26
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr27
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr28
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr29

  TYPE(EQUATIONS_TYPE), POINTER :: Ptr0
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: Ptr1
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: Ptr2
  TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: Ptr3
  TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: Ptr4
  TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: Ptr5
  TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: Ptr6
  TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER :: Ptr7

  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)
  Nullify(NullPtr29)

  
  ! Variable%EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, BOUNDARY_CONDITIONS_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_SET_MATERIALS_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_TYPE, EQUATIONS_INTERPOLATION_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MATRICES_DYNAMIC_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), EQUATIONS_MAPPING_TYPE (CheckVariable4), SOLVER_MAPPING_TYPE (CheckVariable5), EQUATIONS_MATRICES_RHS_TYPE (CheckVariable6), EQUATIONS_MATRICES_LINEAR_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_MATRICES_SOURCE_TYPE (CheckVariable10), EQUATIONS_SETS_TYPE (CheckVariable11), REGION_TYPE (CheckVariable12), EQUATIONS_MATRICES_NONLINEAR_TYPE (CheckVariable13), 
! - signature type EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EquationsSetDerivedType
!   is not available in passing variables, use NullPtr of type EquationsSetDerivedType
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_ANALYTIC_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type EQUATIONS_MATRICES_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_MATERIALS_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type EQUATIONS_INTERPOLATION_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_INTERPOLATION_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_INDEPENDENT_TYPE

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS"
      CALL Print_EQUATIONS_TYPE(Variable% &
        & EQUATIONS, CheckVariable0, CheckVariable1, NullPtr0, NullPtr1, NullPtr2, NullPtr3, Variable2, CheckVariable3, &
        & NullPtr4, CheckVariable4, CheckVariable5, NullPtr5, NullPtr6, CheckVariable8, CheckVariable9, NullPtr7, NullPtr8, &
        & CheckVariable11, CheckVariable12, NullPtr9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "EQUATIONS_MATRICES_FINISHED:                     ", &
    & Variable%EQUATIONS_MATRICES_FINISHED
  
  ! Variable%EQUATIONS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MAPPING_LINEAR_TYPE, EQUATIONS_MAPPING_DYNAMIC_TYPE, EQUATIONS_MAPPING_RHS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, REGION_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_MAPPING_SOURCE_TYPE, EQUATIONS_MAPPING_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MATRICES_DYNAMIC_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), EQUATIONS_MAPPING_TYPE (CheckVariable4), SOLVER_MAPPING_TYPE (CheckVariable5), EQUATIONS_MATRICES_RHS_TYPE (CheckVariable6), EQUATIONS_MATRICES_LINEAR_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_MATRICES_SOURCE_TYPE (CheckVariable10), EQUATIONS_SETS_TYPE (CheckVariable11), REGION_TYPE (CheckVariable12), EQUATIONS_MATRICES_NONLINEAR_TYPE (CheckVariable13), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EQUATIONS_MAPPING_LINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_LINEAR_TYPE
! - signature type EQUATIONS_MAPPING_DYNAMIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_DYNAMIC_TYPE
! - signature type EQUATIONS_MAPPING_RHS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_RHS_TYPE
! - signature type EQUATIONS_MATRICES_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EQUATIONS_MAPPING_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_NONLINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_NONLINEAR_TYPE

    ! if variable was already followed
    Ptr1 => Variable%EQUATIONS_MAPPING
    IF (ASSOCIATED(Ptr1, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MAPPING"
      CALL Print_EQUATIONS_MAPPING_TYPE(Variable% &
        & EQUATIONS_MAPPING, CheckVariable0, CheckVariable1, NullPtr10, NullPtr11, NullPtr12, Variable2, CheckVariable5, &
        & CheckVariable12, CheckVariable8, CheckVariable9, CheckVariable11, NullPtr13, NullPtr14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOLVER_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MAPPING_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, DAE_SOLVER_TYPE, EQUATIONS_SET_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, EQUATIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, INTERFACE_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, SOLVER_MATRIX_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MATRICES_DYNAMIC_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), EQUATIONS_MAPPING_TYPE (CheckVariable4), SOLVER_MAPPING_TYPE (CheckVariable5), EQUATIONS_MATRICES_RHS_TYPE (CheckVariable6), EQUATIONS_MATRICES_LINEAR_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_MATRICES_SOURCE_TYPE (CheckVariable10), EQUATIONS_SETS_TYPE (CheckVariable11), REGION_TYPE (CheckVariable12), EQUATIONS_MATRICES_NONLINEAR_TYPE (CheckVariable13), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable5
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type SOLVER_MATRIX_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRIX_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE

    ! if variable was already followed
    Ptr2 => Variable%SOLVER_MAPPING
    IF (ASSOCIATED(Ptr2, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MAPPING"
      CALL Print_SOLVER_MAPPING_TYPE(Variable% &
        & SOLVER_MAPPING, NullPtr15, NullPtr16, CheckVariable1, NullPtr17, NullPtr1, NullPtr18, CheckVariable0, NullPtr19, &
        & CheckVariable3, NullPtr20, CheckVariable5, NullPtr21, NullPtr22, NullPtr23, CheckVariable8, NullPtr24, NullPtr25, &
        & NullPtr26, NullPtr27, NullPtr28, NullPtr29, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ROWS:                  ", &
    & Variable%NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_ROWS:            ", &
    & Variable%TOTAL_NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_ROWS:           ", &
    & Variable%NUMBER_OF_GLOBAL_ROWS
  
  ! Variable%DYNAMIC_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DYNAMIC_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: " // &
      & "DYNAMIC_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_DYNAMIC_TYPE has the following CheckVariable types: EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MATRICES_DYNAMIC_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), EQUATIONS_MAPPING_TYPE (CheckVariable4), SOLVER_MAPPING_TYPE (CheckVariable5), EQUATIONS_MATRICES_RHS_TYPE (CheckVariable6), EQUATIONS_MATRICES_LINEAR_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_MATRICES_SOURCE_TYPE (CheckVariable10), EQUATIONS_SETS_TYPE (CheckVariable11), REGION_TYPE (CheckVariable12), EQUATIONS_MATRICES_NONLINEAR_TYPE (CheckVariable13), 
! - signature type EQUATIONS_MATRICES_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0

    ! if variable was already followed
    Ptr3 => Variable%DYNAMIC_MATRICES
    IF (ASSOCIATED(Ptr3, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DYNAMIC_MATRICES"
      CALL Print_EQUATIONS_MATRICES_DYNAMIC_TYPE(Variable% &
        & DYNAMIC_MATRICES, Variable2, CheckVariable5, CheckVariable0, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: " // &
      & "DYNAMIC_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%LINEAR_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINEAR_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: " // &
      & "LINEAR_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_LINEAR_TYPE has the following CheckVariable types: EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MATRICES_DYNAMIC_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), EQUATIONS_MAPPING_TYPE (CheckVariable4), SOLVER_MAPPING_TYPE (CheckVariable5), EQUATIONS_MATRICES_RHS_TYPE (CheckVariable6), EQUATIONS_MATRICES_LINEAR_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_MATRICES_SOURCE_TYPE (CheckVariable10), EQUATIONS_SETS_TYPE (CheckVariable11), REGION_TYPE (CheckVariable12), EQUATIONS_MATRICES_NONLINEAR_TYPE (CheckVariable13), 
! - signature type EQUATIONS_MATRICES_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0

    ! if variable was already followed
    Ptr4 => Variable%LINEAR_MATRICES
    IF (ASSOCIATED(Ptr4, CheckVariable7)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINEAR_MATRICES"
      CALL Print_EQUATIONS_MATRICES_LINEAR_TYPE(Variable% &
        & LINEAR_MATRICES, Variable2, CheckVariable5, CheckVariable0, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: " // &
      & "LINEAR_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%NONLINEAR_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NONLINEAR_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: " // &
      & "NONLINEAR_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_NONLINEAR_TYPE has the following CheckVariable types: EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MATRICES_DYNAMIC_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), EQUATIONS_MAPPING_TYPE (CheckVariable4), SOLVER_MAPPING_TYPE (CheckVariable5), EQUATIONS_MATRICES_RHS_TYPE (CheckVariable6), EQUATIONS_MATRICES_LINEAR_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_MATRICES_SOURCE_TYPE (CheckVariable10), EQUATIONS_SETS_TYPE (CheckVariable11), REGION_TYPE (CheckVariable12), EQUATIONS_MATRICES_NONLINEAR_TYPE (CheckVariable13), 
! - signature type EQUATIONS_MATRICES_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0

    ! if variable was already followed
    Ptr5 => Variable%NONLINEAR_MATRICES
    IF (ASSOCIATED(Ptr5, CheckVariable13)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NONLINEAR_MATRICES"
      CALL Print_EQUATIONS_MATRICES_NONLINEAR_TYPE(Variable% &
        & NONLINEAR_MATRICES, Variable2, CheckVariable5, CheckVariable0, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: " // &
      & "NONLINEAR_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%RHS_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RHS_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: " // &
      & "RHS_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_RHS_TYPE has the following CheckVariable types: EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MATRICES_DYNAMIC_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), EQUATIONS_MAPPING_TYPE (CheckVariable4), SOLVER_MAPPING_TYPE (CheckVariable5), EQUATIONS_MATRICES_RHS_TYPE (CheckVariable6), EQUATIONS_MATRICES_LINEAR_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_MATRICES_SOURCE_TYPE (CheckVariable10), EQUATIONS_SETS_TYPE (CheckVariable11), REGION_TYPE (CheckVariable12), EQUATIONS_MATRICES_NONLINEAR_TYPE (CheckVariable13), 
! - signature type EQUATIONS_MATRICES_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0

    ! if variable was already followed
    Ptr6 => Variable%RHS_VECTOR
    IF (ASSOCIATED(Ptr6, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RHS_VECTOR"
      CALL Print_EQUATIONS_MATRICES_RHS_TYPE(Variable% &
        & RHS_VECTOR, Variable2, CheckVariable5, CheckVariable0, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: " // &
      & "RHS_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOURCE_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOURCE_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER :: " // &
      & "SOURCE_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_SOURCE_TYPE has the following CheckVariable types: EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), EQUATIONS_MATRICES_DYNAMIC_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), EQUATIONS_MAPPING_TYPE (CheckVariable4), SOLVER_MAPPING_TYPE (CheckVariable5), EQUATIONS_MATRICES_RHS_TYPE (CheckVariable6), EQUATIONS_MATRICES_LINEAR_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), EQUATIONS_MATRICES_SOURCE_TYPE (CheckVariable10), EQUATIONS_SETS_TYPE (CheckVariable11), REGION_TYPE (CheckVariable12), EQUATIONS_MATRICES_NONLINEAR_TYPE (CheckVariable13), 
! - signature type EQUATIONS_MATRICES_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0

    ! if variable was already followed
    Ptr7 => Variable%SOURCE_VECTOR
    IF (ASSOCIATED(Ptr7, CheckVariable10)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOURCE_VECTOR"
      CALL Print_EQUATIONS_MATRICES_SOURCE_TYPE(Variable% &
        & SOURCE_VECTOR, Variable2, CheckVariable5, CheckVariable0, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER :: " // &
      & "SOURCE_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_MATRICES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_INTERFACE_MATRICES:    ", &
    & Variable%NUMBER_OF_INTERFACE_MATRICES
  
  ! Variable%INTERFACE_MATRIX_NUMBERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_MATRIX_NUMBERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_MATRIX_NUMBERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERFACE_MATRIX_NUMBERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_MATRIX_NUMBERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%INTERFACE_MATRIX_NUMBERS,1), MIN(LBOUND(Variable% &
      & INTERFACE_MATRIX_NUMBERS,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_MATRIX_NUMBERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%INTERFACE_MATRIX_NUMBERS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERFACE_MATRIX_NUMBERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERFACE_COL_NUMBERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_COL_NUMBERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_COL_NUMBERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERFACE_COL_NUMBERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_COL_NUMBERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%INTERFACE_COL_NUMBERS,1), MIN(LBOUND(Variable% &
      & INTERFACE_COL_NUMBERS,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_COL_NUMBERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%INTERFACE_COL_NUMBERS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERFACE_COL_NUMBERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COUPLING_COEFFICIENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COUPLING_COEFFICIENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COUPLING_COEFFICIENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COUPLING_COEFFICIENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COUPLING_COEFFICIENTS,1), MIN(LBOUND(Variable% &
      & COUPLING_COEFFICIENTS,1)+MaxArrayLength, UBOUND(Variable%COUPLING_COEFFICIENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COUPLING_COEFFICIENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MAPPING_CREATE_VALUES_CACHE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(EQUATIONS_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DYNAMIC_EQUATIONS_MATRICES: ", &
    & Variable%NUMBER_OF_DYNAMIC_EQUATIONS_MATRICES
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DYNAMIC_STIFFNESS_MATRIX_NUMBER: ", &
    & Variable%DYNAMIC_STIFFNESS_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DYNAMIC_DAMPING_MATRIX_NUMBER:   ", &
    & Variable%DYNAMIC_DAMPING_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DYNAMIC_MASS_MATRIX_NUMBER:      ", &
    & Variable%DYNAMIC_MASS_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DYNAMIC_VARIABLE_TYPE:           ", &
    & Variable%DYNAMIC_VARIABLE_TYPE
  
  ! Variable%DYNAMIC_MATRIX_COEFFICIENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DYNAMIC_MATRIX_COEFFICIENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DYNAMIC_MATRIX_COEFFICIENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "DYNAMIC_MATRIX_COEFFICIENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DYNAMIC_MATRIX_COEFFICIENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DYNAMIC_MATRIX_COEFFICIENTS,1), MIN(LBOUND(Variable% &
      & DYNAMIC_MATRIX_COEFFICIENTS,1)+MaxArrayLength, UBOUND(Variable%DYNAMIC_MATRIX_COEFFICIENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DYNAMIC_MATRIX_COEFFICIENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "DYNAMIC_MATRIX_COEFFICIENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LINEAR_EQUATIONS_MATRICES: ", &
    & Variable%NUMBER_OF_LINEAR_EQUATIONS_MATRICES
  
  ! Variable%LINEAR_MATRIX_VARIABLE_TYPES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LINEAR_MATRIX_VARIABLE_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LINEAR_MATRIX_VARIABLE_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LINEAR_MATRIX_VARIABLE_TYPES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LINEAR_MATRIX_VARIABLE_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LINEAR_MATRIX_VARIABLE_TYPES,1), MIN(LBOUND(Variable% &
      & LINEAR_MATRIX_VARIABLE_TYPES,1)+MaxArrayLength, UBOUND(Variable%LINEAR_MATRIX_VARIABLE_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LINEAR_MATRIX_VARIABLE_TYPES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LINEAR_MATRIX_VARIABLE_TYPES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LINEAR_MATRIX_COEFFICIENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LINEAR_MATRIX_COEFFICIENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LINEAR_MATRIX_COEFFICIENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "LINEAR_MATRIX_COEFFICIENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LINEAR_MATRIX_COEFFICIENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LINEAR_MATRIX_COEFFICIENTS,1), MIN(LBOUND(Variable% &
      & LINEAR_MATRIX_COEFFICIENTS,1)+MaxArrayLength, UBOUND(Variable%LINEAR_MATRIX_COEFFICIENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LINEAR_MATRIX_COEFFICIENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "LINEAR_MATRIX_COEFFICIENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_RESIDUAL_VARIABLES:    ", &
    & Variable%NUMBER_OF_RESIDUAL_VARIABLES
  
  ! Variable%RESIDUAL_VARIABLE_TYPES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%RESIDUAL_VARIABLE_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%RESIDUAL_VARIABLE_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "RESIDUAL_VARIABLE_TYPES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%RESIDUAL_VARIABLE_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%RESIDUAL_VARIABLE_TYPES,1), MIN(LBOUND(Variable% &
      & RESIDUAL_VARIABLE_TYPES,1)+MaxArrayLength, UBOUND(Variable%RESIDUAL_VARIABLE_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%RESIDUAL_VARIABLE_TYPES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "RESIDUAL_VARIABLE_TYPES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "RESIDUAL_COEFFICIENT:        ", &
    & Variable%RESIDUAL_COEFFICIENT
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "RHS_VARIABLE_TYPE:               ", &
    & Variable%RHS_VARIABLE_TYPE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "RHS_COEFFICIENT:             ", &
    & Variable%RHS_COEFFICIENT
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOURCE_VARIABLE_TYPE:            ", &
    & Variable%SOURCE_VARIABLE_TYPE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "SOURCE_COEFFICIENT:          ", &
    & Variable%SOURCE_COEFFICIENT

  
END SUBROUTINE Print_EQUATIONS_MAPPING_CREATE_VALUES_CACHE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MeshDataPointsType(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, Depth, MaxDepth, MaxArrayLength)
  TYPE(MeshDataPointsType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MeshComponentTopologyType), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(MeshNodesType), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(MeshElementsType), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(MeshDataPointsType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(MeshDofsType), POINTER, INTENT(IN) :: CheckVariable9

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_TYPE), POINTER :: NullPtr1
  TYPE(FIELDS_TYPE), POINTER :: NullPtr2
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr3
  TYPE(REGION_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr5
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr6
  TYPE(MESHES_TYPE), POINTER :: NullPtr7
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr8

  TYPE(MeshComponentTopologyType), POINTER :: Ptr0

  TYPE(MeshDataPointsType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable6)) THEN
    Variable2 => CheckVariable6
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)

  
  ! Variable%meshComponentTopology
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%meshComponentTopology)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshComponentTopologyType), POINTER :: " // &
      & "meshComponentTopology " // &
      & "(associated): " 
  
! Signature of Print_MeshComponentTopologyType has the following CheckVariable types: DATA_PROJECTION_TYPE, MESH_TYPE, MeshDataPointsType, MeshComponentTopologyPtrType, FIELD_TYPE, MESH_PTR_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, MeshNodesType, MeshElementsType, REGION_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, GENERATED_MESH_TYPE, MeshComponentTopologyType, MESHES_TYPE, DECOMPOSITIONS_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, MeshDofsType, 
! The type to handle in this routine is: MeshDataPointsType (Variable)
! Available CheckVariables are: MESH_TYPE (CheckVariable0), MeshComponentTopologyType (CheckVariable1), MeshComponentTopologyPtrType (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), MeshNodesType (CheckVariable4), MeshElementsType (CheckVariable5), MeshDataPointsType (CheckVariable6), DECOMPOSITIONS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), MeshDofsType (CheckVariable9), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MeshDataPointsType
!   is type of this print routine, use Variable2
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type MeshNodesType
!   matches available passing type, use it as CheckVariable4
! - signature type MeshElementsType
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type MeshComponentTopologyType
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type MeshDofsType
!   matches available passing type, use it as CheckVariable9

    ! if variable was already followed
    Ptr0 => Variable%meshComponentTopology
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"meshComponentTopology"
      CALL Print_MeshComponentTopologyType(Variable% &
        & meshComponentTopology, NullPtr0, CheckVariable0, Variable2, CheckVariable2, NullPtr1, CheckVariable3, NullPtr2, &
        & NullPtr3, CheckVariable4, CheckVariable5, NullPtr4, NullPtr5, NullPtr6, CheckVariable1, NullPtr7, CheckVariable7, &
        & NullPtr8, CheckVariable8, CheckVariable9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshComponentTopologyType), POINTER :: " // &
      & "meshComponentTopology (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "totalNumberOfProjectedData:      ", &
    & Variable%totalNumberOfProjectedData
  
  ! Variable%dataPoints(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%dataPoints)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%dataPoints),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshDataPointType), ALLOCATABLE :: " // &
      & "dataPoints(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%dataPoints, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%dataPoints,1), MIN(LBOUND(Variable%dataPoints,1)+MaxArrayLength, UBOUND(Variable%dataPoints,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_MeshDataPointType has the following CheckVariable types: 
! The type to handle in this routine is: MeshDataPointsType (Variable)
! Available CheckVariables are: MESH_TYPE (CheckVariable0), MeshComponentTopologyType (CheckVariable1), MeshComponentTopologyPtrType (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), MeshNodesType (CheckVariable4), MeshElementsType (CheckVariable5), MeshDataPointsType (CheckVariable6), DECOMPOSITIONS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), MeshDofsType (CheckVariable9), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"dataPoints("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_MeshDataPointType(Variable%dataPoints(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshDataPointType), ALLOCATABLE :: " // &
      & "dataPoints(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%elementDataPoint(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%elementDataPoint)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%elementDataPoint),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshElementDataPointsType), ALLOCATABLE :: " // &
      & "elementDataPoint(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%elementDataPoint, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%elementDataPoint,1), MIN(LBOUND(Variable%elementDataPoint,1)+MaxArrayLength, UBOUND(Variable% &
      & elementDataPoint,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_MeshElementDataPointsType has the following CheckVariable types: 
! The type to handle in this routine is: MeshDataPointsType (Variable)
! Available CheckVariables are: MESH_TYPE (CheckVariable0), MeshComponentTopologyType (CheckVariable1), MeshComponentTopologyPtrType (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), MeshNodesType (CheckVariable4), MeshElementsType (CheckVariable5), MeshDataPointsType (CheckVariable6), DECOMPOSITIONS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), MeshDofsType (CheckVariable9), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"elementDataPoint("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_MeshElementDataPointsType(Variable%elementDataPoint(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshElementDataPointsType), ALLOCATABLE :: " // &
      & "elementDataPoint(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_MeshDataPointsType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DATA_POINT_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DATA_POINT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(DATA_POINT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  
  ! Variable%position(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%position)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%position),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "position(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%position, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%position,1), MIN(LBOUND(Variable%position,1)+MaxArrayLength, UBOUND(Variable%position,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%position(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "position(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%WEIGHTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%WEIGHTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%WEIGHTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "WEIGHTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%WEIGHTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%WEIGHTS,1), MIN(LBOUND(Variable%WEIGHTS,1)+MaxArrayLength, UBOUND(Variable%WEIGHTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%WEIGHTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "WEIGHTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DATA_POINT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_JACOBIAN_COL_TO_SOLVER_COLS_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(JACOBIAN_COL_TO_SOLVER_COLS_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(JACOBIAN_COL_TO_SOLVER_COLS_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SOLVER_COLS:           ", &
    & Variable%NUMBER_OF_SOLVER_COLS
  
  ! Variable%SOLVER_COLS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOLVER_COLS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOLVER_COLS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "SOLVER_COLS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOLVER_COLS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SOLVER_COLS,1), MIN(LBOUND(Variable%SOLVER_COLS,1)+MaxArrayLength, UBOUND(Variable%SOLVER_COLS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SOLVER_COLS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "SOLVER_COLS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COUPLING_COEFFICIENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COUPLING_COEFFICIENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COUPLING_COEFFICIENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COUPLING_COEFFICIENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COUPLING_COEFFICIENTS,1), MIN(LBOUND(Variable% &
      & COUPLING_COEFFICIENTS,1)+MaxArrayLength, UBOUND(Variable%COUPLING_COEFFICIENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COUPLING_COEFFICIENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_JACOBIAN_COL_TO_SOLVER_COLS_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_GENERATED_MESH_REGULAR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, Depth, MaxDepth, MaxArrayLength)
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable17

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers
  TYPE(MeshComponentTopologyType), POINTER :: NullPtr0
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr2
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr4
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr5
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr6
  TYPE(NODES_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(BASIS_TYPE), POINTER :: NullPtr10
  TYPE(BASIS_PTR_TYPE), POINTER :: NullPtr11

  TYPE(GENERATED_MESH_TYPE), POINTER :: Ptr0

  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable1)) THEN
    Variable2 => CheckVariable1
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)

  
  ! Variable%GENERATED_MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GENERATED_MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GENERATED_MESH_TYPE), POINTER :: " // &
      & "GENERATED_MESH " // &
      & "(associated): " 
  
! Signature of Print_GENERATED_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, DECOMPOSITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_REGULAR_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), GENERATED_MESH_REGULAR_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), MESHES_TYPE (CheckVariable3), GENERATED_MESH_CYLINDER_TYPE (CheckVariable4), MESH_PTR_TYPE (CheckVariable5), FIELDS_TYPE (CheckVariable6), DECOMPOSITION_TYPE (CheckVariable7), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable8), REGION_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), GENERATED_MESH_TYPE (CheckVariable11), GENERATED_MESHES_TYPE (CheckVariable12), FIELD_TYPE (CheckVariable13), DECOMPOSITIONS_TYPE (CheckVariable14), InterfacePointsConnectivityType (CheckVariable15), INTERFACE_TYPE (CheckVariable16), GENERATED_MESH_PTR_TYPE (CheckVariable17), 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable11
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable9

    ! if variable was already followed
    Ptr0 => Variable%GENERATED_MESH
    IF (ASSOCIATED(Ptr0, CheckVariable11)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GENERATED_MESH"
      CALL Print_GENERATED_MESH_TYPE(Variable% &
        & GENERATED_MESH, NullPtr0, CheckVariable3, CheckVariable4, CheckVariable5, NullPtr1, CheckVariable8, NullPtr2, &
        & CheckVariable11, CheckVariable13, NullPtr3, CheckVariable15, CheckVariable16, CheckVariable10, NullPtr4, &
        & NullPtr5, CheckVariable2, NullPtr6, CheckVariable6, CheckVariable12, CheckVariable14, NullPtr7, NullPtr8, &
        & NullPtr9, CheckVariable17, CheckVariable0, Variable2, CheckVariable7, CheckVariable9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GENERATED_MESH_TYPE), POINTER :: " // &
      & "GENERATED_MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%BASES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%BASES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%BASES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_PTR_TYPE), ALLOCATABLE :: " // &
      & "BASES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%BASES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%BASES,1), MIN(LBOUND(Variable%BASES,1)+MaxArrayLength, UBOUND(Variable%BASES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_BASIS_PTR_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_REGULAR_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), GENERATED_MESH_REGULAR_TYPE (CheckVariable1), MESH_TYPE (CheckVariable2), MESHES_TYPE (CheckVariable3), GENERATED_MESH_CYLINDER_TYPE (CheckVariable4), MESH_PTR_TYPE (CheckVariable5), FIELDS_TYPE (CheckVariable6), DECOMPOSITION_TYPE (CheckVariable7), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable8), REGION_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), GENERATED_MESH_TYPE (CheckVariable11), GENERATED_MESHES_TYPE (CheckVariable12), FIELD_TYPE (CheckVariable13), DECOMPOSITIONS_TYPE (CheckVariable14), InterfacePointsConnectivityType (CheckVariable15), INTERFACE_TYPE (CheckVariable16), GENERATED_MESH_PTR_TYPE (CheckVariable17), 
! - signature type BASIS_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_TYPE
! - signature type BASIS_PTR_TYPE
!   is not available in passing variables, use NullPtr of type BASIS_PTR_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BASES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_BASIS_PTR_TYPE(Variable%BASES(I0), NullPtr10, NullPtr11, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_PTR_TYPE), ALLOCATABLE :: " // &
      & "BASES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "COORDINATE_DIMENSION:            ", &
    & Variable%COORDINATE_DIMENSION
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MESH_DIMENSION:                  ", &
    & Variable%MESH_DIMENSION
  
  ! Variable%ORIGIN(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ORIGIN)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ORIGIN),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "ORIGIN(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ORIGIN, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ORIGIN,1), MIN(LBOUND(Variable%ORIGIN,1)+MaxArrayLength, UBOUND(Variable%ORIGIN,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ORIGIN(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "ORIGIN(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%MAXIMUM_EXTENT(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MAXIMUM_EXTENT)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MAXIMUM_EXTENT),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "MAXIMUM_EXTENT(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MAXIMUM_EXTENT, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%MAXIMUM_EXTENT,1), MIN(LBOUND(Variable%MAXIMUM_EXTENT,1)+MaxArrayLength, UBOUND(Variable% &
      & MAXIMUM_EXTENT,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%MAXIMUM_EXTENT(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "MAXIMUM_EXTENT(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%BASE_VECTORS(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%BASE_VECTORS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%BASE_VECTORS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "BASE_VECTORS(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%BASE_VECTORS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%BASE_VECTORS,1), MIN(LBOUND(Variable%BASE_VECTORS,1)+MaxArrayLength, UBOUND(Variable%BASE_VECTORS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%BASE_VECTORS,2), MIN(LBOUND(Variable%BASE_VECTORS,2)+MaxArrayLength, UBOUND(Variable%BASE_VECTORS,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%BASE_VECTORS(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "BASE_VECTORS(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NUMBER_OF_ELEMENTS_XI(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_ELEMENTS_XI)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_ELEMENTS_XI),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_ELEMENTS_XI(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_ELEMENTS_XI, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_ELEMENTS_XI,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_ELEMENTS_XI,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_ELEMENTS_XI,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_ELEMENTS_XI(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_ELEMENTS_XI(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_GENERATED_MESH_REGULAR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_MODEL_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_MODEL_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable8

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr2
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr3
  TYPE(MESH_TYPE), POINTER :: NullPtr4
  TYPE(FIELDS_TYPE), POINTER :: NullPtr5
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr6
  TYPE(NODES_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr10
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr11
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr12

  TYPE(CELLML_TYPE), POINTER :: Ptr0

  TYPE(CELLML_MODEL_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)

  
  ! Variable%CELLML
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CELLML)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML " // &
      & "(associated): " 
  
! Signature of Print_CELLML_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, CELLML_MODEL_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_MODEL_TYPE (Variable)
! Available CheckVariables are: CELLML_PARAMETERS_FIELD_TYPE (CheckVariable0), CELLML_FIELD_MAPS_TYPE (CheckVariable1), CELLML_ENVIRONMENTS_TYPE (CheckVariable2), CELLML_STATE_FIELD_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), CELLML_TYPE (CheckVariable5), CELLML_MODELS_FIELD_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable8), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CELLML_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable5
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CELLML_MODEL_TYPE
!   is type of this print routine, use Variable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7

    ! if variable was already followed
    Ptr0 => Variable%CELLML
    IF (ASSOCIATED(Ptr0, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML"
      CALL Print_CELLML_TYPE(Variable% &
        & CELLML, NullPtr0, CheckVariable4, NullPtr1, CheckVariable6, CheckVariable8, NullPtr2, NullPtr3, CheckVariable2, &
        & CheckVariable3, CheckVariable5, NullPtr4, NullPtr5, CheckVariable1, Variable2, NullPtr6, NullPtr7, NullPtr8, &
        & NullPtr9, NullPtr10, CheckVariable0, NullPtr11, NullPtr12, CheckVariable7, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_STATE:                 ", &
    & Variable%NUMBER_OF_STATE
  
  ! Variable%STATE_VARIABLE_ID(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%STATE_VARIABLE_ID)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%STATE_VARIABLE_ID),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(VARYING_STRING), ALLOCATABLE :: " // &
      & "STATE_VARIABLE_ID(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%STATE_VARIABLE_ID, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(VARYING_STRING) :: Variable%" // &
        & "STATE_VARIABLE_ID (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(VARYING_STRING), ALLOCATABLE :: " // &
      & "STATE_VARIABLE_ID(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_INTERMEDIATE:          ", &
    & Variable%NUMBER_OF_INTERMEDIATE
  
  ! Variable%INTERMEDIATE_VARIABLE_ID(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERMEDIATE_VARIABLE_ID)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERMEDIATE_VARIABLE_ID),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(VARYING_STRING), ALLOCATABLE :: " // &
      & "INTERMEDIATE_VARIABLE_ID(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERMEDIATE_VARIABLE_ID, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(VARYING_STRING) :: Variable%" // &
        & "INTERMEDIATE_VARIABLE_ID (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(VARYING_STRING), ALLOCATABLE :: " // &
      & "INTERMEDIATE_VARIABLE_ID(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_PARAMETERS:            ", &
    & Variable%NUMBER_OF_PARAMETERS
  
  ! Variable%PARAMETER_VARIABLE_ID(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%PARAMETER_VARIABLE_ID)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%PARAMETER_VARIABLE_ID),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(VARYING_STRING), ALLOCATABLE :: " // &
      & "PARAMETER_VARIABLE_ID(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%PARAMETER_VARIABLE_ID, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(VARYING_STRING) :: Variable%" // &
        & "PARAMETER_VARIABLE_ID (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(VARYING_STRING), ALLOCATABLE :: " // &
      & "PARAMETER_VARIABLE_ID(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_CELLML_MODEL_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_EQUATIONS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
  & CheckVariable32, CheckVariable33, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable31
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable32
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable33

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(FIELD_TYPE), POINTER :: NullPtr0
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr2
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr6
  TYPE(MESHES_TYPE), POINTER :: NullPtr7
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr8
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: NullPtr9
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr11
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr12
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: NullPtr13
  TYPE(CELLML_TYPE), POINTER :: NullPtr14
  TYPE(MESH_TYPE), POINTER :: NullPtr15
  TYPE(FIELDS_TYPE), POINTER :: NullPtr16
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: NullPtr17
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr18
  TYPE(NODES_TYPE), POINTER :: NullPtr19
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr20
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: NullPtr21
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr22
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: NullPtr23
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr24
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr25
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr26
  TYPE(REGION_TYPE), POINTER :: NullPtr27

  TYPE(SOLVER_TYPE), POINTER :: Ptr0

  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable19)) THEN
    Variable2 => CheckVariable19
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)

  
  ! Variable%SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CELLML_EQUATIONS_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), PROBLEM_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), SOLVER_EQUATIONS_TYPE (CheckVariable22), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), HISTORY_TYPE (CheckVariable25), DAE_SOLVER_TYPE (CheckVariable26), SOLVERS_TYPE (CheckVariable27), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable28), SOLVER_TYPE (CheckVariable29), SOLVER_MAPPING_TYPE (CheckVariable30), EULER_DAE_SOLVER_TYPE (CheckVariable31), LINEAR_SOLVER_TYPE (CheckVariable32), EIGENPROBLEM_SOLVER_TYPE (CheckVariable33), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable16
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_EQUATIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable29
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable17

    ! if variable was already followed
    Ptr0 => Variable%SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable29)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & SOLVER, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, CheckVariable3, CheckVariable4, NullPtr1, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable33, &
        & CheckVariable18, Variable2, CheckVariable20, CheckVariable21, NullPtr2, CheckVariable22, NullPtr3, &
        & CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, &
        & CheckVariable29, NullPtr4, NullPtr5, CheckVariable30, CheckVariable31, NullPtr6, CheckVariable32, &
        & CheckVariable17, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "CELLML_EQUATIONS_FINISHED:                       ", &
    & Variable%CELLML_EQUATIONS_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_CELLML_ENVIRONMENTS:   ", &
    & Variable%NUMBER_OF_CELLML_ENVIRONMENTS
  
  ! Variable%CELLML_ENVIRONMENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%CELLML_ENVIRONMENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%CELLML_ENVIRONMENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_PTR_TYPE), ALLOCATABLE :: " // &
      & "CELLML_ENVIRONMENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%CELLML_ENVIRONMENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%CELLML_ENVIRONMENTS,1), MIN(LBOUND(Variable% &
      & CELLML_ENVIRONMENTS,1)+MaxArrayLength, UBOUND(Variable%CELLML_ENVIRONMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_CELLML_PTR_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, DATA_POINTS_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_EQUATIONS_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), PROBLEM_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), SOLVER_EQUATIONS_TYPE (CheckVariable22), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), HISTORY_TYPE (CheckVariable25), DAE_SOLVER_TYPE (CheckVariable26), SOLVERS_TYPE (CheckVariable27), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable28), SOLVER_TYPE (CheckVariable29), SOLVER_MAPPING_TYPE (CheckVariable30), EULER_DAE_SOLVER_TYPE (CheckVariable31), LINEAR_SOLVER_TYPE (CheckVariable32), EIGENPROBLEM_SOLVER_TYPE (CheckVariable33), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type CELLML_MODELS_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_MODELS_FIELD_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CELLML_STATE_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_STATE_FIELD_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type CELLML_FIELD_MAPS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_FIELD_MAPS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_INTERMEDIATE_FIELD_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_PARAMETERS_FIELD_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML_ENVIRONMENTS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_CELLML_PTR_TYPE(Variable% &
          & CELLML_ENVIRONMENTS(I0), NullPtr7, NullPtr0, NullPtr8, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, &
          & NullPtr14, NullPtr15, NullPtr16, NullPtr17, NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, NullPtr23, &
          & NullPtr24, NullPtr25, NullPtr26, NullPtr27, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_PTR_TYPE), ALLOCATABLE :: " // &
      & "CELLML_ENVIRONMENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_CELLML_EQUATIONS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_NODE_PARAM_TO_DOF_MAP_NODE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_NODE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_NODE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DERIVATIVES:           ", &
    & Variable%NUMBER_OF_DERIVATIVES
  
  ! Variable%DERIVATIVES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DERIVATIVES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DERIVATIVES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE_TYPE), ALLOCATABLE :: " // &
      & "DERIVATIVES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DERIVATIVES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%DERIVATIVES,1), MIN(LBOUND(Variable%DERIVATIVES,1)+MaxArrayLength, UBOUND(Variable%DERIVATIVES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_NODE_PARAM_TO_DOF_MAP_NODE_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DERIVATIVES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE_TYPE(Variable%DERIVATIVES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE_TYPE), ALLOCATABLE :: " // &
      & "DERIVATIVES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_NODE_PARAM_TO_DOF_MAP_NODE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DecompositionElementDataPointType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DecompositionElementDataPointType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(DecompositionElementDataPointType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "userNumber:                      ", &
    & Variable%userNumber
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "globalNumber:                    ", &
    & Variable%globalNumber
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "localNumber:                     ", &
    & Variable%localNumber

  
END SUBROUTINE Print_DecompositionElementDataPointType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MATRIX_TO_VAR_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MATRIX_TO_VAR_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr1
  TYPE(MESHES_TYPE), POINTER :: NullPtr2
  TYPE(FIELDS_TYPE), POINTER :: NullPtr3
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr4
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr6
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr11
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr12
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr13
  TYPE(NODES_TYPE), POINTER :: NullPtr14
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr15
  TYPE(REGION_TYPE), POINTER :: NullPtr16
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr17


  TYPE(EQUATIONS_MATRIX_TO_VAR_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MATRIX_NUMBER:                   ", &
    & Variable%MATRIX_NUMBER
  
  ! Variable%EQUATIONS_MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRIX_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRIX " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRIX_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MATRIX_TO_VAR_MAP_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MATRIX"
      CALL Print_EQUATIONS_MATRIX_TYPE(Variable%EQUATIONS_MATRIX, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRIX_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "VARIABLE_TYPE:                   ", &
    & Variable%VARIABLE_TYPE
  
  ! Variable%VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRIX_TO_VAR_MAP_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & VARIABLE, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COLUMNS:               ", &
    & Variable%NUMBER_OF_COLUMNS
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "MATRIX_COEFFICIENT:          ", &
    & Variable%MATRIX_COEFFICIENT
  
  ! Variable%COLUMN_TO_DOF_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COLUMN_TO_DOF_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COLUMN_TO_DOF_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLUMN_TO_DOF_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COLUMN_TO_DOF_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COLUMN_TO_DOF_MAP,1), MIN(LBOUND(Variable%COLUMN_TO_DOF_MAP,1)+MaxArrayLength, UBOUND(Variable% &
      & COLUMN_TO_DOF_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COLUMN_TO_DOF_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLUMN_TO_DOF_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COLUMN_DOFS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%COLUMN_DOFS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "COLUMN_DOFS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MATRIX_TO_VAR_MAP_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"COLUMN_DOFS_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%COLUMN_DOFS_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "COLUMN_DOFS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_MATRIX_TO_VAR_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_MAPPING_CREATE_VALUES_CACHE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(INTERFACE_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_INTERFACE_MATRICES:    ", &
    & Variable%NUMBER_OF_INTERFACE_MATRICES
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LAGRANGE_VARIABLE_TYPE:          ", &
    & Variable%LAGRANGE_VARIABLE_TYPE
  
  ! Variable%MATRIX_COEFFICIENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MATRIX_COEFFICIENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MATRIX_COEFFICIENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "MATRIX_COEFFICIENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MATRIX_COEFFICIENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%MATRIX_COEFFICIENTS,1), MIN(LBOUND(Variable% &
      & MATRIX_COEFFICIENTS,1)+MaxArrayLength, UBOUND(Variable%MATRIX_COEFFICIENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%MATRIX_COEFFICIENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "MATRIX_COEFFICIENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%HAS_TRANSPOSE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%HAS_TRANSPOSE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%HAS_TRANSPOSE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "HAS_TRANSPOSE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%HAS_TRANSPOSE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%HAS_TRANSPOSE,1), MIN(LBOUND(Variable%HAS_TRANSPOSE,1)+MaxArrayLength, UBOUND(Variable%HAS_TRANSPOSE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%HAS_TRANSPOSE(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "HAS_TRANSPOSE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%MATRIX_ROW_FIELD_VARIABLE_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MATRIX_ROW_FIELD_VARIABLE_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MATRIX_ROW_FIELD_VARIABLE_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "MATRIX_ROW_FIELD_VARIABLE_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MATRIX_ROW_FIELD_VARIABLE_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%MATRIX_ROW_FIELD_VARIABLE_INDICES,1), MIN(LBOUND(Variable% &
      & MATRIX_ROW_FIELD_VARIABLE_INDICES,1)+MaxArrayLength, UBOUND(Variable%MATRIX_ROW_FIELD_VARIABLE_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%MATRIX_ROW_FIELD_VARIABLE_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "MATRIX_ROW_FIELD_VARIABLE_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%MATRIX_COL_FIELD_VARIABLE_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MATRIX_COL_FIELD_VARIABLE_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MATRIX_COL_FIELD_VARIABLE_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "MATRIX_COL_FIELD_VARIABLE_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MATRIX_COL_FIELD_VARIABLE_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%MATRIX_COL_FIELD_VARIABLE_INDICES,1), MIN(LBOUND(Variable% &
      & MATRIX_COL_FIELD_VARIABLE_INDICES,1)+MaxArrayLength, UBOUND(Variable%MATRIX_COL_FIELD_VARIABLE_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%MATRIX_COL_FIELD_VARIABLE_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "MATRIX_COL_FIELD_VARIABLE_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "RHS_LAGRANGE_VARIABLE_TYPE:      ", &
    & Variable%RHS_LAGRANGE_VARIABLE_TYPE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "RHS_COEFFICIENT:             ", &
    & Variable%RHS_COEFFICIENT

  
END SUBROUTINE Print_INTERFACE_MAPPING_CREATE_VALUES_CACHE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_NEWTON_TRUSTREGION_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16

  ! iterator variables

  ! null pointers
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr0
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr3
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr4
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr5
  TYPE(HISTORY_TYPE), POINTER :: NullPtr6

  TYPE(NEWTON_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable13)) THEN
    Variable2 => CheckVariable13
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%NEWTON_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NEWTON_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NEWTON_SOLVER_TYPE), POINTER :: " // &
      & "NEWTON_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_NEWTON_SOLVER_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, PROBLEM_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, LINEAR_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: NEWTON_TRUSTREGION_SOLVER_TYPE (Variable)
! Available CheckVariables are: QUASI_NEWTON_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), CELLML_EQUATIONS_TYPE (CheckVariable2), DAE_SOLVER_TYPE (CheckVariable3), SOLVERS_TYPE (CheckVariable4), NEWTON_SOLVER_TYPE (CheckVariable5), SOLVER_TYPE (CheckVariable6), LINEAR_SOLVER_TYPE (CheckVariable7), SOLVER_EQUATIONS_TYPE (CheckVariable8), OPTIMISER_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_TYPE (CheckVariable10), DYNAMIC_SOLVER_TYPE (CheckVariable11), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable12), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable13), EIGENPROBLEM_SOLVER_TYPE (CheckVariable14), GeometricTransformationSolverType (CheckVariable15), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable16), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable5
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable15
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr0 => Variable%NEWTON_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NEWTON_SOLVER"
      CALL Print_NEWTON_SOLVER_TYPE(Variable% &
        & NEWTON_SOLVER, NullPtr0, CheckVariable16, CheckVariable0, CheckVariable1, CheckVariable5, NullPtr1, NullPtr2, &
        & CheckVariable9, NullPtr3, CheckVariable11, CheckVariable12, CheckVariable15, NullPtr4, CheckVariable2, &
        & CheckVariable10, CheckVariable8, Variable2, NullPtr5, NullPtr6, CheckVariable3, CheckVariable4, CheckVariable6, &
        & CheckVariable7, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NEWTON_SOLVER_TYPE), POINTER :: " // &
      & "NEWTON_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRICES_LIBRARY:         ", &
    & Variable%SOLVER_MATRICES_LIBRARY
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "TRUSTREGION_TOLERANCE:       ", &
    & Variable%TRUSTREGION_TOLERANCE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "TRUSTREGION_DELTA0:          ", &
    & Variable%TRUSTREGION_DELTA0

  
END SUBROUTINE Print_NEWTON_TRUSTREGION_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_SET_SETUP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_SET_SETUP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_TYPE), POINTER :: NullPtr4
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr5
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr6
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr8
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr9
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr10
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr11
  TYPE(CELLML_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr13
  TYPE(MESH_TYPE), POINTER :: NullPtr14
  TYPE(FIELDS_TYPE), POINTER :: NullPtr15
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr16
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr17
  TYPE(NODES_TYPE), POINTER :: NullPtr18
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr19
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr20
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr21
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr23
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr24
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr25
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr26
  TYPE(REGION_TYPE), POINTER :: NullPtr27


  TYPE(EQUATIONS_SET_SETUP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SETUP_TYPE:                      ", &
    & Variable%SETUP_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ACTION_TYPE:                     ", &
    & Variable%ACTION_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "FIELD_USER_NUMBER:               ", &
    & Variable%FIELD_USER_NUMBER
  
  ! Variable%FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_SETUP_TYPE (Variable)
! Available CheckVariables are: 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & FIELD, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, NullPtr18, NullPtr19, &
        & NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ANALYTIC_FUNCTION_TYPE:          ", &
    & Variable%ANALYTIC_FUNCTION_TYPE

  
END SUBROUTINE Print_EQUATIONS_SET_SETUP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_RHS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(INTERFACE_RHS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(INTERFACE_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2

  ! iterator variables

  ! null pointers
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_MAPPING_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr6
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: NullPtr7
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr8
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: NullPtr9

  TYPE(INTERFACE_MATRICES_TYPE), POINTER :: Ptr0

  TYPE(INTERFACE_RHS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  
  ! Variable%INTERFACE_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MATRICES_TYPE), POINTER :: " // &
      & "INTERFACE_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_MATRICES_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, INTERFACE_EQUATIONS_TYPE, INTERFACE_CONDITIONS_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_EQUATIONS_TYPE, INTERFACE_RHS_TYPE, FIELD_TYPE, INTERFACE_MAPPING_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: INTERFACE_RHS_TYPE (Variable)
! Available CheckVariables are: SOLVER_MAPPING_TYPE (CheckVariable0), INTERFACE_MATRICES_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type INTERFACE_RHS_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACE_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MAPPING_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE

    ! if variable was already followed
    Ptr0 => Variable%INTERFACE_MATRICES
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_MATRICES"
      CALL Print_INTERFACE_MATRICES_TYPE(Variable% &
        & INTERFACE_MATRICES, NullPtr0, CheckVariable2, NullPtr1, NullPtr2, CheckVariable0, NullPtr3, Variable2, NullPtr4, &
        & NullPtr5, NullPtr6, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MATRICES_TYPE), POINTER :: " // &
      & "INTERFACE_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "UPDATE_VECTOR:                                   ", &
    & Variable%UPDATE_VECTOR
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "FIRST_ASSEMBLY:                                  ", &
    & Variable%FIRST_ASSEMBLY
  
  ! Variable%RHS_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RHS_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "RHS_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: INTERFACE_RHS_TYPE (Variable)
! Available CheckVariables are: SOLVER_MAPPING_TYPE (CheckVariable0), INTERFACE_MATRICES_TYPE (CheckVariable1), INTERFACE_EQUATIONS_TYPE (CheckVariable2), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RHS_VECTOR"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%RHS_VECTOR, NullPtr7, NullPtr8, NullPtr9, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "RHS_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_RHS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MESH_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MeshComponentTopologyType), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable31

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr0
  TYPE(CELLML_TYPE), POINTER :: NullPtr1
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr4
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr6
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr7
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr8
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: NullPtr9
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: NullPtr10
  TYPE(DecompositionDataPointsType), POINTER :: NullPtr11
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: NullPtr12

  TYPE(MESHES_TYPE), POINTER :: Ptr0
  TYPE(REGION_TYPE), POINTER :: Ptr1
  TYPE(INTERFACE_TYPE), POINTER :: Ptr2
  TYPE(GENERATED_MESH_TYPE), POINTER :: Ptr3
  TYPE(MESH_TYPE), POINTER :: Ptr4
  TYPE(MESH_PTR_TYPE), POINTER :: Ptr5
  TYPE(MeshComponentTopologyPtrType), POINTER :: Ptr6
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: Ptr7

  TYPE(MESH_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable18)) THEN
    Variable2 => CheckVariable18
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "MESH_FINISHED:                                   ", &
    & Variable%MESH_FINISHED
  
  ! Variable%MESHES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MESHES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESHES_TYPE), POINTER :: " // &
      & "MESHES " // &
      & "(associated): " 
  
! Signature of Print_MESHES_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), FIELD_PTR_TYPE (CheckVariable7), GENERATED_MESH_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), MeshComponentTopologyPtrType (CheckVariable10), InterfacePointsConnectivityType (CheckVariable11), INTERFACE_TYPE (CheckVariable12), DOMAIN_TYPE (CheckVariable13), INTERFACE_PTR_TYPE (CheckVariable14), REGION_PTR_TYPE (CheckVariable15), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable16), CELLML_ENVIRONMENTS_TYPE (CheckVariable17), MESH_TYPE (CheckVariable18), DECOMPOSITION_PTR_TYPE (CheckVariable19), FIELDS_TYPE (CheckVariable20), GENERATED_MESHES_TYPE (CheckVariable21), DECOMPOSITIONS_TYPE (CheckVariable22), NODES_TYPE (CheckVariable23), DOMAIN_PTR_TYPE (CheckVariable24), INTERFACES_TYPE (CheckVariable25), DATA_POINTS_TYPE (CheckVariable26), GENERATED_MESH_PTR_TYPE (CheckVariable27), DATA_PROJECTION_TYPE (CheckVariable28), GENERATED_MESH_REGULAR_TYPE (CheckVariable29), DECOMPOSITION_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable11
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable10
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable31

    ! if variable was already followed
    Ptr0 => Variable%MESHES
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MESHES"
      CALL Print_MESHES_TYPE(Variable% &
        & MESHES, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable7, CheckVariable8, CheckVariable9, &
        & CheckVariable15, CheckVariable11, NullPtr0, CheckVariable12, CheckVariable14, CheckVariable16, CheckVariable17, &
        & NullPtr1, NullPtr2, Variable2, CheckVariable10, CheckVariable20, CheckVariable21, CheckVariable22, &
        & CheckVariable23, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable30, NullPtr3, &
        & CheckVariable31, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESHES_TYPE), POINTER :: " // &
      & "MESHES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), FIELD_PTR_TYPE (CheckVariable7), GENERATED_MESH_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), MeshComponentTopologyPtrType (CheckVariable10), InterfacePointsConnectivityType (CheckVariable11), INTERFACE_TYPE (CheckVariable12), DOMAIN_TYPE (CheckVariable13), INTERFACE_PTR_TYPE (CheckVariable14), REGION_PTR_TYPE (CheckVariable15), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable16), CELLML_ENVIRONMENTS_TYPE (CheckVariable17), MESH_TYPE (CheckVariable18), DECOMPOSITION_PTR_TYPE (CheckVariable19), FIELDS_TYPE (CheckVariable20), GENERATED_MESHES_TYPE (CheckVariable21), DECOMPOSITIONS_TYPE (CheckVariable22), NODES_TYPE (CheckVariable23), DOMAIN_PTR_TYPE (CheckVariable24), INTERFACES_TYPE (CheckVariable25), DATA_POINTS_TYPE (CheckVariable26), GENERATED_MESH_PTR_TYPE (CheckVariable27), DATA_PROJECTION_TYPE (CheckVariable28), GENERATED_MESH_REGULAR_TYPE (CheckVariable29), DECOMPOSITION_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable11
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable31

    ! if variable was already followed
    Ptr1 => Variable%REGION
    IF (ASSOCIATED(Ptr1, CheckVariable31)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, CheckVariable1, CheckVariable3, CheckVariable4, NullPtr4, CheckVariable7, CheckVariable8, CheckVariable9, &
        & CheckVariable15, CheckVariable11, NullPtr0, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable16, &
        & CheckVariable17, NullPtr5, NullPtr1, Variable2, CheckVariable20, CheckVariable21, CheckVariable22, &
        & CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, NullPtr6, &
        & CheckVariable30, NullPtr3, NullPtr7, CheckVariable31, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), FIELD_PTR_TYPE (CheckVariable7), GENERATED_MESH_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), MeshComponentTopologyPtrType (CheckVariable10), InterfacePointsConnectivityType (CheckVariable11), INTERFACE_TYPE (CheckVariable12), DOMAIN_TYPE (CheckVariable13), INTERFACE_PTR_TYPE (CheckVariable14), REGION_PTR_TYPE (CheckVariable15), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable16), CELLML_ENVIRONMENTS_TYPE (CheckVariable17), MESH_TYPE (CheckVariable18), DECOMPOSITION_PTR_TYPE (CheckVariable19), FIELDS_TYPE (CheckVariable20), GENERATED_MESHES_TYPE (CheckVariable21), DECOMPOSITIONS_TYPE (CheckVariable22), NODES_TYPE (CheckVariable23), DOMAIN_PTR_TYPE (CheckVariable24), INTERFACES_TYPE (CheckVariable25), DATA_POINTS_TYPE (CheckVariable26), GENERATED_MESH_PTR_TYPE (CheckVariable27), DATA_PROJECTION_TYPE (CheckVariable28), GENERATED_MESH_REGULAR_TYPE (CheckVariable29), DECOMPOSITION_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable11
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable10
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable31

    ! if variable was already followed
    Ptr2 => Variable%INTERFACE
    IF (ASSOCIATED(Ptr2, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE"
      CALL Print_INTERFACE_TYPE(Variable% &
        & INTERFACE, NullPtr8, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable7, CheckVariable8, &
        & CheckVariable9, CheckVariable15, CheckVariable11, NullPtr0, CheckVariable12, CheckVariable14, CheckVariable16, &
        & CheckVariable17, NullPtr5, NullPtr2, Variable2, CheckVariable10, CheckVariable20, CheckVariable21, &
        & CheckVariable22, CheckVariable23, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, NullPtr6, &
        & CheckVariable30, NullPtr7, CheckVariable31, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%GENERATED_MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GENERATED_MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GENERATED_MESH_TYPE), POINTER :: " // &
      & "GENERATED_MESH " // &
      & "(associated): " 
  
! Signature of Print_GENERATED_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, DECOMPOSITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), FIELD_PTR_TYPE (CheckVariable7), GENERATED_MESH_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), MeshComponentTopologyPtrType (CheckVariable10), InterfacePointsConnectivityType (CheckVariable11), INTERFACE_TYPE (CheckVariable12), DOMAIN_TYPE (CheckVariable13), INTERFACE_PTR_TYPE (CheckVariable14), REGION_PTR_TYPE (CheckVariable15), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable16), CELLML_ENVIRONMENTS_TYPE (CheckVariable17), MESH_TYPE (CheckVariable18), DECOMPOSITION_PTR_TYPE (CheckVariable19), FIELDS_TYPE (CheckVariable20), GENERATED_MESHES_TYPE (CheckVariable21), DECOMPOSITIONS_TYPE (CheckVariable22), NODES_TYPE (CheckVariable23), DOMAIN_PTR_TYPE (CheckVariable24), INTERFACES_TYPE (CheckVariable25), DATA_POINTS_TYPE (CheckVariable26), GENERATED_MESH_PTR_TYPE (CheckVariable27), DATA_PROJECTION_TYPE (CheckVariable28), GENERATED_MESH_REGULAR_TYPE (CheckVariable29), DECOMPOSITION_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MeshComponentTopologyType
!   matches available passing type, use it as CheckVariable0
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type GENERATED_MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable10
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type GENERATED_MESH_REGULAR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable31

    ! if variable was already followed
    Ptr3 => Variable%GENERATED_MESH
    IF (ASSOCIATED(Ptr3, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GENERATED_MESH"
      CALL Print_GENERATED_MESH_TYPE(Variable% &
        & GENERATED_MESH, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable15, CheckVariable11, CheckVariable12, &
        & CheckVariable16, CheckVariable17, CheckVariable19, Variable2, CheckVariable10, CheckVariable20, CheckVariable21, &
        & CheckVariable22, CheckVariable23, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, &
        & CheckVariable29, CheckVariable30, CheckVariable31, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GENERATED_MESH_TYPE), POINTER :: " // &
      & "GENERATED_MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DIMENSIONS:            ", &
    & Variable%NUMBER_OF_DIMENSIONS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COMPONENTS:            ", &
    & Variable%NUMBER_OF_COMPONENTS
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "MESH_EMBEDDED:                                   ", &
    & Variable%MESH_EMBEDDED
  
  ! Variable%EMBEDDING_MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EMBEDDING_MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_TYPE), POINTER :: " // &
      & "EMBEDDING_MESH " // &
      & "(associated): " 
  
! Signature of Print_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, REGION_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), FIELD_PTR_TYPE (CheckVariable7), GENERATED_MESH_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), MeshComponentTopologyPtrType (CheckVariable10), InterfacePointsConnectivityType (CheckVariable11), INTERFACE_TYPE (CheckVariable12), DOMAIN_TYPE (CheckVariable13), INTERFACE_PTR_TYPE (CheckVariable14), REGION_PTR_TYPE (CheckVariable15), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable16), CELLML_ENVIRONMENTS_TYPE (CheckVariable17), MESH_TYPE (CheckVariable18), DECOMPOSITION_PTR_TYPE (CheckVariable19), FIELDS_TYPE (CheckVariable20), GENERATED_MESHES_TYPE (CheckVariable21), DECOMPOSITIONS_TYPE (CheckVariable22), NODES_TYPE (CheckVariable23), DOMAIN_PTR_TYPE (CheckVariable24), INTERFACES_TYPE (CheckVariable25), DATA_POINTS_TYPE (CheckVariable26), GENERATED_MESH_PTR_TYPE (CheckVariable27), DATA_PROJECTION_TYPE (CheckVariable28), GENERATED_MESH_REGULAR_TYPE (CheckVariable29), DECOMPOSITION_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MeshComponentTopologyType
!   matches available passing type, use it as CheckVariable0
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable10
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type GENERATED_MESH_REGULAR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable31

    ! if variable was already followed
    Ptr4 => Variable%EMBEDDING_MESH
    IF (ASSOCIATED(Ptr4, CheckVariable18)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EMBEDDING_MESH"
      CALL Print_MESH_TYPE(Variable% &
        & EMBEDDING_MESH, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, Variable2, &
        & CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
        & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, &
        & CheckVariable31, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_TYPE), POINTER :: " // &
      & "EMBEDDING_MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_EMBEDDED_MESHES:       ", &
    & Variable%NUMBER_OF_EMBEDDED_MESHES
  
  ! Variable%EMBEDDED_MESHES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%EMBEDDED_MESHES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_PTR_TYPE), POINTER :: " // &
      & "EMBEDDED_MESHES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%EMBEDDED_MESHES,1), "): "
  
    DO I0 = LBOUND(Variable%EMBEDDED_MESHES,1), MIN(LBOUND(Variable%EMBEDDED_MESHES,1)+MaxArrayLength, UBOUND(Variable% &
      & EMBEDDED_MESHES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_MESH_PTR_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, DECOMPOSITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), FIELD_PTR_TYPE (CheckVariable7), GENERATED_MESH_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), MeshComponentTopologyPtrType (CheckVariable10), InterfacePointsConnectivityType (CheckVariable11), INTERFACE_TYPE (CheckVariable12), DOMAIN_TYPE (CheckVariable13), INTERFACE_PTR_TYPE (CheckVariable14), REGION_PTR_TYPE (CheckVariable15), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable16), CELLML_ENVIRONMENTS_TYPE (CheckVariable17), MESH_TYPE (CheckVariable18), DECOMPOSITION_PTR_TYPE (CheckVariable19), FIELDS_TYPE (CheckVariable20), GENERATED_MESHES_TYPE (CheckVariable21), DECOMPOSITIONS_TYPE (CheckVariable22), NODES_TYPE (CheckVariable23), DOMAIN_PTR_TYPE (CheckVariable24), INTERFACES_TYPE (CheckVariable25), DATA_POINTS_TYPE (CheckVariable26), GENERATED_MESH_PTR_TYPE (CheckVariable27), DATA_PROJECTION_TYPE (CheckVariable28), GENERATED_MESH_REGULAR_TYPE (CheckVariable29), DECOMPOSITION_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MeshComponentTopologyType
!   matches available passing type, use it as CheckVariable0
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable3
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable10
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable31

      ! if variable was already followed
      Ptr5 => Variable%EMBEDDED_MESHES(I0)
      IF (ASSOCIATED(Ptr5, CheckVariable3)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EMBEDDED_MESHES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_MESH_PTR_TYPE(Variable% &
          & EMBEDDED_MESHES(I0), CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable7, &
          & CheckVariable8, CheckVariable9, CheckVariable15, CheckVariable11, CheckVariable12, CheckVariable14, &
          & CheckVariable16, CheckVariable17, CheckVariable19, Variable2, CheckVariable10, CheckVariable20, &
          & CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable25, CheckVariable26, CheckVariable28, &
          & CheckVariable30, CheckVariable31, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_PTR_TYPE), POINTER :: " // &
      & "EMBEDDED_MESHES(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ELEMENTS:              ", &
    & Variable%NUMBER_OF_ELEMENTS
  
  ! Variable%TOPOLOGY(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%TOPOLOGY)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshComponentTopologyPtrType), POINTER :: " // &
      & "TOPOLOGY(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%TOPOLOGY,1), "): "
  
    DO I0 = LBOUND(Variable%TOPOLOGY,1), MIN(LBOUND(Variable%TOPOLOGY,1)+MaxArrayLength, UBOUND(Variable%TOPOLOGY,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_MeshComponentTopologyPtrType has the following CheckVariable types: DATA_PROJECTION_TYPE, MESH_TYPE, MeshComponentTopologyType, MESHES_TYPE, MESH_PTR_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, MeshComponentTopologyPtrType, REGION_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, DECOMPOSITIONS_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, 
! The type to handle in this routine is: MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), FIELD_PTR_TYPE (CheckVariable7), GENERATED_MESH_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), MeshComponentTopologyPtrType (CheckVariable10), InterfacePointsConnectivityType (CheckVariable11), INTERFACE_TYPE (CheckVariable12), DOMAIN_TYPE (CheckVariable13), INTERFACE_PTR_TYPE (CheckVariable14), REGION_PTR_TYPE (CheckVariable15), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable16), CELLML_ENVIRONMENTS_TYPE (CheckVariable17), MESH_TYPE (CheckVariable18), DECOMPOSITION_PTR_TYPE (CheckVariable19), FIELDS_TYPE (CheckVariable20), GENERATED_MESHES_TYPE (CheckVariable21), DECOMPOSITIONS_TYPE (CheckVariable22), NODES_TYPE (CheckVariable23), DOMAIN_PTR_TYPE (CheckVariable24), INTERFACES_TYPE (CheckVariable25), DATA_POINTS_TYPE (CheckVariable26), GENERATED_MESH_PTR_TYPE (CheckVariable27), DATA_PROJECTION_TYPE (CheckVariable28), GENERATED_MESH_REGULAR_TYPE (CheckVariable29), DECOMPOSITION_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type MeshComponentTopologyType
!   matches available passing type, use it as CheckVariable0
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type MeshComponentTopologyPtrType
!   matches available passing type (and equals subtype), use it as CheckVariable10
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable12

      ! if variable was already followed
      Ptr6 => Variable%TOPOLOGY(I0)
      IF (ASSOCIATED(Ptr6, CheckVariable10)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TOPOLOGY("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_MeshComponentTopologyPtrType(Variable% &
          & TOPOLOGY(I0), CheckVariable28, Variable2, CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable20, &
          & CheckVariable30, CheckVariable10, CheckVariable31, CheckVariable16, CheckVariable8, CheckVariable9, &
          & CheckVariable22, CheckVariable11, CheckVariable12, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshComponentTopologyPtrType), POINTER :: " // &
      & "TOPOLOGY(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DECOMPOSITIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DECOMPOSITIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITIONS_TYPE), POINTER :: " // &
      & "DECOMPOSITIONS " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITIONS_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESH_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), GENERATED_MESH_CYLINDER_TYPE (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), INTERFACE_CONDITIONS_TYPE (CheckVariable4), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable5), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable6), FIELD_PTR_TYPE (CheckVariable7), GENERATED_MESH_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), MeshComponentTopologyPtrType (CheckVariable10), InterfacePointsConnectivityType (CheckVariable11), INTERFACE_TYPE (CheckVariable12), DOMAIN_TYPE (CheckVariable13), INTERFACE_PTR_TYPE (CheckVariable14), REGION_PTR_TYPE (CheckVariable15), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable16), CELLML_ENVIRONMENTS_TYPE (CheckVariable17), MESH_TYPE (CheckVariable18), DECOMPOSITION_PTR_TYPE (CheckVariable19), FIELDS_TYPE (CheckVariable20), GENERATED_MESHES_TYPE (CheckVariable21), DECOMPOSITIONS_TYPE (CheckVariable22), NODES_TYPE (CheckVariable23), DOMAIN_PTR_TYPE (CheckVariable24), INTERFACES_TYPE (CheckVariable25), DATA_POINTS_TYPE (CheckVariable26), GENERATED_MESH_PTR_TYPE (CheckVariable27), DATA_PROJECTION_TYPE (CheckVariable28), GENERATED_MESH_REGULAR_TYPE (CheckVariable29), DECOMPOSITION_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MeshComponentTopologyType
!   matches available passing type, use it as CheckVariable0
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable10
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DECOMPOSITION_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_FACES_TYPE
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_ELEMENTS_TYPE
! - signature type MESH_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable22
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type DecompositionDataPointsType
!   is not available in passing variables, use NullPtr of type DecompositionDataPointsType
! - signature type DECOMPOSITION_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_LINES_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable31

    ! if variable was already followed
    Ptr7 => Variable%DECOMPOSITIONS
    IF (ASSOCIATED(Ptr7, CheckVariable22)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DECOMPOSITIONS"
      CALL Print_DECOMPOSITIONS_TYPE(Variable% &
        & DECOMPOSITIONS, CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable6, CheckVariable7, &
        & CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, &
        & CheckVariable16, NullPtr9, NullPtr10, Variable2, CheckVariable19, CheckVariable20, CheckVariable21, &
        & CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable26, CheckVariable28, CheckVariable30, NullPtr11, &
        & NullPtr12, CheckVariable31, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITIONS_TYPE), POINTER :: " // &
      & "DECOMPOSITIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "SURROUNDING_ELEMENTS_CALCULATE:                  ", &
    & Variable%SURROUNDING_ELEMENTS_CALCULATE

  
END SUBROUTINE Print_MESH_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_SET_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EquationsSetDerivedType), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable28

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr2
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr3
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr4
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_TYPE), POINTER :: NullPtr8
  TYPE(MESH_TYPE), POINTER :: NullPtr9
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr11
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr12
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr13
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr14
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr15
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: NullPtr16
  TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: NullPtr17
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr18
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr19
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr20
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr21
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr22
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr23
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr24
  TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER :: NullPtr25
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr26
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr27
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr28

  TYPE(EQUATIONS_SETS_TYPE), POINTER :: Ptr0
  TYPE(REGION_TYPE), POINTER :: Ptr1
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: Ptr2
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: Ptr3
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: Ptr4
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: Ptr5
  TYPE(EquationsSetDerivedType), POINTER :: Ptr6
  TYPE(EQUATIONS_TYPE), POINTER :: Ptr7
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: Ptr8

  TYPE(EQUATIONS_SET_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable10)) THEN
    Variable2 => CheckVariable10
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "EQUATIONS_SET_FINISHED:                          ", &
    & Variable%EQUATIONS_SET_FINISHED
  
  ! Variable%EQUATIONS_SETS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SETS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SETS_TYPE), POINTER :: " // &
      & "EQUATIONS_SETS " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SETS_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, EQUATIONS_SET_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, INTERFACES_TYPE, EQUATIONS_SET_PTR_TYPE, GENERATED_MESHES_TYPE, FIELD_TYPE, CONTROL_LOOP_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), FIELD_TYPE (CheckVariable3), REGION_PTR_TYPE (CheckVariable4), EQUATIONS_SETS_TYPE (CheckVariable5), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CONTROL_LOOP_TYPE (CheckVariable9), EQUATIONS_SET_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), INTERFACES_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), DATA_PROJECTION_TYPE (CheckVariable17), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), EQUATIONS_SET_SOURCE_TYPE (CheckVariable22), SOLVER_MAPPING_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable28), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type EQUATIONS_SET_TYPE
!   is type of this print routine, use Variable2
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable5
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable16

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_SETS
    IF (ASSOCIATED(Ptr0, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SETS"
      CALL Print_EQUATIONS_SETS_TYPE(Variable% &
        & EQUATIONS_SETS, CheckVariable17, Variable2, CheckVariable1, CheckVariable12, CheckVariable20, CheckVariable4, &
        & CheckVariable15, CheckVariable25, CheckVariable13, CheckVariable3, CheckVariable9, CheckVariable7, &
        & CheckVariable8, CheckVariable14, CheckVariable5, CheckVariable27, CheckVariable16, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SETS_TYPE), POINTER :: " // &
      & "EQUATIONS_SETS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), FIELD_TYPE (CheckVariable3), REGION_PTR_TYPE (CheckVariable4), EQUATIONS_SETS_TYPE (CheckVariable5), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CONTROL_LOOP_TYPE (CheckVariable9), EQUATIONS_SET_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), INTERFACES_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), DATA_PROJECTION_TYPE (CheckVariable17), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), EQUATIONS_SET_SOURCE_TYPE (CheckVariable22), SOLVER_MAPPING_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable28), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is type of this print routine, use Variable2
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable27

    ! if variable was already followed
    Ptr1 => Variable%REGION
    IF (ASSOCIATED(Ptr1, CheckVariable27)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, CheckVariable1, NullPtr0, NullPtr1, Variable2, NullPtr2, NullPtr3, CheckVariable3, CheckVariable4, &
        & NullPtr4, CheckVariable5, CheckVariable7, NullPtr5, NullPtr6, NullPtr7, CheckVariable8, CheckVariable9, NullPtr8, &
        & NullPtr9, CheckVariable12, CheckVariable13, NullPtr10, CheckVariable14, NullPtr11, CheckVariable15, &
        & CheckVariable16, NullPtr12, CheckVariable17, NullPtr13, CheckVariable20, CheckVariable25, NullPtr14, &
        & CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SPECIFICATION(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SPECIFICATION)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SPECIFICATION),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "SPECIFICATION(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SPECIFICATION, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SPECIFICATION,1), MIN(LBOUND(Variable%SPECIFICATION,1)+MaxArrayLength, UBOUND(Variable%SPECIFICATION,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SPECIFICATION(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "SPECIFICATION(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLUTION_METHOD:                 ", &
    & Variable%SOLUTION_METHOD
  
  ! Variable%MATERIALS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MATERIALS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: " // &
      & "MATERIALS " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_MATERIALS_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), FIELD_TYPE (CheckVariable3), REGION_PTR_TYPE (CheckVariable4), EQUATIONS_SETS_TYPE (CheckVariable5), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CONTROL_LOOP_TYPE (CheckVariable9), EQUATIONS_SET_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), INTERFACES_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), DATA_PROJECTION_TYPE (CheckVariable17), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), EQUATIONS_SET_SOURCE_TYPE (CheckVariable22), SOLVER_MAPPING_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable28), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is type of this print routine, use Variable2
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable28

    ! if variable was already followed
    Ptr2 => Variable%MATERIALS
    IF (ASSOCIATED(Ptr2, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATERIALS"
      CALL Print_EQUATIONS_SET_MATERIALS_TYPE(Variable% &
        & MATERIALS, CheckVariable17, CheckVariable0, Variable2, CheckVariable2, CheckVariable18, CheckVariable12, &
        & CheckVariable20, CheckVariable22, CheckVariable6, CheckVariable7, CheckVariable25, CheckVariable26, &
        & CheckVariable3, CheckVariable5, CheckVariable27, CheckVariable28, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: " // &
      & "MATERIALS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOURCE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOURCE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: " // &
      & "SOURCE " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_SOURCE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), FIELD_TYPE (CheckVariable3), REGION_PTR_TYPE (CheckVariable4), EQUATIONS_SETS_TYPE (CheckVariable5), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CONTROL_LOOP_TYPE (CheckVariable9), EQUATIONS_SET_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), INTERFACES_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), DATA_PROJECTION_TYPE (CheckVariable17), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), EQUATIONS_SET_SOURCE_TYPE (CheckVariable22), SOLVER_MAPPING_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable28), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is type of this print routine, use Variable2
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable22
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable28

    ! if variable was already followed
    Ptr3 => Variable%SOURCE
    IF (ASSOCIATED(Ptr3, CheckVariable22)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOURCE"
      CALL Print_EQUATIONS_SET_SOURCE_TYPE(Variable% &
        & SOURCE, CheckVariable17, CheckVariable0, Variable2, CheckVariable2, CheckVariable18, CheckVariable12, &
        & CheckVariable20, CheckVariable22, CheckVariable6, CheckVariable7, CheckVariable25, CheckVariable26, &
        & CheckVariable3, CheckVariable5, CheckVariable27, CheckVariable28, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: " // &
      & "SOURCE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INDEPENDENT
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INDEPENDENT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: " // &
      & "INDEPENDENT " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_INDEPENDENT_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), FIELD_TYPE (CheckVariable3), REGION_PTR_TYPE (CheckVariable4), EQUATIONS_SETS_TYPE (CheckVariable5), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CONTROL_LOOP_TYPE (CheckVariable9), EQUATIONS_SET_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), INTERFACES_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), DATA_PROJECTION_TYPE (CheckVariable17), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), EQUATIONS_SET_SOURCE_TYPE (CheckVariable22), SOLVER_MAPPING_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable28), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is type of this print routine, use Variable2
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable28

    ! if variable was already followed
    Ptr4 => Variable%INDEPENDENT
    IF (ASSOCIATED(Ptr4, CheckVariable28)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INDEPENDENT"
      CALL Print_EQUATIONS_SET_INDEPENDENT_TYPE(Variable% &
        & INDEPENDENT, CheckVariable17, CheckVariable0, Variable2, CheckVariable2, CheckVariable18, CheckVariable12, &
        & CheckVariable20, CheckVariable22, CheckVariable6, CheckVariable7, CheckVariable25, CheckVariable26, &
        & CheckVariable3, CheckVariable5, CheckVariable27, CheckVariable28, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: " // &
      & "INDEPENDENT (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%ANALYTIC
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ANALYTIC)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: " // &
      & "ANALYTIC " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_ANALYTIC_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), FIELD_TYPE (CheckVariable3), REGION_PTR_TYPE (CheckVariable4), EQUATIONS_SETS_TYPE (CheckVariable5), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CONTROL_LOOP_TYPE (CheckVariable9), EQUATIONS_SET_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), INTERFACES_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), DATA_PROJECTION_TYPE (CheckVariable17), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), EQUATIONS_SET_SOURCE_TYPE (CheckVariable22), SOLVER_MAPPING_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable28), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is type of this print routine, use Variable2
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable18
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable28

    ! if variable was already followed
    Ptr5 => Variable%ANALYTIC
    IF (ASSOCIATED(Ptr5, CheckVariable18)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ANALYTIC"
      CALL Print_EQUATIONS_SET_ANALYTIC_TYPE(Variable% &
        & ANALYTIC, CheckVariable17, CheckVariable0, Variable2, CheckVariable2, CheckVariable18, CheckVariable12, &
        & CheckVariable20, CheckVariable22, CheckVariable6, CheckVariable7, CheckVariable25, CheckVariable26, &
        & CheckVariable3, CheckVariable5, CheckVariable27, CheckVariable28, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: " // &
      & "ANALYTIC (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%derived
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%derived)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EquationsSetDerivedType), POINTER :: " // &
      & "derived " // &
      & "(associated): " 
  
! Signature of Print_EquationsSetDerivedType has the following CheckVariable types: DATA_PROJECTION_TYPE, EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), FIELD_TYPE (CheckVariable3), REGION_PTR_TYPE (CheckVariable4), EQUATIONS_SETS_TYPE (CheckVariable5), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CONTROL_LOOP_TYPE (CheckVariable9), EQUATIONS_SET_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), INTERFACES_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), DATA_PROJECTION_TYPE (CheckVariable17), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), EQUATIONS_SET_SOURCE_TYPE (CheckVariable22), SOLVER_MAPPING_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable28), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is type of this print routine, use Variable2
! - signature type EquationsSetDerivedType
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable28

    ! if variable was already followed
    Ptr6 => Variable%derived
    IF (ASSOCIATED(Ptr6, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"derived"
      CALL Print_EquationsSetDerivedType(Variable% &
        & derived, CheckVariable17, CheckVariable0, Variable2, CheckVariable2, CheckVariable18, CheckVariable12, &
        & CheckVariable20, CheckVariable22, CheckVariable6, CheckVariable7, CheckVariable25, CheckVariable26, &
        & CheckVariable3, CheckVariable5, CheckVariable27, CheckVariable28, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EquationsSetDerivedType), POINTER :: " // &
      & "derived (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, BOUNDARY_CONDITIONS_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_SET_MATERIALS_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_TYPE, EQUATIONS_INTERPOLATION_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), FIELD_TYPE (CheckVariable3), REGION_PTR_TYPE (CheckVariable4), EQUATIONS_SETS_TYPE (CheckVariable5), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CONTROL_LOOP_TYPE (CheckVariable9), EQUATIONS_SET_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), INTERFACES_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), DATA_PROJECTION_TYPE (CheckVariable17), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), EQUATIONS_SET_SOURCE_TYPE (CheckVariable22), SOLVER_MAPPING_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable28), 
! - signature type EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is type of this print routine, use Variable2
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable2
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type EQUATIONS_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_INTERPOLATION_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_INTERPOLATION_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable28

    ! if variable was already followed
    Ptr7 => Variable%EQUATIONS
    IF (ASSOCIATED(Ptr7, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS"
      CALL Print_EQUATIONS_TYPE(Variable% &
        & EQUATIONS, CheckVariable0, Variable2, CheckVariable2, CheckVariable11, CheckVariable18, CheckVariable12, &
        & NullPtr15, CheckVariable21, CheckVariable22, NullPtr16, CheckVariable23, CheckVariable6, CheckVariable25, &
        & CheckVariable26, CheckVariable3, CheckVariable7, NullPtr17, CheckVariable5, CheckVariable27, CheckVariable28, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%BOUNDARY_CONDITIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%BOUNDARY_CONDITIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: " // &
      & "BOUNDARY_CONDITIONS " // &
      & "(associated): " 
  
! Signature of Print_BOUNDARY_CONDITIONS_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, EQUATIONS_SET_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, INTERFACE_CONDITION_TYPE, SOLVERS_TYPE, REGION_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, FIELD_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, BOUNDARY_CONDITIONS_VARIABLE_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), MESHES_TYPE (CheckVariable1), EquationsSetDerivedType (CheckVariable2), FIELD_TYPE (CheckVariable3), REGION_PTR_TYPE (CheckVariable4), EQUATIONS_SETS_TYPE (CheckVariable5), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable6), INTERFACE_TYPE (CheckVariable7), CELLML_ENVIRONMENTS_TYPE (CheckVariable8), CONTROL_LOOP_TYPE (CheckVariable9), EQUATIONS_SET_TYPE (CheckVariable10), BOUNDARY_CONDITIONS_TYPE (CheckVariable11), FIELDS_TYPE (CheckVariable12), GENERATED_MESHES_TYPE (CheckVariable13), NODES_TYPE (CheckVariable14), INTERFACES_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), DATA_PROJECTION_TYPE (CheckVariable17), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable18), SOLVERS_TYPE (CheckVariable19), DECOMPOSITION_TYPE (CheckVariable20), SOLVER_TYPE (CheckVariable21), EQUATIONS_SET_SOURCE_TYPE (CheckVariable22), SOLVER_MAPPING_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), EQUATIONS_SET_PTR_TYPE (CheckVariable25), SOLVER_EQUATIONS_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable28), 
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable11
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_VARIABLE_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE

    ! if variable was already followed
    Ptr8 => Variable%BOUNDARY_CONDITIONS
    IF (ASSOCIATED(Ptr8, CheckVariable11)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BOUNDARY_CONDITIONS"
      CALL Print_BOUNDARY_CONDITIONS_TYPE(Variable% &
        & BOUNDARY_CONDITIONS, NullPtr18, Variable2, NullPtr19, CheckVariable11, NullPtr20, NullPtr21, CheckVariable19, &
        & CheckVariable27, CheckVariable21, CheckVariable23, CheckVariable24, NullPtr22, CheckVariable26, NullPtr23, &
        & CheckVariable3, CheckVariable9, NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: " // &
      & "BOUNDARY_CONDITIONS (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_SET_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_PROBLEM_SETUP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(PROBLEM_SETUP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(PROBLEM_SETUP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SETUP_TYPE:                      ", &
    & Variable%SETUP_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ACTION_TYPE:                     ", &
    & Variable%ACTION_TYPE

  
END SUBROUTINE Print_PROBLEM_SETUP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_IMPROVED_EULER_DAE_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, Depth, MaxDepth, MaxArrayLength)
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13

  ! iterator variables

  ! null pointers
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr4
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr8

  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable2)) THEN
    Variable2 => CheckVariable2
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)

  
  ! Variable%EULER_DAE_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EULER_DAE_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "EULER_DAE_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_EULER_DAE_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, EXTERNAL_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: IMPROVED_EULER_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), SOLVERS_TYPE (CheckVariable1), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable4), EULER_DAE_SOLVER_TYPE (CheckVariable5), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable6), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable7), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable8), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_TYPE (CheckVariable10), BDF_DAE_SOLVER_TYPE (CheckVariable11), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable5
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13

    ! if variable was already followed
    Ptr0 => Variable%EULER_DAE_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EULER_DAE_SOLVER"
      CALL Print_EULER_DAE_SOLVER_TYPE(Variable% &
        & EULER_DAE_SOLVER, CheckVariable11, CheckVariable7, CheckVariable12, NullPtr0, CheckVariable4, NullPtr1, &
        & CheckVariable9, CheckVariable10, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, CheckVariable6, NullPtr7, &
        & CheckVariable0, CheckVariable1, Variable2, CheckVariable3, CheckVariable5, NullPtr8, CheckVariable8, &
        & CheckVariable13, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "EULER_DAE_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)

  
END SUBROUTINE Print_IMPROVED_EULER_DAE_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MATRICES_SOURCE_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2

  ! iterator variables

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: NullPtr1
  TYPE(SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: NullPtr4
  TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: NullPtr5
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr6
  TYPE(FIELD_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr8
  TYPE(REGION_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: NullPtr10
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: NullPtr11
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr12
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: NullPtr13

  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: Ptr0

  TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)

  
  ! Variable%EQUATIONS_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MATRICES_DYNAMIC_TYPE, SOLVER_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_MATRICES_RHS_TYPE, EQUATIONS_MATRICES_LINEAR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_MATRICES_SOURCE_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_MATRICES_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_SOURCE_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_MATRICES_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), EQUATIONS_TYPE (CheckVariable2), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EQUATIONS_MATRICES_DYNAMIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_DYNAMIC_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EQUATIONS_MATRICES_RHS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_RHS_TYPE
! - signature type EQUATIONS_MATRICES_LINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_LINEAR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type EQUATIONS_MATRICES_SOURCE_TYPE
!   is type of this print routine, use Variable2
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type EQUATIONS_MATRICES_NONLINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_NONLINEAR_TYPE

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_MATRICES
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MATRICES"
      CALL Print_EQUATIONS_MATRICES_TYPE(Variable% &
        & EQUATIONS_MATRICES, CheckVariable2, NullPtr0, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, NullPtr4, NullPtr5, &
        & NullPtr6, NullPtr7, Variable2, NullPtr8, NullPtr9, NullPtr10, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "UPDATE_VECTOR:                                   ", &
    & Variable%UPDATE_VECTOR
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "FIRST_ASSEMBLY:                                  ", &
    & Variable%FIRST_ASSEMBLY
  
  ! Variable%VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "VECTOR " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_SOURCE_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_MATRICES_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), EQUATIONS_TYPE (CheckVariable2), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VECTOR"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%VECTOR, NullPtr11, NullPtr12, NullPtr13, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_MATRICES_SOURCE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BASIS_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, Depth, MaxDepth, MaxArrayLength)
  TYPE(BASIS_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BASIS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(BASIS_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1

  ! iterator variables

  ! null pointers

  TYPE(BASIS_TYPE), POINTER :: Ptr0

  TYPE(BASIS_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable1)) THEN
    Variable2 => CheckVariable1
  ELSE
    Variable2 => Variable
  END IF 


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_BASIS_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: BASIS_PTR_TYPE (Variable)
! Available CheckVariables are: BASIS_TYPE (CheckVariable0), BASIS_PTR_TYPE (CheckVariable1), 
! - signature type BASIS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type BASIS_PTR_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_BASIS_TYPE(Variable%PTR, CheckVariable0, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_BASIS_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MESH_EMBEDDING_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(MESH_EMBEDDING_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers
  TYPE(MeshComponentTopologyType), POINTER :: NullPtr0
  TYPE(MESHES_TYPE), POINTER :: NullPtr1
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: NullPtr2
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr3
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: NullPtr5
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr6
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr7
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_TYPE), POINTER :: NullPtr9
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr10
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr11
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr12
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr14
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr15
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr16
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr17
  TYPE(MESH_TYPE), POINTER :: NullPtr18
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr19
  TYPE(FIELDS_TYPE), POINTER :: NullPtr20
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr21
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr22
  TYPE(NODES_TYPE), POINTER :: NullPtr23
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr24
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr25
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr26
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr27
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr28
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: NullPtr29
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr30
  TYPE(REGION_TYPE), POINTER :: NullPtr31


  TYPE(MESH_EMBEDDING_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)
  Nullify(NullPtr29)
  Nullify(NullPtr30)
  Nullify(NullPtr31)

  
  ! Variable% PARENT_MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable% PARENT_MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_TYPE), POINTER :: " // &
      & " PARENT_MESH " // &
      & "(associated): " 
  
! Signature of Print_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, REGION_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESH_EMBEDDING_TYPE (Variable)
! Available CheckVariables are: 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_CYLINDER_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_ELLIPSOID_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_REGULAR_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent)," PARENT_MESH"
      CALL Print_MESH_TYPE(Variable% &
        & PARENT_MESH, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, NullPtr18, NullPtr19, &
        & NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, NullPtr29, &
        & NullPtr30, NullPtr31, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_TYPE), POINTER :: " // &
      & " PARENT_MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CHILD_MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CHILD_MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_TYPE), POINTER :: " // &
      & "CHILD_MESH " // &
      & "(associated): " 
  
! Signature of Print_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, REGION_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESH_EMBEDDING_TYPE (Variable)
! Available CheckVariables are: 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_CYLINDER_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_ELLIPSOID_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_REGULAR_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CHILD_MESH"
      CALL Print_MESH_TYPE(Variable% &
        & CHILD_MESH, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, NullPtr18, NullPtr19, &
        & NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, NullPtr29, &
        & NullPtr30, NullPtr31, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_TYPE), POINTER :: " // &
      & "CHILD_MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CHILD_NODE_XI_POSITION(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%CHILD_NODE_XI_POSITION)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%CHILD_NODE_XI_POSITION),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EMBEDDING_XI_TYPE), ALLOCATABLE :: " // &
      & "CHILD_NODE_XI_POSITION(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%CHILD_NODE_XI_POSITION, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%CHILD_NODE_XI_POSITION,1), MIN(LBOUND(Variable% &
      & CHILD_NODE_XI_POSITION,1)+MaxArrayLength, UBOUND(Variable%CHILD_NODE_XI_POSITION,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EMBEDDING_XI_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: MESH_EMBEDDING_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CHILD_NODE_XI_POSITION("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EMBEDDING_XI_TYPE(Variable%CHILD_NODE_XI_POSITION(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EMBEDDING_XI_TYPE), ALLOCATABLE :: " // &
      & "CHILD_NODE_XI_POSITION(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%GAUSS_POINT_XI_POSITION(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GAUSS_POINT_XI_POSITION)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GAUSS_POINT_XI_POSITION),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EMBEDDING_GAUSSPOINT_TYPE), ALLOCATABLE :: " // &
      & "GAUSS_POINT_XI_POSITION(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GAUSS_POINT_XI_POSITION, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%GAUSS_POINT_XI_POSITION,1), MIN(LBOUND(Variable% &
      & GAUSS_POINT_XI_POSITION,1)+MaxArrayLength, UBOUND(Variable%GAUSS_POINT_XI_POSITION,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%GAUSS_POINT_XI_POSITION,2), MIN(LBOUND(Variable% &
        & GAUSS_POINT_XI_POSITION,2)+MaxArrayLength, UBOUND(Variable%GAUSS_POINT_XI_POSITION,2))
        WRITE(I1_STR,"(I4)") I1 

! Signature of Print_EMBEDDING_GAUSSPOINT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: MESH_EMBEDDING_TYPE (Variable)
! Available CheckVariables are: 
          PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GAUSS_POINT_XI_POSITION("//TRIM(ADJUSTL(I0_STR))//"," // &
            & ""//TRIM(ADJUSTL(I1_STR))//")"
          CALL Print_EMBEDDING_GAUSSPOINT_TYPE(Variable%GAUSS_POINT_XI_POSITION(I0,I1), Depth+1, MaxDepth, MaxArrayLength)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EMBEDDING_GAUSSPOINT_TYPE), ALLOCATABLE :: " // &
      & "GAUSS_POINT_XI_POSITION(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_MESH_EMBEDDING_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_MODELS_FIELD_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable12

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr2
  TYPE(MESH_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_MODEL_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr9
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr11
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr12
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr13
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr14
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr15
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr16
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr17
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr18
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr19
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr20
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr21

  TYPE(CELLML_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable10)) THEN
    Variable2 => CheckVariable10
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)

  
  ! Variable%CELLML
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CELLML)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML " // &
      & "(associated): " 
  
! Signature of Print_CELLML_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, CELLML_MODEL_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_MODELS_FIELD_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), CELLML_FIELD_MAPS_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), CELLML_ENVIRONMENTS_TYPE (CheckVariable6), CELLML_STATE_FIELD_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), CELLML_MODELS_FIELD_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable12), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type CELLML_MODELS_FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CELLML_MODEL_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_MODEL_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr0 => Variable%CELLML
    IF (ASSOCIATED(Ptr0, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML"
      CALL Print_CELLML_TYPE(Variable% &
        & CELLML, NullPtr0, CheckVariable8, NullPtr1, Variable2, CheckVariable12, CheckVariable5, NullPtr2, CheckVariable6, &
        & CheckVariable7, CheckVariable9, NullPtr3, CheckVariable2, CheckVariable4, NullPtr4, NullPtr5, NullPtr6, NullPtr7, &
        & NullPtr8, CheckVariable0, CheckVariable1, CheckVariable3, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "MODELS_FIELD_FINISHED:                           ", &
    & Variable%MODELS_FIELD_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "MODELS_FIELD_AUTO_CREATED:                       ", &
    & Variable%MODELS_FIELD_AUTO_CREATED
  
  ! Variable%MODELS_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MODELS_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "MODELS_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_MODELS_FIELD_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), CELLML_FIELD_MAPS_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), CELLML_ENVIRONMENTS_TYPE (CheckVariable6), CELLML_STATE_FIELD_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), CELLML_MODELS_FIELD_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable12), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr1 => Variable%MODELS_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MODELS_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & MODELS_FIELD, NullPtr0, NullPtr10, NullPtr11, NullPtr12, CheckVariable8, NullPtr1, NullPtr13, NullPtr14, &
        & CheckVariable5, NullPtr15, CheckVariable6, NullPtr16, CheckVariable9, NullPtr17, NullPtr3, CheckVariable2, &
        & NullPtr5, NullPtr18, NullPtr6, NullPtr19, NullPtr7, NullPtr8, CheckVariable0, NullPtr20, CheckVariable3, &
        & NullPtr21, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "MODELS_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ONLY_ONE_MODEL_INDEX:            ", &
    & Variable%ONLY_ONE_MODEL_INDEX

  
END SUBROUTINE Print_CELLML_MODELS_FIELD_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MeshDofsType(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, Depth, MaxDepth, MaxArrayLength)
  TYPE(MeshDofsType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MeshComponentTopologyType), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(MeshNodesType), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(MeshElementsType), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(MeshDataPointsType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(MeshDofsType), POINTER, INTENT(IN) :: CheckVariable9

  ! iterator variables

  ! null pointers
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_TYPE), POINTER :: NullPtr1
  TYPE(FIELDS_TYPE), POINTER :: NullPtr2
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr3
  TYPE(REGION_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr5
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr6
  TYPE(MESHES_TYPE), POINTER :: NullPtr7
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr8

  TYPE(MeshComponentTopologyType), POINTER :: Ptr0

  TYPE(MeshDofsType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable9)) THEN
    Variable2 => CheckVariable9
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)

  
  ! Variable%meshComponentTopology
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%meshComponentTopology)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshComponentTopologyType), POINTER :: " // &
      & "meshComponentTopology " // &
      & "(associated): " 
  
! Signature of Print_MeshComponentTopologyType has the following CheckVariable types: DATA_PROJECTION_TYPE, MESH_TYPE, MeshDataPointsType, MeshComponentTopologyPtrType, FIELD_TYPE, MESH_PTR_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, MeshNodesType, MeshElementsType, REGION_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, GENERATED_MESH_TYPE, MeshComponentTopologyType, MESHES_TYPE, DECOMPOSITIONS_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, MeshDofsType, 
! The type to handle in this routine is: MeshDofsType (Variable)
! Available CheckVariables are: MESH_TYPE (CheckVariable0), MeshComponentTopologyType (CheckVariable1), MeshComponentTopologyPtrType (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), MeshNodesType (CheckVariable4), MeshElementsType (CheckVariable5), MeshDataPointsType (CheckVariable6), DECOMPOSITIONS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), MeshDofsType (CheckVariable9), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MeshDataPointsType
!   matches available passing type, use it as CheckVariable6
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type MeshNodesType
!   matches available passing type, use it as CheckVariable4
! - signature type MeshElementsType
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type MeshComponentTopologyType
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type MeshDofsType
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr0 => Variable%meshComponentTopology
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"meshComponentTopology"
      CALL Print_MeshComponentTopologyType(Variable% &
        & meshComponentTopology, NullPtr0, CheckVariable0, CheckVariable6, CheckVariable2, NullPtr1, CheckVariable3, &
        & NullPtr2, NullPtr3, CheckVariable4, CheckVariable5, NullPtr4, NullPtr5, NullPtr6, CheckVariable1, NullPtr7, &
        & CheckVariable7, NullPtr8, CheckVariable8, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshComponentTopologyType), POINTER :: " // &
      & "meshComponentTopology (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfDofs:                    ", &
    & Variable%numberOfDofs

  
END SUBROUTINE Print_MeshDofsType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_MODEL_MAPS_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_MODEL_MAPS_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(CELLML_MODEL_MAPS_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_MODEL_MAPS_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_CELLML_MODEL_MAPS_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: CELLML_MODEL_MAPS_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_CELLML_MODEL_MAPS_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_MODEL_MAPS_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_CELLML_MODEL_MAPS_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_MAPPING_CREATE_VALUES_CACHE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1, I2
  CHARACTER(LEN=30) :: I0_STR, I1_STR, I2_STR

  ! null pointers


  TYPE(SOLVER_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%EQUATIONS_VARIABLE_LIST(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_VARIABLE_LIST)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(LIST_PTR_TYPE), POINTER :: " // &
      & "EQUATIONS_VARIABLE_LIST(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%EQUATIONS_VARIABLE_LIST,1), "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_VARIABLE_LIST,1), MIN(LBOUND(Variable% &
      & EQUATIONS_VARIABLE_LIST,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_VARIABLE_LIST,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_LIST_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: SOLVER_MAPPING_CREATE_VALUES_CACHE_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_VARIABLE_LIST("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_LIST_PTR_TYPE(Variable%EQUATIONS_VARIABLE_LIST(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(LIST_PTR_TYPE), POINTER :: " // &
      & "EQUATIONS_VARIABLE_LIST(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DYNAMIC_VARIABLE_TYPE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DYNAMIC_VARIABLE_TYPE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DYNAMIC_VARIABLE_TYPE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER, ALLOCATABLE :: " // &
      & "DYNAMIC_VARIABLE_TYPE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DYNAMIC_VARIABLE_TYPE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER, ALLOCATABLE :: " // &
      & "DYNAMIC_VARIABLE_TYPE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%MATRIX_VARIABLE_TYPES(:,:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MATRIX_VARIABLE_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MATRIX_VARIABLE_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "MATRIX_VARIABLE_TYPES(:,:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MATRIX_VARIABLE_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%MATRIX_VARIABLE_TYPES,1), MIN(LBOUND(Variable% &
      & MATRIX_VARIABLE_TYPES,1)+MaxArrayLength, UBOUND(Variable%MATRIX_VARIABLE_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%MATRIX_VARIABLE_TYPES,2), MIN(LBOUND(Variable% &
        & MATRIX_VARIABLE_TYPES,2)+MaxArrayLength, UBOUND(Variable%MATRIX_VARIABLE_TYPES,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//","//TRIM(ADJUSTL(I1_STR))//",*): "
        DO I2 = LBOUND(Variable%MATRIX_VARIABLE_TYPES,3), MIN(LBOUND(Variable% &
          & MATRIX_VARIABLE_TYPES,3)+MaxArrayLength, UBOUND(Variable%MATRIX_VARIABLE_TYPES,3))
          WRITE(I2_STR,"(I4)") I2 

          PRINT*, TRIM(PrintIndent), Variable%MATRIX_VARIABLE_TYPES(I0,I1,I2)

        ENDDO  ! I2
      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "MATRIX_VARIABLE_TYPES(:,:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%RESIDUAL_VARIABLE_TYPES(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%RESIDUAL_VARIABLE_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%RESIDUAL_VARIABLE_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "RESIDUAL_VARIABLE_TYPES(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%RESIDUAL_VARIABLE_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%RESIDUAL_VARIABLE_TYPES,1), MIN(LBOUND(Variable% &
      & RESIDUAL_VARIABLE_TYPES,1)+MaxArrayLength, UBOUND(Variable%RESIDUAL_VARIABLE_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%RESIDUAL_VARIABLE_TYPES,2), MIN(LBOUND(Variable% &
        & RESIDUAL_VARIABLE_TYPES,2)+MaxArrayLength, UBOUND(Variable%RESIDUAL_VARIABLE_TYPES,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%RESIDUAL_VARIABLE_TYPES(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "RESIDUAL_VARIABLE_TYPES(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%RHS_VARIABLE_TYPE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%RHS_VARIABLE_TYPE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%RHS_VARIABLE_TYPE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "RHS_VARIABLE_TYPE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%RHS_VARIABLE_TYPE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%RHS_VARIABLE_TYPE,1), MIN(LBOUND(Variable%RHS_VARIABLE_TYPE,1)+MaxArrayLength, UBOUND(Variable% &
      & RHS_VARIABLE_TYPE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%RHS_VARIABLE_TYPE(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "RHS_VARIABLE_TYPE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%SOURCE_VARIABLE_TYPE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOURCE_VARIABLE_TYPE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOURCE_VARIABLE_TYPE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER, ALLOCATABLE :: " // &
      & "SOURCE_VARIABLE_TYPE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOURCE_VARIABLE_TYPE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER, ALLOCATABLE :: " // &
      & "SOURCE_VARIABLE_TYPE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERFACE_VARIABLE_LIST(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%INTERFACE_VARIABLE_LIST)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(LIST_PTR_TYPE), POINTER :: " // &
      & "INTERFACE_VARIABLE_LIST(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%INTERFACE_VARIABLE_LIST,1), "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_VARIABLE_LIST,1), MIN(LBOUND(Variable% &
      & INTERFACE_VARIABLE_LIST,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_VARIABLE_LIST,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_LIST_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: SOLVER_MAPPING_CREATE_VALUES_CACHE_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_VARIABLE_LIST("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_LIST_PTR_TYPE(Variable%INTERFACE_VARIABLE_LIST(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(LIST_PTR_TYPE), POINTER :: " // &
      & "INTERFACE_VARIABLE_LIST(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE_INDICES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%INTERFACE_INDICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(LIST_PTR_TYPE), POINTER :: " // &
      & "INTERFACE_INDICES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%INTERFACE_INDICES,1), "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_INDICES,1), MIN(LBOUND(Variable%INTERFACE_INDICES,1)+MaxArrayLength, UBOUND(Variable% &
      & INTERFACE_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_LIST_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: SOLVER_MAPPING_CREATE_VALUES_CACHE_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_INDICES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_LIST_PTR_TYPE(Variable%INTERFACE_INDICES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(LIST_PTR_TYPE), POINTER :: " // &
      & "INTERFACE_INDICES(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_SOLVER_MAPPING_CREATE_VALUES_CACHE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BoundaryConditionsDofConstraintType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(BoundaryConditionsDofConstraintType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(BoundaryConditionsDofConstraintType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "globalDof:                       ", &
    & Variable%globalDof
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfDofs:                    ", &
    & Variable%numberOfDofs
  
  ! Variable%dofs(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%dofs)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%dofs),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "dofs(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%dofs, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%dofs,1), MIN(LBOUND(Variable%dofs,1)+MaxArrayLength, UBOUND(Variable%dofs,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%dofs(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "dofs(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%coefficients(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%coefficients)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%coefficients),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "coefficients(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%coefficients, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%coefficients,1), MIN(LBOUND(Variable%coefficients,1)+MaxArrayLength, UBOUND(Variable%coefficients,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%coefficients(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "coefficients(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_BoundaryConditionsDofConstraintType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_COL_TO_EQUATIONS_MAPS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_COL_TO_EQUATIONS_MAPS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(SOLVER_MATRIX_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable7

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr0
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr2
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr4
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: NullPtr6
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr11
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr12

  TYPE(SOLVER_MAPPING_TYPE), POINTER :: Ptr0
  TYPE(SOLVER_MATRIX_TYPE), POINTER :: Ptr1

  TYPE(SOLVER_COL_TO_EQUATIONS_MAPS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRIX_NUMBER:            ", &
    & Variable%SOLVER_MATRIX_NUMBER
  
  ! Variable%SOLVER_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MAPPING_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, DAE_SOLVER_TYPE, EQUATIONS_SET_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, EQUATIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, INTERFACE_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, SOLVER_MATRIX_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_COL_TO_EQUATIONS_MAPS_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRIX_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVER_MATRICES_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVERS_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_MATRIX_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE

    ! if variable was already followed
    Ptr0 => Variable%SOLVER_MAPPING
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MAPPING"
      CALL Print_SOLVER_MAPPING_TYPE(Variable% &
        & SOLVER_MAPPING, NullPtr0, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, NullPtr4, NullPtr5, CheckVariable5, &
        & CheckVariable3, NullPtr6, CheckVariable4, CheckVariable2, CheckVariable0, NullPtr7, CheckVariable6, NullPtr8, &
        & CheckVariable7, NullPtr9, NullPtr10, NullPtr11, NullPtr12, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOLVER_MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MATRIX_TYPE), POINTER :: " // &
      & "SOLVER_MATRIX " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MATRIX_TYPE has the following CheckVariable types: SOLVER_MATRICES_TYPE, SOLVERS_TYPE, SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, 
! The type to handle in this routine is: SOLVER_COL_TO_EQUATIONS_MAPS_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRIX_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVER_MATRICES_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVERS_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4

    ! if variable was already followed
    Ptr1 => Variable%SOLVER_MATRIX
    IF (ASSOCIATED(Ptr1, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MATRIX"
      CALL Print_SOLVER_MATRIX_TYPE(Variable% &
        & SOLVER_MATRIX, CheckVariable2, CheckVariable5, CheckVariable3, CheckVariable6, CheckVariable4, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MATRIX_TYPE), POINTER :: " // &
      & "SOLVER_MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COLUMNS:               ", &
    & Variable%NUMBER_OF_COLUMNS
  
  ! Variable%SOLVER_COL_TO_EQUATIONS_SET_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOLVER_COL_TO_EQUATIONS_SET_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOLVER_COL_TO_EQUATIONS_SET_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_COL_TO_EQUATIONS_SET_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOLVER_COL_TO_EQUATIONS_SET_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%SOLVER_COL_TO_EQUATIONS_SET_MAPS,1), MIN(LBOUND(Variable% &
      & SOLVER_COL_TO_EQUATIONS_SET_MAPS,1)+MaxArrayLength, UBOUND(Variable%SOLVER_COL_TO_EQUATIONS_SET_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE has the following CheckVariable types: SOLVER_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, 
! The type to handle in this routine is: SOLVER_COL_TO_EQUATIONS_MAPS_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRIX_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVER_MATRICES_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVERS_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_COL_TO_EQUATIONS_SET_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE(Variable% &
          & SOLVER_COL_TO_EQUATIONS_SET_MAPS(I0), CheckVariable6, CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_COL_TO_EQUATIONS_SET_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%SOLVER_COL_TO_INTERFACE_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOLVER_COL_TO_INTERFACE_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOLVER_COL_TO_INTERFACE_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_COL_TO_INTERFACE_MAP_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_COL_TO_INTERFACE_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOLVER_COL_TO_INTERFACE_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%SOLVER_COL_TO_INTERFACE_MAPS,1), MIN(LBOUND(Variable% &
      & SOLVER_COL_TO_INTERFACE_MAPS,1)+MaxArrayLength, UBOUND(Variable%SOLVER_COL_TO_INTERFACE_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_COL_TO_INTERFACE_MAP_TYPE has the following CheckVariable types: SOLVER_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, 
! The type to handle in this routine is: SOLVER_COL_TO_EQUATIONS_MAPS_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRIX_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVER_MATRICES_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVERS_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable4
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_COL_TO_INTERFACE_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_COL_TO_INTERFACE_MAP_TYPE(Variable% &
          & SOLVER_COL_TO_INTERFACE_MAPS(I0), CheckVariable6, CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_COL_TO_INTERFACE_MAP_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_COL_TO_INTERFACE_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DOFS:                  ", &
    & Variable%NUMBER_OF_DOFS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_DOFS:            ", &
    & Variable%TOTAL_NUMBER_OF_DOFS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_DOFS:           ", &
    & Variable%NUMBER_OF_GLOBAL_DOFS
  
  ! Variable%SOLVER_DOF_TO_VARIABLE_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOLVER_DOF_TO_VARIABLE_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOLVER_DOF_TO_VARIABLE_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_DOF_TO_VARIABLE_MAP_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_DOF_TO_VARIABLE_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOLVER_DOF_TO_VARIABLE_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%SOLVER_DOF_TO_VARIABLE_MAPS,1), MIN(LBOUND(Variable% &
      & SOLVER_DOF_TO_VARIABLE_MAPS,1)+MaxArrayLength, UBOUND(Variable%SOLVER_DOF_TO_VARIABLE_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_DOF_TO_VARIABLE_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: SOLVER_COL_TO_EQUATIONS_MAPS_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRIX_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVER_MATRICES_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVERS_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_DOF_TO_VARIABLE_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_DOF_TO_VARIABLE_MAP_TYPE(Variable%SOLVER_DOF_TO_VARIABLE_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_DOF_TO_VARIABLE_MAP_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_DOF_TO_VARIABLE_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COLUMN_DOFS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%COLUMN_DOFS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "COLUMN_DOFS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: SOLVER_COL_TO_EQUATIONS_MAPS_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRIX_TYPE (CheckVariable0), BOUNDARY_CONDITIONS_TYPE (CheckVariable1), SOLVER_MATRICES_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), SOLVER_MAPPING_TYPE (CheckVariable4), SOLVERS_TYPE (CheckVariable5), SOLVER_EQUATIONS_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"COLUMN_DOFS_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%COLUMN_DOFS_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "COLUMN_DOFS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_SOLVER_COL_TO_EQUATIONS_MAPS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTEGER_CINT_ALLOC_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTEGER_CINT_ALLOC_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(INTEGER_CINT_ALLOC_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%ARRAY(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ARRAY)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ARRAY),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(C_INT), ALLOCATABLE :: " // &
      & "ARRAY(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ARRAY, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(C_INT), ALLOCATABLE :: " // &
      & "ARRAY(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_INTEGER_CINT_ALLOC_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INTERFACE_MATRIX_NUMBER:         ", &
    & Variable%INTERFACE_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SOLVER_MATRICES:       ", &
    & Variable%NUMBER_OF_SOLVER_MATRICES
  
  ! Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TO_SOLVER_MAPS_PTR_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_TO_SOLVER_MATRIX_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS,1), MIN(LBOUND(Variable% &
      & INTERFACE_TO_SOLVER_MATRIX_MAPS,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_TO_SOLVER_MATRIX_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_TO_SOLVER_MAPS_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_TO_SOLVER_MATRIX_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_TO_SOLVER_MAPS_PTR_TYPE(Variable% &
          & INTERFACE_TO_SOLVER_MATRIX_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TO_SOLVER_MAPS_PTR_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_TO_SOLVER_MATRIX_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERFACE_ROW_TO_SOLVER_ROWS_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_ROW_TO_SOLVER_ROWS_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_ROW_TO_SOLVER_ROWS_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_ROW_TO_SOLVER_ROWS_MAP_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_ROW_TO_SOLVER_ROWS_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_ROW_TO_SOLVER_ROWS_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_ROW_TO_SOLVER_ROWS_MAP,1), MIN(LBOUND(Variable% &
      & INTERFACE_ROW_TO_SOLVER_ROWS_MAP,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_ROW_TO_SOLVER_ROWS_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_ROW_TO_SOLVER_ROWS_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_ROW_TO_SOLVER_ROWS_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_ROW_TO_SOLVER_ROWS_MAP_TYPE(Variable% &
          & INTERFACE_ROW_TO_SOLVER_ROWS_MAP(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_ROW_TO_SOLVER_ROWS_MAP_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_ROW_TO_SOLVER_ROWS_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_JACOBIAN_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_JACOBIAN_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(EQUATIONS_JACOBIAN_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_JACOBIAN_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_JACOBIAN_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_JACOBIAN_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_EQUATIONS_JACOBIAN_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_JACOBIAN_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_JACOBIAN_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_INTERPOLATED_POINT_METRICS_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers


  TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%INTERPOLATED_POINT
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERPOLATED_POINT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: " // &
      & "INTERPOLATED_POINT " // &
      & "(associated): " 
  
! Signature of Print_FIELD_INTERPOLATED_POINT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_INTERPOLATED_POINT_METRICS_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERPOLATED_POINT"
      CALL Print_FIELD_INTERPOLATED_POINT_TYPE(Variable%INTERPOLATED_POINT, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: " // &
      & "INTERPOLATED_POINT (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_X_DIMENSIONS:          ", &
    & Variable%NUMBER_OF_X_DIMENSIONS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_XI_DIMENSIONS:         ", &
    & Variable%NUMBER_OF_XI_DIMENSIONS
  
  ! Variable%GL(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GL)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GL),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "GL(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GL, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%GL,1), MIN(LBOUND(Variable%GL,1)+MaxArrayLength, UBOUND(Variable%GL,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%GL,2), MIN(LBOUND(Variable%GL,2)+MaxArrayLength, UBOUND(Variable%GL,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%GL(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "GL(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%GU(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GU)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GU),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "GU(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GU, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%GU,1), MIN(LBOUND(Variable%GU,1)+MaxArrayLength, UBOUND(Variable%GU,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%GU,2), MIN(LBOUND(Variable%GU,2)+MaxArrayLength, UBOUND(Variable%GU,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%GU(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "GU(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DX_DXI(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DX_DXI)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DX_DXI),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "DX_DXI(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DX_DXI, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DX_DXI,1), MIN(LBOUND(Variable%DX_DXI,1)+MaxArrayLength, UBOUND(Variable%DX_DXI,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%DX_DXI,2), MIN(LBOUND(Variable%DX_DXI,2)+MaxArrayLength, UBOUND(Variable%DX_DXI,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%DX_DXI(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "DX_DXI(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DXI_DX(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DXI_DX)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DXI_DX),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "DXI_DX(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DXI_DX, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DXI_DX,1), MIN(LBOUND(Variable%DXI_DX,1)+MaxArrayLength, UBOUND(Variable%DXI_DX,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%DXI_DX,2), MIN(LBOUND(Variable%DXI_DX,2)+MaxArrayLength, UBOUND(Variable%DXI_DX,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%DXI_DX(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "DXI_DX(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "JACOBIAN:                    ", &
    & Variable%JACOBIAN
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "JACOBIAN_TYPE:                   ", &
    & Variable%JACOBIAN_TYPE

  
END SUBROUTINE Print_FIELD_INTERPOLATED_POINT_METRICS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_GENERATED_MESH_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, Depth, MaxDepth, MaxArrayLength)
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable21

  ! iterator variables

  ! null pointers
  TYPE(MeshComponentTopologyType), POINTER :: NullPtr0
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr2
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr3
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr4
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr5

  TYPE(GENERATED_MESH_TYPE), POINTER :: Ptr0

  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable19)) THEN
    Variable2 => CheckVariable19
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GENERATED_MESH_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_GENERATED_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, DECOMPOSITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: GENERATED_MESH_PTR_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), GENERATED_MESH_CYLINDER_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), GENERATED_MESH_ELLIPSOID_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable10), CELLML_ENVIRONMENTS_TYPE (CheckVariable11), MESH_TYPE (CheckVariable12), FIELDS_TYPE (CheckVariable13), GENERATED_MESHES_TYPE (CheckVariable14), DECOMPOSITIONS_TYPE (CheckVariable15), NODES_TYPE (CheckVariable16), INTERFACES_TYPE (CheckVariable17), DATA_POINTS_TYPE (CheckVariable18), GENERATED_MESH_PTR_TYPE (CheckVariable19), GENERATED_MESH_REGULAR_TYPE (CheckVariable20), REGION_TYPE (CheckVariable21), 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESH_PTR_TYPE
!   is type of this print routine, use Variable2
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type GENERATED_MESH_REGULAR_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable21

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable5)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_GENERATED_MESH_TYPE(Variable% &
        & PTR, NullPtr0, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, NullPtr1, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & NullPtr2, CheckVariable12, NullPtr3, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
        & CheckVariable17, CheckVariable18, Variable2, NullPtr4, CheckVariable20, NullPtr5, CheckVariable21, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GENERATED_MESH_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_GENERATED_MESH_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_ROW_TO_SOLVER_ROWS_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_ROW_TO_SOLVER_ROWS_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(INTERFACE_ROW_TO_SOLVER_ROWS_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SOLVER_ROWS:           ", &
    & Variable%NUMBER_OF_SOLVER_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_ROW:                      ", &
    & Variable%SOLVER_ROW
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "COUPLING_COEFFICIENT:        ", &
    & Variable%COUPLING_COEFFICIENT

  
END SUBROUTINE Print_INTERFACE_ROW_TO_SOLVER_ROWS_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_NODES_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_NODES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable4

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_LINES_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_TYPE), POINTER :: NullPtr3
  TYPE(DOMAIN_DOFS_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr5
  TYPE(FIELDS_TYPE), POINTER :: NullPtr6
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr8
  TYPE(CELLML_TYPE), POINTER :: NullPtr9
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: NullPtr10
  TYPE(MESH_TYPE), POINTER :: NullPtr11
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr12
  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: NullPtr13
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr14
  TYPE(DOMAIN_FACES_TYPE), POINTER :: NullPtr15
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr16
  TYPE(DecompositionDataPointsType), POINTER :: NullPtr17
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: NullPtr18
  TYPE(REGION_TYPE), POINTER :: NullPtr19

  TYPE(DOMAIN_TYPE), POINTER :: Ptr0

  TYPE(DOMAIN_NODES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)

  
  ! Variable%DOMAIN
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DOMAIN)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_TYPE has the following CheckVariable types: DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, DOMAIN_LINES_TYPE, FIELD_TYPE, DOMAIN_DOFS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_FACES_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_ELEMENTS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_FACES_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DOMAIN_NODES_TYPE, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DOMAIN_NODES_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TOPOLOGY_TYPE (CheckVariable0), DECOMPOSITION_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DOMAIN_PTR_TYPE (CheckVariable3), DOMAIN_TYPE (CheckVariable4), 
! - signature type DOMAIN_MAPPINGS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type DOMAIN_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_LINES_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type DOMAIN_DOFS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_DOFS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_FACES_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_ELEMENTS_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type DOMAIN_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_ELEMENTS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DOMAIN_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_FACES_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DecompositionDataPointsType
!   is not available in passing variables, use NullPtr of type DecompositionDataPointsType
! - signature type DOMAIN_NODES_TYPE
!   is type of this print routine, use Variable2
! - signature type DECOMPOSITION_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_LINES_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DOMAIN
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOMAIN"
      CALL Print_DOMAIN_TYPE(Variable% &
        & DOMAIN, CheckVariable2, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, CheckVariable4, NullPtr6, &
        & NullPtr7, NullPtr8, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, CheckVariable3, NullPtr15, &
        & NullPtr16, CheckVariable0, CheckVariable1, NullPtr17, Variable2, NullPtr18, NullPtr19, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_NODES:                 ", &
    & Variable%NUMBER_OF_NODES
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_NODES:           ", &
    & Variable%TOTAL_NUMBER_OF_NODES
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_NODES:          ", &
    & Variable%NUMBER_OF_GLOBAL_NODES
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_DERIVATIVES:   ", &
    & Variable%MAXIMUM_NUMBER_OF_DERIVATIVES
  
  ! Variable%NODES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%NODES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_NODE_TYPE), POINTER :: " // &
      & "NODES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%NODES,1), "): "
  
    DO I0 = LBOUND(Variable%NODES,1), MIN(LBOUND(Variable%NODES,1)+MaxArrayLength, UBOUND(Variable%NODES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DOMAIN_NODE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DOMAIN_NODES_TYPE (Variable)
! Available CheckVariables are: DOMAIN_TOPOLOGY_TYPE (CheckVariable0), DECOMPOSITION_TYPE (CheckVariable1), DOMAIN_MAPPINGS_TYPE (CheckVariable2), DOMAIN_PTR_TYPE (CheckVariable3), DOMAIN_TYPE (CheckVariable4), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NODES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DOMAIN_NODE_TYPE(Variable%NODES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_NODE_TYPE), POINTER :: " // &
      & "NODES(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%NODES_TREE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NODES_TREE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(TREE_TYPE), POINTER :: " // &
      & "NODES_TREE " // &
      & "(associated): " 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(TREE_TYPE) :: Variable%" // &
        & "NODES_TREE (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(TREE_TYPE), POINTER :: " // &
      & "NODES_TREE (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DOMAIN_NODES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_VAR_TO_EQUATIONS_MATRICES_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(VAR_TO_EQUATIONS_MATRICES_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr1
  TYPE(MESHES_TYPE), POINTER :: NullPtr2
  TYPE(FIELDS_TYPE), POINTER :: NullPtr3
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr4
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr6
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr11
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr12
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr13
  TYPE(NODES_TYPE), POINTER :: NullPtr14
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr15
  TYPE(REGION_TYPE), POINTER :: NullPtr16
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr17


  TYPE(VAR_TO_EQUATIONS_MATRICES_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "VARIABLE_INDEX:                  ", &
    & Variable%VARIABLE_INDEX
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "VARIABLE_TYPE:                   ", &
    & Variable%VARIABLE_TYPE
  
  ! Variable%VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: VAR_TO_EQUATIONS_MATRICES_MAP_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & VARIABLE, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_EQUATIONS_MATRICES:    ", &
    & Variable%NUMBER_OF_EQUATIONS_MATRICES
  
  ! Variable%EQUATIONS_MATRIX_NUMBERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_MATRIX_NUMBERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_MATRIX_NUMBERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_MATRIX_NUMBERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_MATRIX_NUMBERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_MATRIX_NUMBERS,1), MIN(LBOUND(Variable% &
      & EQUATIONS_MATRIX_NUMBERS,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_MATRIX_NUMBERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_MATRIX_NUMBERS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_MATRIX_NUMBERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DOF_TO_COLUMNS_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOF_TO_COLUMNS_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOF_TO_COLUMNS_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(VAR_TO_EQUATIONS_COLUMN_MAP_TYPE), ALLOCATABLE :: " // &
      & "DOF_TO_COLUMNS_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOF_TO_COLUMNS_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%DOF_TO_COLUMNS_MAPS,1), MIN(LBOUND(Variable% &
      & DOF_TO_COLUMNS_MAPS,1)+MaxArrayLength, UBOUND(Variable%DOF_TO_COLUMNS_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_VAR_TO_EQUATIONS_COLUMN_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: VAR_TO_EQUATIONS_MATRICES_MAP_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOF_TO_COLUMNS_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_VAR_TO_EQUATIONS_COLUMN_MAP_TYPE(Variable%DOF_TO_COLUMNS_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(VAR_TO_EQUATIONS_COLUMN_MAP_TYPE), ALLOCATABLE :: " // &
      & "DOF_TO_COLUMNS_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DOF_TO_ROWS_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOF_TO_ROWS_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOF_TO_ROWS_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_TO_ROWS_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOF_TO_ROWS_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DOF_TO_ROWS_MAP,1), MIN(LBOUND(Variable%DOF_TO_ROWS_MAP,1)+MaxArrayLength, UBOUND(Variable% &
      & DOF_TO_ROWS_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DOF_TO_ROWS_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_TO_ROWS_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_VAR_TO_EQUATIONS_MATRICES_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MAPPING_LINEAR_TYPE(Variable, CheckVariable0, CheckVariable1, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable1

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr3
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr4
  TYPE(REGION_TYPE), POINTER :: NullPtr5
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr6
  TYPE(FIELD_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr8
  TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER :: NullPtr10

  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: Ptr0

  TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)

  
  ! Variable%EQUATIONS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MAPPING_LINEAR_TYPE, EQUATIONS_MAPPING_DYNAMIC_TYPE, EQUATIONS_MAPPING_RHS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, REGION_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_MAPPING_SOURCE_TYPE, EQUATIONS_MAPPING_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_LINEAR_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EQUATIONS_MAPPING_LINEAR_TYPE
!   is type of this print routine, use Variable2
! - signature type EQUATIONS_MAPPING_DYNAMIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_DYNAMIC_TYPE
! - signature type EQUATIONS_MAPPING_RHS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_RHS_TYPE
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type EQUATIONS_MAPPING_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_NONLINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_NONLINEAR_TYPE

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_MAPPING
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MAPPING"
      CALL Print_EQUATIONS_MAPPING_TYPE(Variable% &
        & EQUATIONS_MAPPING, CheckVariable0, NullPtr0, Variable2, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, &
        & NullPtr6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LINEAR_EQUATIONS_MATRICES: ", &
    & Variable%NUMBER_OF_LINEAR_EQUATIONS_MATRICES
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LINEAR_MATRIX_VARIABLES: ", &
    & Variable%NUMBER_OF_LINEAR_MATRIX_VARIABLES
  
  ! Variable%LINEAR_MATRIX_VARIABLE_TYPES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LINEAR_MATRIX_VARIABLE_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LINEAR_MATRIX_VARIABLE_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LINEAR_MATRIX_VARIABLE_TYPES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LINEAR_MATRIX_VARIABLE_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LINEAR_MATRIX_VARIABLE_TYPES,1), MIN(LBOUND(Variable% &
      & LINEAR_MATRIX_VARIABLE_TYPES,1)+MaxArrayLength, UBOUND(Variable%LINEAR_MATRIX_VARIABLE_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LINEAR_MATRIX_VARIABLE_TYPES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LINEAR_MATRIX_VARIABLE_TYPES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%VAR_TO_EQUATIONS_MATRICES_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VAR_TO_EQUATIONS_MATRICES_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VAR_TO_EQUATIONS_MATRICES_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(VAR_TO_EQUATIONS_MATRICES_MAP_TYPE), ALLOCATABLE :: " // &
      & "VAR_TO_EQUATIONS_MATRICES_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VAR_TO_EQUATIONS_MATRICES_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%VAR_TO_EQUATIONS_MATRICES_MAPS,1), MIN(LBOUND(Variable% &
      & VAR_TO_EQUATIONS_MATRICES_MAPS,1)+MaxArrayLength, UBOUND(Variable%VAR_TO_EQUATIONS_MATRICES_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_VAR_TO_EQUATIONS_MATRICES_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MAPPING_LINEAR_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VAR_TO_EQUATIONS_MATRICES_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_VAR_TO_EQUATIONS_MATRICES_MAP_TYPE(Variable% &
          & VAR_TO_EQUATIONS_MATRICES_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(VAR_TO_EQUATIONS_MATRICES_MAP_TYPE), ALLOCATABLE :: " // &
      & "VAR_TO_EQUATIONS_MATRICES_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_MATRIX_TO_VAR_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_MATRIX_TO_VAR_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_MATRIX_TO_VAR_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRIX_TO_VAR_MAP_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_MATRIX_TO_VAR_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_MATRIX_TO_VAR_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_MATRIX_TO_VAR_MAPS,1), MIN(LBOUND(Variable% &
      & EQUATIONS_MATRIX_TO_VAR_MAPS,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_MATRIX_TO_VAR_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_MATRIX_TO_VAR_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MAPPING_LINEAR_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MATRIX_TO_VAR_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_MATRIX_TO_VAR_MAP_TYPE(Variable%EQUATIONS_MATRIX_TO_VAR_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRIX_TO_VAR_MAP_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_MATRIX_TO_VAR_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS,1), MIN(LBOUND(Variable% &
      & EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS,2), MIN(LBOUND(Variable% &
        & EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS,2)+MaxArrayLength, UBOUND(Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EQUATIONS_MAPPING_LINEAR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CONTROL_LOOP_FIXED_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, Depth, MaxDepth, MaxArrayLength)
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable11

  ! iterator variables

  ! null pointers
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr3
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr9

  TYPE(CONTROL_LOOP_TYPE), POINTER :: Ptr0

  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable5)) THEN
    Variable2 => CheckVariable5
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  
  ! Variable%CONTROL_LOOP
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CONTROL_LOOP)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, PROBLEMS_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_FIXED_TYPE (Variable)
! Available CheckVariables are: HISTORY_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), PROBLEM_PTR_TYPE (CheckVariable7), CONTROL_LOOP_WHILE_TYPE (CheckVariable8), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable9), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable10), PROBLEM_TYPE (CheckVariable11), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr0 => Variable%CONTROL_LOOP
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CONTROL_LOOP"
      CALL Print_CONTROL_LOOP_TYPE(Variable% &
        & CONTROL_LOOP, CheckVariable8, CheckVariable1, Variable2, CheckVariable6, NullPtr0, CheckVariable4, NullPtr1, &
        & NullPtr2, NullPtr3, NullPtr4, NullPtr5, CheckVariable9, NullPtr6, NullPtr7, CheckVariable10, CheckVariable0, &
        & NullPtr8, CheckVariable2, CheckVariable3, CheckVariable7, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "CONTROL_LOOP (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ITERATION_NUMBER:                ", &
    & Variable%ITERATION_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "START_ITERATION:                 ", &
    & Variable%START_ITERATION
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "STOP_ITERATION:                  ", &
    & Variable%STOP_ITERATION
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ITERATION_INCREMENT:             ", &
    & Variable%ITERATION_INCREMENT

  
END SUBROUTINE Print_CONTROL_LOOP_FIXED_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DECOMPOSITION_LINES_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, Depth, MaxDepth, MaxArrayLength)
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DecompositionDataPointsType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable11

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr3
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr4
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr5
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr7
  TYPE(FIELDS_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: NullPtr11
  TYPE(REGION_TYPE), POINTER :: NullPtr12

  TYPE(DECOMPOSITION_TYPE), POINTER :: Ptr0

  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable8)) THEN
    Variable2 => CheckVariable8
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)

  
  ! Variable%DECOMPOSITION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DECOMPOSITION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "DECOMPOSITION " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_LINES_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DecompositionDataPointsType (CheckVariable6), DECOMPOSITION_FACES_TYPE (CheckVariable7), DECOMPOSITION_LINES_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITIONS_TYPE (CheckVariable10), DOMAIN_PTR_TYPE (CheckVariable11), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type DOMAIN_MAPPINGS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_MAPPINGS_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TOPOLOGY_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable6
! - signature type DECOMPOSITION_LINES_TYPE
!   is type of this print routine, use Variable2
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DECOMPOSITION
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DECOMPOSITION"
      CALL Print_DECOMPOSITION_TYPE(Variable% &
        & DECOMPOSITION, NullPtr0, NullPtr1, NullPtr2, CheckVariable5, NullPtr3, NullPtr4, CheckVariable9, NullPtr5, &
        & NullPtr6, CheckVariable3, NullPtr7, CheckVariable7, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr8, &
        & CheckVariable10, CheckVariable11, NullPtr9, NullPtr10, NullPtr11, CheckVariable4, CheckVariable6, Variable2, &
        & NullPtr12, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "DECOMPOSITION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LINES:                 ", &
    & Variable%NUMBER_OF_LINES
  
  ! Variable%LINES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LINES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LINES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_LINE_TYPE), ALLOCATABLE :: " // &
      & "LINES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LINES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%LINES,1), MIN(LBOUND(Variable%LINES,1)+MaxArrayLength, UBOUND(Variable%LINES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DECOMPOSITION_LINE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DECOMPOSITION_LINES_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DecompositionDataPointsType (CheckVariable6), DECOMPOSITION_FACES_TYPE (CheckVariable7), DECOMPOSITION_LINES_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITIONS_TYPE (CheckVariable10), DOMAIN_PTR_TYPE (CheckVariable11), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DECOMPOSITION_LINE_TYPE(Variable%LINES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_LINE_TYPE), ALLOCATABLE :: " // &
      & "LINES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DECOMPOSITION_LINES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
  & CheckVariable32, CheckVariable33, CheckVariable34, CheckVariable35, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable31
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable32
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable33
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable34
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable35

  ! iterator variables

  ! null pointers
  TYPE(FIELD_TYPE), POINTER :: NullPtr0
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr4

  TYPE(SOLVER_TYPE), POINTER :: Ptr0

  TYPE(SOLVER_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: SOLVER_PTR_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), PROBLEMS_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), NONLINEAR_SOLVER_TYPE (CheckVariable22), SOLVER_EQUATIONS_TYPE (CheckVariable23), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable24), SOLVER_MATRICES_TYPE (CheckVariable25), HISTORY_TYPE (CheckVariable26), DAE_SOLVER_TYPE (CheckVariable27), SOLVERS_TYPE (CheckVariable28), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable29), SOLVER_TYPE (CheckVariable30), SOLVER_MAPPING_TYPE (CheckVariable31), EULER_DAE_SOLVER_TYPE (CheckVariable32), PROBLEM_PTR_TYPE (CheckVariable33), LINEAR_SOLVER_TYPE (CheckVariable34), PROBLEM_TYPE (CheckVariable35), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable16
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable30
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable35

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable30)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_SOLVER_TYPE(Variable% &
        & PTR, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, CheckVariable3, CheckVariable4, NullPtr1, &
        & CheckVariable5, CheckVariable22, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
        & CheckVariable11, CheckVariable12, CheckVariable20, CheckVariable14, CheckVariable15, CheckVariable16, &
        & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable13, CheckVariable21, CheckVariable6, &
        & CheckVariable23, NullPtr2, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, &
        & CheckVariable29, CheckVariable30, NullPtr3, NullPtr4, CheckVariable31, CheckVariable32, CheckVariable33, &
        & CheckVariable34, CheckVariable35, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_SOLVER_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BASIS_TYPE(Variable, CheckVariable0, CheckVariable1, Depth, MaxDepth, MaxArrayLength)
  TYPE(BASIS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BASIS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(BASIS_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1, I2, I3
  CHARACTER(LEN=30) :: I0_STR, I1_STR, I2_STR, I3_STR

  ! null pointers

  TYPE(BASIS_PTR_TYPE), POINTER :: Ptr0
  TYPE(BASIS_TYPE), POINTER :: Ptr1

  TYPE(BASIS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable0)) THEN
    Variable2 => CheckVariable0
  ELSE
    Variable2 => Variable
  END IF 


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "FAMILY_NUMBER:                   ", &
    & Variable%FAMILY_NUMBER
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "BASIS_FINISHED:                                  ", &
    & Variable%BASIS_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "HERMITE:                                         ", &
    & Variable%HERMITE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TYPE:                            ", &
    & Variable%TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_XI:                    ", &
    & Variable%NUMBER_OF_XI
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_XI_COORDINATES:        ", &
    & Variable%NUMBER_OF_XI_COORDINATES
  
  ! Variable%INTERPOLATION_XI(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERPOLATION_XI)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERPOLATION_XI),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERPOLATION_XI(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERPOLATION_XI, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%INTERPOLATION_XI,1), MIN(LBOUND(Variable%INTERPOLATION_XI,1)+MaxArrayLength, UBOUND(Variable% &
      & INTERPOLATION_XI,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%INTERPOLATION_XI(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERPOLATION_XI(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERPOLATION_TYPE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERPOLATION_TYPE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERPOLATION_TYPE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERPOLATION_TYPE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERPOLATION_TYPE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%INTERPOLATION_TYPE,1), MIN(LBOUND(Variable% &
      & INTERPOLATION_TYPE,1)+MaxArrayLength, UBOUND(Variable%INTERPOLATION_TYPE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%INTERPOLATION_TYPE(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERPOLATION_TYPE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERPOLATION_ORDER(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERPOLATION_ORDER)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERPOLATION_ORDER),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERPOLATION_ORDER(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERPOLATION_ORDER, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%INTERPOLATION_ORDER,1), MIN(LBOUND(Variable% &
      & INTERPOLATION_ORDER,1)+MaxArrayLength, UBOUND(Variable%INTERPOLATION_ORDER,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%INTERPOLATION_ORDER(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "INTERPOLATION_ORDER(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "DEGENERATE:                                      ", &
    & Variable%DEGENERATE
  
  ! Variable%COLLAPSED_XI(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COLLAPSED_XI)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COLLAPSED_XI),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLLAPSED_XI(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COLLAPSED_XI, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COLLAPSED_XI,1), MIN(LBOUND(Variable%COLLAPSED_XI,1)+MaxArrayLength, UBOUND(Variable%COLLAPSED_XI,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COLLAPSED_XI(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "COLLAPSED_XI(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COLLAPSED_XI:          ", &
    & Variable%NUMBER_OF_COLLAPSED_XI
  
  ! Variable%NODE_AT_COLLAPSE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODE_AT_COLLAPSE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODE_AT_COLLAPSE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "LOGICAL, ALLOCATABLE :: " // &
      & "NODE_AT_COLLAPSE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODE_AT_COLLAPSE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NODE_AT_COLLAPSE,1), MIN(LBOUND(Variable%NODE_AT_COLLAPSE,1)+MaxArrayLength, UBOUND(Variable% &
      & NODE_AT_COLLAPSE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NODE_AT_COLLAPSE(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"LOGICAL, ALLOCATABLE :: " // &
      & "NODE_AT_COLLAPSE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_PARTIAL_DERIVATIVES:   ", &
    & Variable%NUMBER_OF_PARTIAL_DERIVATIVES
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_NODES:                 ", &
    & Variable%NUMBER_OF_NODES
  
  ! Variable%NUMBER_OF_NODES_XIC(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_NODES_XIC)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_NODES_XIC),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_NODES_XIC(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_NODES_XIC, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_NODES_XIC,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_NODES_XIC,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_NODES_XIC,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_NODES_XIC(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_NODES_XIC(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ELEMENT_PARAMETERS:    ", &
    & Variable%NUMBER_OF_ELEMENT_PARAMETERS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_DERIVATIVES:   ", &
    & Variable%MAXIMUM_NUMBER_OF_DERIVATIVES
  
  ! Variable%NUMBER_OF_DERIVATIVES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_DERIVATIVES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_DERIVATIVES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_DERIVATIVES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_DERIVATIVES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_DERIVATIVES,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_DERIVATIVES,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_DERIVATIVES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_DERIVATIVES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_DERIVATIVES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NODE_POSITION_INDEX(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODE_POSITION_INDEX)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODE_POSITION_INDEX),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_POSITION_INDEX(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODE_POSITION_INDEX, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NODE_POSITION_INDEX,1), MIN(LBOUND(Variable% &
      & NODE_POSITION_INDEX,1)+MaxArrayLength, UBOUND(Variable%NODE_POSITION_INDEX,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%NODE_POSITION_INDEX,2), MIN(LBOUND(Variable% &
        & NODE_POSITION_INDEX,2)+MaxArrayLength, UBOUND(Variable%NODE_POSITION_INDEX,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%NODE_POSITION_INDEX(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_POSITION_INDEX(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NODE_POSITION_INDEX_INV(:,:,:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODE_POSITION_INDEX_INV)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODE_POSITION_INDEX_INV),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_POSITION_INDEX_INV(:,:,:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODE_POSITION_INDEX_INV, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NODE_POSITION_INDEX_INV,1), MIN(LBOUND(Variable% &
      & NODE_POSITION_INDEX_INV,1)+MaxArrayLength, UBOUND(Variable%NODE_POSITION_INDEX_INV,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%NODE_POSITION_INDEX_INV,2), MIN(LBOUND(Variable% &
        & NODE_POSITION_INDEX_INV,2)+MaxArrayLength, UBOUND(Variable%NODE_POSITION_INDEX_INV,2))
        WRITE(I1_STR,"(I4)") I1 

        DO I2 = LBOUND(Variable%NODE_POSITION_INDEX_INV,3), MIN(LBOUND(Variable% &
          & NODE_POSITION_INDEX_INV,3)+MaxArrayLength, UBOUND(Variable%NODE_POSITION_INDEX_INV,3))
          WRITE(I2_STR,"(I4)") I2 

          PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//","//TRIM(ADJUSTL(I1_STR))//","//TRIM(ADJUSTL(I2_STR))//",*): "
          DO I3 = LBOUND(Variable%NODE_POSITION_INDEX_INV,4), MIN(LBOUND(Variable% &
            & NODE_POSITION_INDEX_INV,4)+MaxArrayLength, UBOUND(Variable%NODE_POSITION_INDEX_INV,4))
            WRITE(I3_STR,"(I4)") I3 

            PRINT*, TRIM(PrintIndent), Variable%NODE_POSITION_INDEX_INV(I0,I1,I2,I3)

          ENDDO  ! I3
        ENDDO  ! I2
      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_POSITION_INDEX_INV(:,:,:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DERIVATIVE_ORDER_INDEX(:,:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DERIVATIVE_ORDER_INDEX)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DERIVATIVE_ORDER_INDEX),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DERIVATIVE_ORDER_INDEX(:,:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DERIVATIVE_ORDER_INDEX, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DERIVATIVE_ORDER_INDEX,1), MIN(LBOUND(Variable% &
      & DERIVATIVE_ORDER_INDEX,1)+MaxArrayLength, UBOUND(Variable%DERIVATIVE_ORDER_INDEX,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%DERIVATIVE_ORDER_INDEX,2), MIN(LBOUND(Variable% &
        & DERIVATIVE_ORDER_INDEX,2)+MaxArrayLength, UBOUND(Variable%DERIVATIVE_ORDER_INDEX,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//","//TRIM(ADJUSTL(I1_STR))//",*): "
        DO I2 = LBOUND(Variable%DERIVATIVE_ORDER_INDEX,3), MIN(LBOUND(Variable% &
          & DERIVATIVE_ORDER_INDEX,3)+MaxArrayLength, UBOUND(Variable%DERIVATIVE_ORDER_INDEX,3))
          WRITE(I2_STR,"(I4)") I2 

          PRINT*, TRIM(PrintIndent), Variable%DERIVATIVE_ORDER_INDEX(I0,I1,I2)

        ENDDO  ! I2
      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DERIVATIVE_ORDER_INDEX(:,:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DERIVATIVE_ORDER_INDEX_INV(:,:,:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DERIVATIVE_ORDER_INDEX_INV)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DERIVATIVE_ORDER_INDEX_INV),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DERIVATIVE_ORDER_INDEX_INV(:,:,:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DERIVATIVE_ORDER_INDEX_INV, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DERIVATIVE_ORDER_INDEX_INV,1), MIN(LBOUND(Variable% &
      & DERIVATIVE_ORDER_INDEX_INV,1)+MaxArrayLength, UBOUND(Variable%DERIVATIVE_ORDER_INDEX_INV,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%DERIVATIVE_ORDER_INDEX_INV,2), MIN(LBOUND(Variable% &
        & DERIVATIVE_ORDER_INDEX_INV,2)+MaxArrayLength, UBOUND(Variable%DERIVATIVE_ORDER_INDEX_INV,2))
        WRITE(I1_STR,"(I4)") I1 

        DO I2 = LBOUND(Variable%DERIVATIVE_ORDER_INDEX_INV,3), MIN(LBOUND(Variable% &
          & DERIVATIVE_ORDER_INDEX_INV,3)+MaxArrayLength, UBOUND(Variable%DERIVATIVE_ORDER_INDEX_INV,3))
          WRITE(I2_STR,"(I4)") I2 

          PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//","//TRIM(ADJUSTL(I1_STR))//","//TRIM(ADJUSTL(I2_STR))//",*): "
          DO I3 = LBOUND(Variable%DERIVATIVE_ORDER_INDEX_INV,4), MIN(LBOUND(Variable% &
            & DERIVATIVE_ORDER_INDEX_INV,4)+MaxArrayLength, UBOUND(Variable%DERIVATIVE_ORDER_INDEX_INV,4))
            WRITE(I3_STR,"(I4)") I3 

            PRINT*, TRIM(PrintIndent), Variable%DERIVATIVE_ORDER_INDEX_INV(I0,I1,I2,I3)

          ENDDO  ! I3
        ENDDO  ! I2
      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DERIVATIVE_ORDER_INDEX_INV(:,:,:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%PARTIAL_DERIVATIVE_INDEX(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%PARTIAL_DERIVATIVE_INDEX)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%PARTIAL_DERIVATIVE_INDEX),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "PARTIAL_DERIVATIVE_INDEX(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%PARTIAL_DERIVATIVE_INDEX, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%PARTIAL_DERIVATIVE_INDEX,1), MIN(LBOUND(Variable% &
      & PARTIAL_DERIVATIVE_INDEX,1)+MaxArrayLength, UBOUND(Variable%PARTIAL_DERIVATIVE_INDEX,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%PARTIAL_DERIVATIVE_INDEX,2), MIN(LBOUND(Variable% &
        & PARTIAL_DERIVATIVE_INDEX,2)+MaxArrayLength, UBOUND(Variable%PARTIAL_DERIVATIVE_INDEX,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%PARTIAL_DERIVATIVE_INDEX(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "PARTIAL_DERIVATIVE_INDEX(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ELEMENT_PARAMETER_INDEX(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_PARAMETER_INDEX)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_PARAMETER_INDEX),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_PARAMETER_INDEX(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_PARAMETER_INDEX, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENT_PARAMETER_INDEX,1), MIN(LBOUND(Variable% &
      & ELEMENT_PARAMETER_INDEX,1)+MaxArrayLength, UBOUND(Variable%ELEMENT_PARAMETER_INDEX,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%ELEMENT_PARAMETER_INDEX,2), MIN(LBOUND(Variable% &
        & ELEMENT_PARAMETER_INDEX,2)+MaxArrayLength, UBOUND(Variable%ELEMENT_PARAMETER_INDEX,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%ELEMENT_PARAMETER_INDEX(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_PARAMETER_INDEX(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ELEMENT_PARAMETER_INDEX_INV(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_PARAMETER_INDEX_INV)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_PARAMETER_INDEX_INV),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_PARAMETER_INDEX_INV(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_PARAMETER_INDEX_INV, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENT_PARAMETER_INDEX_INV,1), MIN(LBOUND(Variable% &
      & ELEMENT_PARAMETER_INDEX_INV,1)+MaxArrayLength, UBOUND(Variable%ELEMENT_PARAMETER_INDEX_INV,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%ELEMENT_PARAMETER_INDEX_INV,2), MIN(LBOUND(Variable% &
        & ELEMENT_PARAMETER_INDEX_INV,2)+MaxArrayLength, UBOUND(Variable%ELEMENT_PARAMETER_INDEX_INV,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%ELEMENT_PARAMETER_INDEX_INV(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_PARAMETER_INDEX_INV(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LOCAL_LINES:           ", &
    & Variable%NUMBER_OF_LOCAL_LINES
  
  ! Variable%LOCAL_LINE_XI_DIRECTION(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LOCAL_LINE_XI_DIRECTION)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LOCAL_LINE_XI_DIRECTION),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_LINE_XI_DIRECTION(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LOCAL_LINE_XI_DIRECTION, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LOCAL_LINE_XI_DIRECTION,1), MIN(LBOUND(Variable% &
      & LOCAL_LINE_XI_DIRECTION,1)+MaxArrayLength, UBOUND(Variable%LOCAL_LINE_XI_DIRECTION,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LOCAL_LINE_XI_DIRECTION(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_LINE_XI_DIRECTION(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NUMBER_OF_NODES_IN_LOCAL_LINE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_NODES_IN_LOCAL_LINE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_NODES_IN_LOCAL_LINE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_NODES_IN_LOCAL_LINE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_NODES_IN_LOCAL_LINE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_NODES_IN_LOCAL_LINE,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_NODES_IN_LOCAL_LINE,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_NODES_IN_LOCAL_LINE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_NODES_IN_LOCAL_LINE(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_NODES_IN_LOCAL_LINE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NODE_NUMBERS_IN_LOCAL_LINE(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODE_NUMBERS_IN_LOCAL_LINE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODE_NUMBERS_IN_LOCAL_LINE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_NUMBERS_IN_LOCAL_LINE(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODE_NUMBERS_IN_LOCAL_LINE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NODE_NUMBERS_IN_LOCAL_LINE,1), MIN(LBOUND(Variable% &
      & NODE_NUMBERS_IN_LOCAL_LINE,1)+MaxArrayLength, UBOUND(Variable%NODE_NUMBERS_IN_LOCAL_LINE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%NODE_NUMBERS_IN_LOCAL_LINE,2), MIN(LBOUND(Variable% &
        & NODE_NUMBERS_IN_LOCAL_LINE,2)+MaxArrayLength, UBOUND(Variable%NODE_NUMBERS_IN_LOCAL_LINE,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%NODE_NUMBERS_IN_LOCAL_LINE(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_NUMBERS_IN_LOCAL_LINE(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DERIVATIVE_NUMBERS_IN_LOCAL_LINE(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_LINE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_LINE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DERIVATIVE_NUMBERS_IN_LOCAL_LINE(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_LINE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_LINE,1), MIN(LBOUND(Variable% &
      & DERIVATIVE_NUMBERS_IN_LOCAL_LINE,1)+MaxArrayLength, UBOUND(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_LINE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_LINE,2), MIN(LBOUND(Variable% &
        & DERIVATIVE_NUMBERS_IN_LOCAL_LINE,2)+MaxArrayLength, UBOUND(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_LINE,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%DERIVATIVE_NUMBERS_IN_LOCAL_LINE(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DERIVATIVE_NUMBERS_IN_LOCAL_LINE(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ELEMENT_PARAMETERS_IN_LOCAL_LINE(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_PARAMETERS_IN_LOCAL_LINE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_PARAMETERS_IN_LOCAL_LINE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_PARAMETERS_IN_LOCAL_LINE(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_PARAMETERS_IN_LOCAL_LINE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENT_PARAMETERS_IN_LOCAL_LINE,1), MIN(LBOUND(Variable% &
      & ELEMENT_PARAMETERS_IN_LOCAL_LINE,1)+MaxArrayLength, UBOUND(Variable%ELEMENT_PARAMETERS_IN_LOCAL_LINE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%ELEMENT_PARAMETERS_IN_LOCAL_LINE,2), MIN(LBOUND(Variable% &
        & ELEMENT_PARAMETERS_IN_LOCAL_LINE,2)+MaxArrayLength, UBOUND(Variable%ELEMENT_PARAMETERS_IN_LOCAL_LINE,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%ELEMENT_PARAMETERS_IN_LOCAL_LINE(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_PARAMETERS_IN_LOCAL_LINE(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LOCAL_FACES:           ", &
    & Variable%NUMBER_OF_LOCAL_FACES
  
  ! Variable%LOCAL_FACE_XI_DIRECTION(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LOCAL_FACE_XI_DIRECTION)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LOCAL_FACE_XI_DIRECTION),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_FACE_XI_DIRECTION(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LOCAL_FACE_XI_DIRECTION, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LOCAL_FACE_XI_DIRECTION,1), MIN(LBOUND(Variable% &
      & LOCAL_FACE_XI_DIRECTION,1)+MaxArrayLength, UBOUND(Variable%LOCAL_FACE_XI_DIRECTION,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LOCAL_FACE_XI_DIRECTION(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_FACE_XI_DIRECTION(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NUMBER_OF_NODES_IN_LOCAL_FACE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NUMBER_OF_NODES_IN_LOCAL_FACE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NUMBER_OF_NODES_IN_LOCAL_FACE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_NODES_IN_LOCAL_FACE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NUMBER_OF_NODES_IN_LOCAL_FACE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NUMBER_OF_NODES_IN_LOCAL_FACE,1), MIN(LBOUND(Variable% &
      & NUMBER_OF_NODES_IN_LOCAL_FACE,1)+MaxArrayLength, UBOUND(Variable%NUMBER_OF_NODES_IN_LOCAL_FACE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NUMBER_OF_NODES_IN_LOCAL_FACE(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NUMBER_OF_NODES_IN_LOCAL_FACE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NODE_NUMBERS_IN_LOCAL_FACE(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODE_NUMBERS_IN_LOCAL_FACE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODE_NUMBERS_IN_LOCAL_FACE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_NUMBERS_IN_LOCAL_FACE(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODE_NUMBERS_IN_LOCAL_FACE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NODE_NUMBERS_IN_LOCAL_FACE,1), MIN(LBOUND(Variable% &
      & NODE_NUMBERS_IN_LOCAL_FACE,1)+MaxArrayLength, UBOUND(Variable%NODE_NUMBERS_IN_LOCAL_FACE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%NODE_NUMBERS_IN_LOCAL_FACE,2), MIN(LBOUND(Variable% &
        & NODE_NUMBERS_IN_LOCAL_FACE,2)+MaxArrayLength, UBOUND(Variable%NODE_NUMBERS_IN_LOCAL_FACE,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%NODE_NUMBERS_IN_LOCAL_FACE(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_NUMBERS_IN_LOCAL_FACE(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DERIVATIVE_NUMBERS_IN_LOCAL_FACE(:,:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_FACE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_FACE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DERIVATIVE_NUMBERS_IN_LOCAL_FACE(:,:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_FACE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_FACE,1), MIN(LBOUND(Variable% &
      & DERIVATIVE_NUMBERS_IN_LOCAL_FACE,1)+MaxArrayLength, UBOUND(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_FACE,1))
      WRITE(I0_STR,"(I4)") I0 

      DO I1 = LBOUND(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_FACE,2), MIN(LBOUND(Variable% &
        & DERIVATIVE_NUMBERS_IN_LOCAL_FACE,2)+MaxArrayLength, UBOUND(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_FACE,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//","//TRIM(ADJUSTL(I1_STR))//",*): "
        DO I2 = LBOUND(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_FACE,3), MIN(LBOUND(Variable% &
          & DERIVATIVE_NUMBERS_IN_LOCAL_FACE,3)+MaxArrayLength, UBOUND(Variable%DERIVATIVE_NUMBERS_IN_LOCAL_FACE,3))
          WRITE(I2_STR,"(I4)") I2 

          PRINT*, TRIM(PrintIndent), Variable%DERIVATIVE_NUMBERS_IN_LOCAL_FACE(I0,I1,I2)

        ENDDO  ! I2
      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DERIVATIVE_NUMBERS_IN_LOCAL_FACE(:,:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ELEMENT_PARAMETERS_IN_LOCAL_FACE(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_PARAMETERS_IN_LOCAL_FACE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_PARAMETERS_IN_LOCAL_FACE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_PARAMETERS_IN_LOCAL_FACE(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_PARAMETERS_IN_LOCAL_FACE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENT_PARAMETERS_IN_LOCAL_FACE,1), MIN(LBOUND(Variable% &
      & ELEMENT_PARAMETERS_IN_LOCAL_FACE,1)+MaxArrayLength, UBOUND(Variable%ELEMENT_PARAMETERS_IN_LOCAL_FACE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%ELEMENT_PARAMETERS_IN_LOCAL_FACE,2), MIN(LBOUND(Variable% &
        & ELEMENT_PARAMETERS_IN_LOCAL_FACE,2)+MaxArrayLength, UBOUND(Variable%ELEMENT_PARAMETERS_IN_LOCAL_FACE,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%ELEMENT_PARAMETERS_IN_LOCAL_FACE(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_PARAMETERS_IN_LOCAL_FACE(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LOCAL_XI_NORMAL(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LOCAL_XI_NORMAL)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LOCAL_XI_NORMAL),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_XI_NORMAL(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LOCAL_XI_NORMAL, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LOCAL_XI_NORMAL,1), MIN(LBOUND(Variable%LOCAL_XI_NORMAL,1)+MaxArrayLength, UBOUND(Variable% &
      & LOCAL_XI_NORMAL,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LOCAL_XI_NORMAL(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_XI_NORMAL(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LINE_BASES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%LINE_BASES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_PTR_TYPE), POINTER :: " // &
      & "LINE_BASES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%LINE_BASES,1), "): "
  
    DO I0 = LBOUND(Variable%LINE_BASES,1), MIN(LBOUND(Variable%LINE_BASES,1)+MaxArrayLength, UBOUND(Variable%LINE_BASES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_BASIS_PTR_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: BASIS_TYPE (Variable)
! Available CheckVariables are: BASIS_TYPE (CheckVariable0), BASIS_PTR_TYPE (CheckVariable1), 
! - signature type BASIS_TYPE
!   is type of this print routine, use Variable2
! - signature type BASIS_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1

      ! if variable was already followed
      Ptr0 => Variable%LINE_BASES(I0)
      IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINE_BASES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_BASIS_PTR_TYPE(Variable%LINE_BASES(I0), Variable2, CheckVariable1, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_PTR_TYPE), POINTER :: " // &
      & "LINE_BASES(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%FACE_BASES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%FACE_BASES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_PTR_TYPE), POINTER :: " // &
      & "FACE_BASES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%FACE_BASES,1), "): "
  
    DO I0 = LBOUND(Variable%FACE_BASES,1), MIN(LBOUND(Variable%FACE_BASES,1)+MaxArrayLength, UBOUND(Variable%FACE_BASES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_BASIS_PTR_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: BASIS_TYPE (Variable)
! Available CheckVariables are: BASIS_TYPE (CheckVariable0), BASIS_PTR_TYPE (CheckVariable1), 
! - signature type BASIS_TYPE
!   is type of this print routine, use Variable2
! - signature type BASIS_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1

      ! if variable was already followed
      Ptr0 => Variable%FACE_BASES(I0)
      IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FACE_BASES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_BASIS_PTR_TYPE(Variable%FACE_BASES(I0), Variable2, CheckVariable1, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_PTR_TYPE), POINTER :: " // &
      & "FACE_BASES(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SUB_BASES:             ", &
    & Variable%NUMBER_OF_SUB_BASES
  
  ! Variable%SUB_BASES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%SUB_BASES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_PTR_TYPE), POINTER :: " // &
      & "SUB_BASES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%SUB_BASES,1), "): "
  
    DO I0 = LBOUND(Variable%SUB_BASES,1), MIN(LBOUND(Variable%SUB_BASES,1)+MaxArrayLength, UBOUND(Variable%SUB_BASES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_BASIS_PTR_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: BASIS_TYPE (Variable)
! Available CheckVariables are: BASIS_TYPE (CheckVariable0), BASIS_PTR_TYPE (CheckVariable1), 
! - signature type BASIS_TYPE
!   is type of this print routine, use Variable2
! - signature type BASIS_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1

      ! if variable was already followed
      Ptr0 => Variable%SUB_BASES(I0)
      IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SUB_BASES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_BASIS_PTR_TYPE(Variable%SUB_BASES(I0), Variable2, CheckVariable1, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_PTR_TYPE), POINTER :: " // &
      & "SUB_BASES(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%PARENT_BASIS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PARENT_BASIS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BASIS_TYPE), POINTER :: " // &
      & "PARENT_BASIS " // &
      & "(associated): " 
  
! Signature of Print_BASIS_TYPE has the following CheckVariable types: BASIS_TYPE, BASIS_PTR_TYPE, 
! The type to handle in this routine is: BASIS_TYPE (Variable)
! Available CheckVariables are: BASIS_TYPE (CheckVariable0), BASIS_PTR_TYPE (CheckVariable1), 
! - signature type BASIS_TYPE
!   is type of this print routine, use Variable2
! - signature type BASIS_PTR_TYPE
!   matches available passing type, use it as CheckVariable1

    ! if variable was already followed
    Ptr1 => Variable%PARENT_BASIS
    IF (ASSOCIATED(Ptr1, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PARENT_BASIS"
      CALL Print_BASIS_TYPE(Variable%PARENT_BASIS, Variable2, CheckVariable1, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BASIS_TYPE), POINTER :: " // &
      & "PARENT_BASIS (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_BASIS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_SETS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable16

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr0
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr2
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr3
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr4
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_TYPE), POINTER :: NullPtr8
  TYPE(MESH_TYPE), POINTER :: NullPtr9
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr11
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr12
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr13
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr14
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr15
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr16
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr17
  TYPE(SOLVER_TYPE), POINTER :: NullPtr18
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr19
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr20

  TYPE(REGION_TYPE), POINTER :: Ptr0
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: Ptr1

  TYPE(EQUATIONS_SETS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable14)) THEN
    Variable2 => CheckVariable14
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)

  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE) , POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_SETS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), MESHES_TYPE (CheckVariable2), FIELDS_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), INTERFACES_TYPE (CheckVariable6), EQUATIONS_SET_PTR_TYPE (CheckVariable7), GENERATED_MESHES_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), CONTROL_LOOP_TYPE (CheckVariable10), INTERFACE_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), NODES_TYPE (CheckVariable13), EQUATIONS_SETS_TYPE (CheckVariable14), REGION_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable15

    ! if variable was already followed
    Ptr0 => Variable%REGION
    IF (ASSOCIATED(Ptr0, CheckVariable15)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, CheckVariable2, NullPtr0, NullPtr1, CheckVariable1, NullPtr2, NullPtr3, CheckVariable9, CheckVariable5, &
        & NullPtr4, Variable2, CheckVariable11, NullPtr5, NullPtr6, NullPtr7, CheckVariable12, CheckVariable10, NullPtr8, &
        & NullPtr9, CheckVariable3, CheckVariable8, NullPtr10, CheckVariable13, NullPtr11, CheckVariable6, CheckVariable16, &
        & NullPtr12, CheckVariable0, NullPtr13, CheckVariable4, CheckVariable7, NullPtr14, CheckVariable15, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE) , POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_EQUATIONS_SETS:        ", &
    & Variable%NUMBER_OF_EQUATIONS_SETS
  
  ! Variable%EQUATIONS_SETS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SETS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: " // &
      & "EQUATIONS_SETS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%EQUATIONS_SETS,1), "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_SETS,1), MIN(LBOUND(Variable%EQUATIONS_SETS,1)+MaxArrayLength, UBOUND(Variable% &
      & EQUATIONS_SETS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_SET_PTR_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, SOLVER_EQUATIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, GENERATED_MESHES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_SETS_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), MESHES_TYPE (CheckVariable2), FIELDS_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), REGION_PTR_TYPE (CheckVariable5), INTERFACES_TYPE (CheckVariable6), EQUATIONS_SET_PTR_TYPE (CheckVariable7), GENERATED_MESHES_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), CONTROL_LOOP_TYPE (CheckVariable10), INTERFACE_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), NODES_TYPE (CheckVariable13), EQUATIONS_SETS_TYPE (CheckVariable14), REGION_TYPE (CheckVariable15), DATA_POINTS_TYPE (CheckVariable16), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EQUATIONS_SETS_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable7
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable15

      ! if variable was already followed
      Ptr1 => Variable%EQUATIONS_SETS(I0)
      IF (ASSOCIATED(Ptr1, CheckVariable7)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SETS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_SET_PTR_TYPE(Variable% &
          & EQUATIONS_SETS(I0), CheckVariable2, CheckVariable9, CheckVariable5, Variable2, CheckVariable11, &
          & CheckVariable12, CheckVariable10, CheckVariable1, NullPtr15, CheckVariable3, NullPtr16, CheckVariable13, &
          & CheckVariable6, CheckVariable16, CheckVariable0, NullPtr17, CheckVariable4, NullPtr18, NullPtr19, NullPtr20, &
          & CheckVariable7, CheckVariable8, CheckVariable15, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: " // &
      & "EQUATIONS_SETS(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_SETS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MESH_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MeshComponentTopologyType), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable24

  ! iterator variables

  ! null pointers
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: NullPtr0
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: NullPtr1
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr2
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr3
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr5
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: NullPtr6

  TYPE(MESH_TYPE), POINTER :: Ptr0

  TYPE(MESH_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable2)) THEN
    Variable2 => CheckVariable2
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, REGION_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESH_PTR_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), DECOMPOSITION_PTR_TYPE (CheckVariable13), MESH_TYPE (CheckVariable14), MeshComponentTopologyPtrType (CheckVariable15), FIELDS_TYPE (CheckVariable16), GENERATED_MESHES_TYPE (CheckVariable17), DECOMPOSITIONS_TYPE (CheckVariable18), NODES_TYPE (CheckVariable19), INTERFACES_TYPE (CheckVariable20), DATA_POINTS_TYPE (CheckVariable21), DATA_PROJECTION_TYPE (CheckVariable22), DECOMPOSITION_TYPE (CheckVariable23), REGION_TYPE (CheckVariable24), 
! - signature type MeshComponentTopologyType
!   matches available passing type, use it as CheckVariable0
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_CYLINDER_TYPE
! - signature type MESH_PTR_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_ELLIPSOID_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable15
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable14
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_REGULAR_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable24

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable14)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_MESH_TYPE(Variable% &
        & PTR, CheckVariable0, CheckVariable1, NullPtr0, Variable2, CheckVariable3, NullPtr1, NullPtr2, CheckVariable4, &
        & CheckVariable5, CheckVariable6, CheckVariable15, CheckVariable8, CheckVariable9, NullPtr3, CheckVariable10, &
        & CheckVariable7, CheckVariable11, CheckVariable12, CheckVariable14, CheckVariable13, CheckVariable16, &
        & CheckVariable17, CheckVariable18, CheckVariable19, NullPtr4, CheckVariable20, CheckVariable21, NullPtr5, &
        & CheckVariable22, NullPtr6, CheckVariable23, CheckVariable24, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_MESH_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DISTRIBUTED_MATRIX_TYPE(Variable, CheckVariable0, CheckVariable1, Depth, MaxDepth, MaxArrayLength)
  TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER, INTENT(IN) :: CheckVariable1

  ! iterator variables

  ! null pointers

  TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER :: Ptr0
  TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER :: Ptr1

  TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "MATRIX_FINISHED:                                 ", &
    & Variable%MATRIX_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LIBRARY_TYPE:                    ", &
    & Variable%LIBRARY_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GHOSTING_TYPE:                   ", &
    & Variable%GHOSTING_TYPE
  
  ! Variable%ROW_DOMAIN_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ROW_DOMAIN_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "ROW_DOMAIN_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DISTRIBUTED_MATRIX_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_MATRIX_CMISS_TYPE (CheckVariable0), DISTRIBUTED_MATRIX_PETSC_TYPE (CheckVariable1), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ROW_DOMAIN_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%ROW_DOMAIN_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "ROW_DOMAIN_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%COLUMN_DOMAIN_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%COLUMN_DOMAIN_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "COLUMN_DOMAIN_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DISTRIBUTED_MATRIX_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_MATRIX_CMISS_TYPE (CheckVariable0), DISTRIBUTED_MATRIX_PETSC_TYPE (CheckVariable1), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"COLUMN_DOMAIN_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%COLUMN_DOMAIN_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "COLUMN_DOMAIN_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DATA_TYPE:                       ", &
    & Variable%DATA_TYPE
  
  ! Variable%CMISS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CMISS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER :: " // &
      & "CMISS " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_MATRIX_CMISS_TYPE has the following CheckVariable types: DISTRIBUTED_MATRIX_TYPE, 
! The type to handle in this routine is: DISTRIBUTED_MATRIX_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_MATRIX_CMISS_TYPE (CheckVariable0), DISTRIBUTED_MATRIX_PETSC_TYPE (CheckVariable1), 
! - signature type DISTRIBUTED_MATRIX_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr0 => Variable%CMISS
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CMISS"
      CALL Print_DISTRIBUTED_MATRIX_CMISS_TYPE(Variable%CMISS, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER :: " // &
      & "CMISS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%PETSC
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PETSC)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER :: " // &
      & "PETSC " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_MATRIX_PETSC_TYPE has the following CheckVariable types: DISTRIBUTED_MATRIX_TYPE, 
! The type to handle in this routine is: DISTRIBUTED_MATRIX_TYPE (Variable)
! Available CheckVariables are: DISTRIBUTED_MATRIX_CMISS_TYPE (CheckVariable0), DISTRIBUTED_MATRIX_PETSC_TYPE (CheckVariable1), 
! - signature type DISTRIBUTED_MATRIX_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr1 => Variable%PETSC
    IF (ASSOCIATED(Ptr1, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PETSC"
      CALL Print_DISTRIBUTED_MATRIX_PETSC_TYPE(Variable%PETSC, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER :: " // &
      & "PETSC (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DISTRIBUTED_MATRIX_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DOMAIN_GLOBAL_MAPPING_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DOMAIN_GLOBAL_MAPPING_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(DOMAIN_GLOBAL_MAPPING_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DOMAINS:               ", &
    & Variable%NUMBER_OF_DOMAINS
  
  ! Variable%LOCAL_NUMBER(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LOCAL_NUMBER)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LOCAL_NUMBER),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_NUMBER(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LOCAL_NUMBER, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LOCAL_NUMBER,1), MIN(LBOUND(Variable%LOCAL_NUMBER,1)+MaxArrayLength, UBOUND(Variable%LOCAL_NUMBER,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LOCAL_NUMBER(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_NUMBER(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DOMAIN_NUMBER(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOMAIN_NUMBER)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOMAIN_NUMBER),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOMAIN_NUMBER(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOMAIN_NUMBER, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DOMAIN_NUMBER,1), MIN(LBOUND(Variable%DOMAIN_NUMBER,1)+MaxArrayLength, UBOUND(Variable%DOMAIN_NUMBER,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%DOMAIN_NUMBER(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOMAIN_NUMBER(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LOCAL_TYPE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LOCAL_TYPE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LOCAL_TYPE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_TYPE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LOCAL_TYPE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%LOCAL_TYPE,1), MIN(LBOUND(Variable%LOCAL_TYPE,1)+MaxArrayLength, UBOUND(Variable%LOCAL_TYPE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%LOCAL_TYPE(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "LOCAL_TYPE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DOMAIN_GLOBAL_MAPPING_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_ROW_TO_SOLVER_ROWS_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_ROW_TO_SOLVER_ROWS_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(EQUATIONS_ROW_TO_SOLVER_ROWS_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SOLVER_ROWS:           ", &
    & Variable%NUMBER_OF_SOLVER_ROWS
  
  ! Variable%SOLVER_ROWS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOLVER_ROWS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOLVER_ROWS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "SOLVER_ROWS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOLVER_ROWS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SOLVER_ROWS,1), MIN(LBOUND(Variable%SOLVER_ROWS,1)+MaxArrayLength, UBOUND(Variable%SOLVER_ROWS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SOLVER_ROWS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "SOLVER_ROWS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COUPLING_COEFFICIENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COUPLING_COEFFICIENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COUPLING_COEFFICIENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COUPLING_COEFFICIENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COUPLING_COEFFICIENTS,1), MIN(LBOUND(Variable% &
      & COUPLING_COEFFICIENTS,1)+MaxArrayLength, UBOUND(Variable%COUPLING_COEFFICIENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COUPLING_COEFFICIENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EQUATIONS_ROW_TO_SOLVER_ROWS_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TO_SOLVER_MAPS_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_TO_SOLVER_MAPS_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_EQUATIONS_TO_SOLVER_MAPS_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TO_SOLVER_MAPS_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_INTERPOLATED_POINT_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers
  TYPE(FIELD_TYPE), POINTER :: NullPtr0


  TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)

  
  ! Variable%INTERPOLATION_PARAMETERS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERPOLATION_PARAMETERS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: " // &
      & "INTERPOLATION_PARAMETERS " // &
      & "(associated): " 
  
! Signature of Print_FIELD_INTERPOLATION_PARAMETERS_TYPE has the following CheckVariable types: FIELD_TYPE, 
! The type to handle in this routine is: FIELD_INTERPOLATED_POINT_TYPE (Variable)
! Available CheckVariables are: 
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERPOLATION_PARAMETERS"
      CALL Print_FIELD_INTERPOLATION_PARAMETERS_TYPE(Variable%INTERPOLATION_PARAMETERS, NullPtr0, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: " // &
      & "INTERPOLATION_PARAMETERS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAX_PARTIAL_DERIVATIVE_INDEX:    ", &
    & Variable%MAX_PARTIAL_DERIVATIVE_INDEX
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "PARTIAL_DERIVATIVE_TYPE:         ", &
    & Variable%PARTIAL_DERIVATIVE_TYPE
  
  ! Variable%VALUES(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VALUES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VALUES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "VALUES(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VALUES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%VALUES,1), MIN(LBOUND(Variable%VALUES,1)+MaxArrayLength, UBOUND(Variable%VALUES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%VALUES,2), MIN(LBOUND(Variable%VALUES,2)+MaxArrayLength, UBOUND(Variable%VALUES,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%VALUES(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "VALUES(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_INTERPOLATED_POINT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_MODEL_MAP_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_MODEL_MAP_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(CELLML_MODEL_MAP_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_MODEL_MAP_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_CELLML_MODEL_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: CELLML_MODEL_MAP_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_CELLML_MODEL_MAP_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_MODEL_MAP_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_CELLML_MODEL_MAP_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BoundaryConditionsDofConstraintsType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(BoundaryConditionsDofConstraintsType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(BoundaryConditionsDofConstraintsType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfConstraints:             ", &
    & Variable%numberOfConstraints
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfDofs:                    ", &
    & Variable%numberOfDofs
  
  ! Variable%constraints(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%constraints)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%constraints),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BoundaryConditionsDofConstraintPtrType), ALLOCATABLE :: " // &
      & "constraints(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%constraints, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%constraints,1), MIN(LBOUND(Variable%constraints,1)+MaxArrayLength, UBOUND(Variable%constraints,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_BoundaryConditionsDofConstraintPtrType has the following CheckVariable types: 
! The type to handle in this routine is: BoundaryConditionsDofConstraintsType (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"constraints("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_BoundaryConditionsDofConstraintPtrType(Variable%constraints(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BoundaryConditionsDofConstraintPtrType), ALLOCATABLE :: " // &
      & "constraints(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%dofCouplings(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%dofCouplings)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%dofCouplings),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BoundaryConditionsCoupledDofsPtrType), ALLOCATABLE :: " // &
      & "dofCouplings(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%dofCouplings, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%dofCouplings,1), MIN(LBOUND(Variable%dofCouplings,1)+MaxArrayLength, UBOUND(Variable%dofCouplings,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_BoundaryConditionsCoupledDofsPtrType has the following CheckVariable types: 
! The type to handle in this routine is: BoundaryConditionsDofConstraintsType (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"dofCouplings("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_BoundaryConditionsCoupledDofsPtrType(Variable%dofCouplings(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BoundaryConditionsCoupledDofsPtrType), ALLOCATABLE :: " // &
      & "dofCouplings(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_BoundaryConditionsDofConstraintsType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_PARAMETER_SET_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_PARAMETER_SET_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: NullPtr0
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr1
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: NullPtr2


  TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SET_INDEX:                       ", &
    & Variable%SET_INDEX
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SET_TYPE:                        ", &
    & Variable%SET_TYPE
  
  ! Variable%PARAMETERS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PARAMETERS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "PARAMETERS " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: FIELD_PARAMETER_SET_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PARAMETERS"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%PARAMETERS, NullPtr0, NullPtr1, NullPtr2, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "PARAMETERS (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_FIELD_PARAMETER_SET_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MATRIX_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MATRIX_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr0
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr2
  TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER :: NullPtr3
  TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER :: NullPtr4
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: NullPtr5
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr6
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: NullPtr7


  TYPE(EQUATIONS_MATRIX_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MATRIX_NUMBER:                   ", &
    & Variable%MATRIX_NUMBER
  
  ! Variable%DYNAMIC_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DYNAMIC_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: " // &
      & "DYNAMIC_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_DYNAMIC_TYPE has the following CheckVariable types: EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRIX_TYPE (Variable)
! Available CheckVariables are: 
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DYNAMIC_MATRICES"
      CALL Print_EQUATIONS_MATRICES_DYNAMIC_TYPE(Variable% &
        & DYNAMIC_MATRICES, NullPtr0, NullPtr1, NullPtr2, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: " // &
      & "DYNAMIC_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%LINEAR_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINEAR_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: " // &
      & "LINEAR_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_LINEAR_TYPE has the following CheckVariable types: EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRIX_TYPE (Variable)
! Available CheckVariables are: 
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINEAR_MATRICES"
      CALL Print_EQUATIONS_MATRICES_LINEAR_TYPE(Variable% &
        & LINEAR_MATRICES, NullPtr0, NullPtr1, NullPtr2, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: " // &
      & "LINEAR_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "STORAGE_TYPE:                    ", &
    & Variable%STORAGE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "STRUCTURE_TYPE:                  ", &
    & Variable%STRUCTURE_TYPE
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "LUMPED:                                          ", &
    & Variable%LUMPED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COLUMNS:               ", &
    & Variable%NUMBER_OF_COLUMNS
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "UPDATE_MATRIX:                                   ", &
    & Variable%UPDATE_MATRIX
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "FIRST_ASSEMBLY:                                  ", &
    & Variable%FIRST_ASSEMBLY
  
  ! Variable%MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "MATRIX " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_MATRIX_TYPE has the following CheckVariable types: DISTRIBUTED_MATRIX_CMISS_TYPE, DISTRIBUTED_MATRIX_PETSC_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRIX_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DISTRIBUTED_MATRIX_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_CMISS_TYPE
! - signature type DISTRIBUTED_MATRIX_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_PETSC_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATRIX"
      CALL Print_DISTRIBUTED_MATRIX_TYPE(Variable%MATRIX, NullPtr3, NullPtr4, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%TEMP_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%TEMP_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "TEMP_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRIX_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TEMP_VECTOR"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%TEMP_VECTOR, NullPtr5, NullPtr6, NullPtr7, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "TEMP_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_MATRIX_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_PROBLEM_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable10

  ! iterator variables

  ! null pointers
  TYPE(SOLVER_TYPE), POINTER :: NullPtr0

  TYPE(PROBLEM_TYPE), POINTER :: Ptr0

  TYPE(PROBLEM_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable6)) THEN
    Variable2 => CheckVariable6
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(PROBLEM_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_PROBLEM_TYPE has the following CheckVariable types: HISTORY_TYPE, PROBLEMS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, CONTROL_LOOP_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, PROBLEM_PTR_TYPE, CONTROL_LOOP_WHILE_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: PROBLEM_PTR_TYPE (Variable)
! Available CheckVariables are: HISTORY_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), CONTROL_LOOP_TYPE (CheckVariable3), CONTROL_LOOP_FIXED_TYPE (CheckVariable4), CONTROL_LOOP_TIME_TYPE (CheckVariable5), PROBLEM_PTR_TYPE (CheckVariable6), CONTROL_LOOP_WHILE_TYPE (CheckVariable7), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable8), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable9), PROBLEM_TYPE (CheckVariable10), 
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type PROBLEM_PTR_TYPE
!   is type of this print routine, use Variable2
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type PROBLEM_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable10

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable10)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_PROBLEM_TYPE(Variable% &
        & PTR, CheckVariable0, CheckVariable1, CheckVariable2, NullPtr0, CheckVariable3, CheckVariable4, CheckVariable5, &
        & Variable2, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(PROBLEM_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_PROBLEM_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_ELEMENT_VECTOR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(ELEMENT_VECTOR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(ELEMENT_VECTOR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ROWS:                  ", &
    & Variable%NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAX_NUMBER_OF_ROWS:              ", &
    & Variable%MAX_NUMBER_OF_ROWS
  
  ! Variable%ROW_DOFS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ROW_DOFS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ROW_DOFS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ROW_DOFS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ROW_DOFS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ROW_DOFS,1), MIN(LBOUND(Variable%ROW_DOFS,1)+MaxArrayLength, UBOUND(Variable%ROW_DOFS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ROW_DOFS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ROW_DOFS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%VECTOR(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VECTOR)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VECTOR),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "VECTOR(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VECTOR, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%VECTOR,1), MIN(LBOUND(Variable%VECTOR,1)+MaxArrayLength, UBOUND(Variable%VECTOR,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%VECTOR(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "VECTOR(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_ELEMENT_VECTOR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MeshComponentTopologyPtrType(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, Depth, MaxDepth, MaxArrayLength)
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MeshComponentTopologyType), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable14

  ! iterator variables

  ! null pointers
  TYPE(MeshDataPointsType), POINTER :: NullPtr0
  TYPE(MeshNodesType), POINTER :: NullPtr1
  TYPE(MeshElementsType), POINTER :: NullPtr2
  TYPE(MeshDofsType), POINTER :: NullPtr3

  TYPE(MeshComponentTopologyType), POINTER :: Ptr0

  TYPE(MeshComponentTopologyPtrType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)

  
  ! Variable%ptr
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ptr)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshComponentTopologyType), POINTER :: " // &
      & "ptr " // &
      & "(associated): " 
  
! Signature of Print_MeshComponentTopologyType has the following CheckVariable types: DATA_PROJECTION_TYPE, MESH_TYPE, MeshDataPointsType, MeshComponentTopologyPtrType, FIELD_TYPE, MESH_PTR_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, MeshNodesType, MeshElementsType, REGION_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, GENERATED_MESH_TYPE, MeshComponentTopologyType, MESHES_TYPE, DECOMPOSITIONS_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, MeshDofsType, 
! The type to handle in this routine is: MeshComponentTopologyPtrType (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), MeshComponentTopologyType (CheckVariable2), MESHES_TYPE (CheckVariable3), MESH_PTR_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), MeshComponentTopologyPtrType (CheckVariable7), REGION_TYPE (CheckVariable8), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable9), GENERATED_MESH_TYPE (CheckVariable10), FIELD_TYPE (CheckVariable11), DECOMPOSITIONS_TYPE (CheckVariable12), InterfacePointsConnectivityType (CheckVariable13), INTERFACE_TYPE (CheckVariable14), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MeshDataPointsType
!   is not available in passing variables, use NullPtr of type MeshDataPointsType
! - signature type MeshComponentTopologyPtrType
!   is type of this print routine, use Variable2
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type MeshNodesType
!   is not available in passing variables, use NullPtr of type MeshNodesType
! - signature type MeshElementsType
!   is not available in passing variables, use NullPtr of type MeshElementsType
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type MeshComponentTopologyType
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type MeshDofsType
!   is not available in passing variables, use NullPtr of type MeshDofsType

    ! if variable was already followed
    Ptr0 => Variable%ptr
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ptr"
      CALL Print_MeshComponentTopologyType(Variable% &
        & ptr, CheckVariable0, CheckVariable1, NullPtr0, Variable2, CheckVariable11, CheckVariable4, CheckVariable5, &
        & CheckVariable6, NullPtr1, NullPtr2, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable2, &
        & CheckVariable3, CheckVariable12, CheckVariable13, CheckVariable14, NullPtr3, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshComponentTopologyType), POINTER :: " // &
      & "ptr (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_MeshComponentTopologyPtrType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_REGION_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable31

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr0
  TYPE(MeshComponentTopologyPtrType), POINTER :: NullPtr1
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: NullPtr2
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: NullPtr3
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: NullPtr4
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: NullPtr5
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: NullPtr6
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: NullPtr8
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: NullPtr9

  TYPE(DATA_POINTS_TYPE), POINTER :: Ptr0
  TYPE(NODES_TYPE), POINTER :: Ptr1
  TYPE(MESHES_TYPE), POINTER :: Ptr2
  TYPE(GENERATED_MESHES_TYPE), POINTER :: Ptr3
  TYPE(FIELDS_TYPE), POINTER :: Ptr4
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: Ptr5
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: Ptr6
  TYPE(REGION_TYPE), POINTER :: Ptr7
  TYPE(REGION_PTR_TYPE), POINTER :: Ptr8
  TYPE(INTERFACES_TYPE), POINTER :: Ptr9

  TYPE(REGION_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable31)) THEN
    Variable2 => CheckVariable31
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "REGION_FINISHED:                                 ", &
    & Variable%REGION_FINISHED
  
  ! Variable%COORDINATE_SYSTEM
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%COORDINATE_SYSTEM)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: " // &
      & "COORDINATE_SYSTEM " // &
      & "(associated): " 
  
! Signature of Print_COORDINATE_SYSTEM_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: REGION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), EQUATIONS_SET_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), DOMAIN_PTR_TYPE (CheckVariable22), INTERFACES_TYPE (CheckVariable23), DATA_POINTS_TYPE (CheckVariable24), GENERATED_MESH_PTR_TYPE (CheckVariable25), DATA_PROJECTION_TYPE (CheckVariable26), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable27), DECOMPOSITION_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"COORDINATE_SYSTEM"
      CALL Print_COORDINATE_SYSTEM_TYPE(Variable%COORDINATE_SYSTEM, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: " // &
      & "COORDINATE_SYSTEM (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DATA_POINTS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DATA_POINTS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DATA_POINTS_TYPE), POINTER :: " // &
      & "DATA_POINTS " // &
      & "(associated): " 
  
! Signature of Print_DATA_POINTS_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: REGION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), EQUATIONS_SET_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), DOMAIN_PTR_TYPE (CheckVariable22), INTERFACES_TYPE (CheckVariable23), DATA_POINTS_TYPE (CheckVariable24), GENERATED_MESH_PTR_TYPE (CheckVariable25), DATA_PROJECTION_TYPE (CheckVariable26), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable27), DECOMPOSITION_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_POINTS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable24
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type REGION_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr0 => Variable%DATA_POINTS
    IF (ASSOCIATED(Ptr0, CheckVariable24)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DATA_POINTS"
      CALL Print_DATA_POINTS_TYPE(Variable% &
        & DATA_POINTS, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable12, CheckVariable13, &
        & CheckVariable14, CheckVariable16, NullPtr0, CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, &
        & CheckVariable21, CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, &
        & CheckVariable28, CheckVariable29, CheckVariable30, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DATA_POINTS_TYPE), POINTER :: " // &
      & "DATA_POINTS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%NODES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NODES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NODES_TYPE), POINTER :: " // &
      & "NODES " // &
      & "(associated): " 
  
! Signature of Print_NODES_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: REGION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), EQUATIONS_SET_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), DOMAIN_PTR_TYPE (CheckVariable22), INTERFACES_TYPE (CheckVariable23), DATA_POINTS_TYPE (CheckVariable24), GENERATED_MESH_PTR_TYPE (CheckVariable25), DATA_PROJECTION_TYPE (CheckVariable26), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable27), DECOMPOSITION_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type REGION_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr1 => Variable%NODES
    IF (ASSOCIATED(Ptr1, CheckVariable21)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NODES"
      CALL Print_NODES_TYPE(Variable% &
        & NODES, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable12, CheckVariable13, &
        & CheckVariable14, CheckVariable16, NullPtr0, CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, &
        & CheckVariable21, CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable28, &
        & CheckVariable29, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NODES_TYPE), POINTER :: " // &
      & "NODES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MESHES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MESHES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESHES_TYPE), POINTER :: " // &
      & "MESHES " // &
      & "(associated): " 
  
! Signature of Print_MESHES_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: REGION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), EQUATIONS_SET_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), DOMAIN_PTR_TYPE (CheckVariable22), INTERFACES_TYPE (CheckVariable23), DATA_POINTS_TYPE (CheckVariable24), GENERATED_MESH_PTR_TYPE (CheckVariable25), DATA_PROJECTION_TYPE (CheckVariable26), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable27), DECOMPOSITION_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type MeshComponentTopologyPtrType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyPtrType
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type REGION_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr2 => Variable%MESHES
    IF (ASSOCIATED(Ptr2, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MESHES"
      CALL Print_MESHES_TYPE(Variable% &
        & MESHES, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable12, CheckVariable13, &
        & CheckVariable14, CheckVariable16, NullPtr0, CheckVariable17, NullPtr1, CheckVariable18, CheckVariable19, &
        & CheckVariable20, CheckVariable21, CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, &
        & CheckVariable28, CheckVariable29, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESHES_TYPE), POINTER :: " // &
      & "MESHES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%GENERATED_MESHES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GENERATED_MESHES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GENERATED_MESHES_TYPE), POINTER :: " // &
      & "GENERATED_MESHES " // &
      & "(associated): " 
  
! Signature of Print_GENERATED_MESHES_TYPE has the following CheckVariable types: MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: REGION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), EQUATIONS_SET_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), DOMAIN_PTR_TYPE (CheckVariable22), INTERFACES_TYPE (CheckVariable23), DATA_POINTS_TYPE (CheckVariable24), GENERATED_MESH_PTR_TYPE (CheckVariable25), DATA_PROJECTION_TYPE (CheckVariable26), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable27), DECOMPOSITION_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_CYLINDER_TYPE
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_ELLIPSOID_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_REGULAR_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type REGION_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr3 => Variable%GENERATED_MESHES
    IF (ASSOCIATED(Ptr3, CheckVariable19)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GENERATED_MESHES"
      CALL Print_GENERATED_MESHES_TYPE(Variable% &
        & GENERATED_MESHES, CheckVariable0, NullPtr2, CheckVariable1, CheckVariable2, NullPtr3, CheckVariable4, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable12, &
        & CheckVariable13, CheckVariable14, CheckVariable16, NullPtr0, CheckVariable17, CheckVariable18, CheckVariable19, &
        & CheckVariable20, CheckVariable21, CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, NullPtr4, &
        & CheckVariable28, CheckVariable29, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GENERATED_MESHES_TYPE), POINTER :: " // &
      & "GENERATED_MESHES (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%FIELDS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELDS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELDS_TYPE), POINTER :: " // &
      & "FIELDS " // &
      & "(associated): " 
  
! Signature of Print_FIELDS_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: REGION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), EQUATIONS_SET_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), DOMAIN_PTR_TYPE (CheckVariable22), INTERFACES_TYPE (CheckVariable23), DATA_POINTS_TYPE (CheckVariable24), GENERATED_MESH_PTR_TYPE (CheckVariable25), DATA_PROJECTION_TYPE (CheckVariable26), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable27), DECOMPOSITION_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type REGION_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr4 => Variable%FIELDS
    IF (ASSOCIATED(Ptr4, CheckVariable18)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELDS"
      CALL Print_FIELDS_TYPE(Variable% &
        & FIELDS, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable12, CheckVariable13, &
        & CheckVariable14, CheckVariable16, NullPtr0, CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, &
        & CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, &
        & CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELDS_TYPE), POINTER :: " // &
      & "FIELDS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%EQUATIONS_SETS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SETS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SETS_TYPE), POINTER :: " // &
      & "EQUATIONS_SETS " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SETS_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, EQUATIONS_SET_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, INTERFACES_TYPE, EQUATIONS_SET_PTR_TYPE, GENERATED_MESHES_TYPE, FIELD_TYPE, CONTROL_LOOP_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: REGION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), EQUATIONS_SET_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), DOMAIN_PTR_TYPE (CheckVariable22), INTERFACES_TYPE (CheckVariable23), DATA_POINTS_TYPE (CheckVariable24), GENERATED_MESH_PTR_TYPE (CheckVariable25), DATA_PROJECTION_TYPE (CheckVariable26), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable27), DECOMPOSITION_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type REGION_TYPE
!   is type of this print routine, use Variable2
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable24

    ! if variable was already followed
    Ptr5 => Variable%EQUATIONS_SETS
    IF (ASSOCIATED(Ptr5, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SETS"
      CALL Print_EQUATIONS_SETS_TYPE(Variable% &
        & EQUATIONS_SETS, CheckVariable26, CheckVariable3, CheckVariable0, CheckVariable18, CheckVariable28, &
        & CheckVariable7, CheckVariable23, CheckVariable29, CheckVariable19, CheckVariable6, CheckVariable15, &
        & CheckVariable10, CheckVariable14, CheckVariable21, CheckVariable9, Variable2, CheckVariable24, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SETS_TYPE), POINTER :: " // &
      & "EQUATIONS_SETS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CELLML_ENVIRONMENTS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CELLML_ENVIRONMENTS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: " // &
      & "CELLML_ENVIRONMENTS " // &
      & "(associated): " 
  
! Signature of Print_CELLML_ENVIRONMENTS_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, InterfacePointsConnectivityType, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, DATA_POINTS_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: REGION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), EQUATIONS_SET_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), DOMAIN_PTR_TYPE (CheckVariable22), INTERFACES_TYPE (CheckVariable23), DATA_POINTS_TYPE (CheckVariable24), GENERATED_MESH_PTR_TYPE (CheckVariable25), DATA_PROJECTION_TYPE (CheckVariable26), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable27), DECOMPOSITION_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_MODELS_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_MODELS_FIELD_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable14
! - signature type CELLML_STATE_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_STATE_FIELD_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_FIELD_MAPS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_FIELD_MAPS_TYPE
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_INTERMEDIATE_FIELD_TYPE
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_PARAMETERS_FIELD_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type REGION_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr6 => Variable%CELLML_ENVIRONMENTS
    IF (ASSOCIATED(Ptr6, CheckVariable14)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML_ENVIRONMENTS"
      CALL Print_CELLML_ENVIRONMENTS_TYPE(Variable% &
        & CELLML_ENVIRONMENTS, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, NullPtr5, CheckVariable9, CheckVariable10, CheckVariable8, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, NullPtr6, CheckVariable16, CheckVariable17, CheckVariable18, &
        & NullPtr7, CheckVariable19, CheckVariable21, CheckVariable23, NullPtr8, CheckVariable25, CheckVariable26, &
        & NullPtr9, CheckVariable28, CheckVariable24, CheckVariable29, CheckVariable30, Variable2, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: " // &
      & "CELLML_ENVIRONMENTS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%PARENT_REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PARENT_REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "PARENT_REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: REGION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), EQUATIONS_SET_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), DOMAIN_PTR_TYPE (CheckVariable22), INTERFACES_TYPE (CheckVariable23), DATA_POINTS_TYPE (CheckVariable24), GENERATED_MESH_PTR_TYPE (CheckVariable25), DATA_PROJECTION_TYPE (CheckVariable26), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable27), DECOMPOSITION_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type REGION_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr7 => Variable%PARENT_REGION
    IF (ASSOCIATED(Ptr7, CheckVariable31)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PARENT_REGION"
      CALL Print_REGION_TYPE(Variable% &
        & PARENT_REGION, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
        & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, &
        & CheckVariable30, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "PARENT_REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SUB_REGIONS:           ", &
    & Variable%NUMBER_OF_SUB_REGIONS
  
  ! Variable%SUB_REGIONS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%SUB_REGIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_PTR_TYPE), POINTER :: " // &
      & "SUB_REGIONS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%SUB_REGIONS,1), "): "
  
    DO I0 = LBOUND(Variable%SUB_REGIONS,1), MIN(LBOUND(Variable%SUB_REGIONS,1)+MaxArrayLength, UBOUND(Variable%SUB_REGIONS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_REGION_PTR_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: REGION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), EQUATIONS_SET_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), DOMAIN_PTR_TYPE (CheckVariable22), INTERFACES_TYPE (CheckVariable23), DATA_POINTS_TYPE (CheckVariable24), GENERATED_MESH_PTR_TYPE (CheckVariable25), DATA_PROJECTION_TYPE (CheckVariable26), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable27), DECOMPOSITION_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type REGION_TYPE
!   is type of this print routine, use Variable2

      ! if variable was already followed
      Ptr8 => Variable%SUB_REGIONS(I0)
      IF (ASSOCIATED(Ptr8, CheckVariable7)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SUB_REGIONS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_REGION_PTR_TYPE(Variable% &
          & SUB_REGIONS(I0), CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable4, CheckVariable5, &
          & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable12, &
          & CheckVariable13, CheckVariable14, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, &
          & CheckVariable21, CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable28, &
          & CheckVariable29, Variable2, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_PTR_TYPE), POINTER :: " // &
      & "SUB_REGIONS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACES_TYPE), POINTER :: " // &
      & "INTERFACES " // &
      & "(associated): " 
  
! Signature of Print_INTERFACES_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, REGION_TYPE, 
! The type to handle in this routine is: REGION_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), EQUATIONS_SET_TYPE (CheckVariable3), FIELD_PTR_TYPE (CheckVariable4), GENERATED_MESH_TYPE (CheckVariable5), FIELD_TYPE (CheckVariable6), REGION_PTR_TYPE (CheckVariable7), InterfacePointsConnectivityType (CheckVariable8), EQUATIONS_SETS_TYPE (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_PTR_TYPE (CheckVariable12), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable13), CELLML_ENVIRONMENTS_TYPE (CheckVariable14), CONTROL_LOOP_TYPE (CheckVariable15), CELLML_TYPE (CheckVariable16), MESH_TYPE (CheckVariable17), FIELDS_TYPE (CheckVariable18), GENERATED_MESHES_TYPE (CheckVariable19), DECOMPOSITIONS_TYPE (CheckVariable20), NODES_TYPE (CheckVariable21), DOMAIN_PTR_TYPE (CheckVariable22), INTERFACES_TYPE (CheckVariable23), DATA_POINTS_TYPE (CheckVariable24), GENERATED_MESH_PTR_TYPE (CheckVariable25), DATA_PROJECTION_TYPE (CheckVariable26), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable27), DECOMPOSITION_TYPE (CheckVariable28), EQUATIONS_SET_PTR_TYPE (CheckVariable29), FIELD_VARIABLE_TYPE (CheckVariable30), REGION_TYPE (CheckVariable31), 
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable8
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable23
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type REGION_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr9 => Variable%INTERFACES
    IF (ASSOCIATED(Ptr9, CheckVariable23)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACES"
      CALL Print_INTERFACES_TYPE(Variable% &
        & INTERFACES, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable12, CheckVariable13, &
        & CheckVariable14, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable21, &
        & CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable28, CheckVariable29, Variable2, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACES_TYPE), POINTER :: " // &
      & "INTERFACES (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_REGION_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_LINEAR_DIRECT_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, Depth, MaxDepth, MaxArrayLength)
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14

  ! iterator variables

  ! null pointers
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr6
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr9
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr10
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: NullPtr11
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr12
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr13
  TYPE(HISTORY_TYPE), POINTER :: NullPtr14
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: NullPtr15
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr16
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr17
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr18

  TYPE(LINEAR_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable12)) THEN
    Variable2 => CheckVariable12
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)

  
  ! Variable%LINEAR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINEAR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(LINEAR_SOLVER_TYPE), POINTER :: " // &
      & "LINEAR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_LINEAR_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: LINEAR_DIRECT_SOLVER_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), CELLML_EQUATIONS_TYPE (CheckVariable2), SOLVERS_TYPE (CheckVariable3), SOLVER_TYPE (CheckVariable4), GeometricTransformationSolverType (CheckVariable5), LINEAR_SOLVER_TYPE (CheckVariable6), SOLVER_EQUATIONS_TYPE (CheckVariable7), OPTIMISER_SOLVER_TYPE (CheckVariable8), CONTROL_LOOP_TYPE (CheckVariable9), DYNAMIC_SOLVER_TYPE (CheckVariable10), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable11), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable12), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable13), EIGENPROBLEM_SOLVER_TYPE (CheckVariable14), 
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable5
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable6
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE

    ! if variable was already followed
    Ptr0 => Variable%LINEAR_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINEAR_SOLVER"
      CALL Print_LINEAR_SOLVER_TYPE(Variable% &
        & LINEAR_SOLVER, NullPtr0, NullPtr1, NullPtr2, Variable2, CheckVariable13, NullPtr3, CheckVariable1, NullPtr4, &
        & NullPtr5, NullPtr6, NullPtr7, NullPtr8, CheckVariable8, NullPtr9, CheckVariable10, CheckVariable11, &
        & CheckVariable5, CheckVariable14, NullPtr10, CheckVariable2, CheckVariable9, NullPtr11, CheckVariable7, NullPtr12, &
        & NullPtr13, NullPtr14, CheckVariable0, CheckVariable3, NullPtr15, CheckVariable4, NullPtr16, NullPtr17, &
        & CheckVariable6, NullPtr18, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(LINEAR_SOLVER_TYPE), POINTER :: " // &
      & "LINEAR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRICES_LIBRARY:         ", &
    & Variable%SOLVER_MATRICES_LIBRARY
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DIRECT_SOLVER_TYPE:              ", &
    & Variable%DIRECT_SOLVER_TYPE

  
END SUBROUTINE Print_LINEAR_DIRECT_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_JACOBIAN_TO_SOLVER_MAP_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, Depth, &
  & MaxDepth, MaxArrayLength)
  TYPE(JACOBIAN_TO_SOLVER_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable2

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr0
  TYPE(SOLVER_TYPE), POINTER :: NullPtr1


  TYPE(JACOBIAN_TO_SOLVER_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRIX_NUMBER:            ", &
    & Variable%SOLVER_MATRIX_NUMBER
  
  ! Variable%JACOBIAN_MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%JACOBIAN_MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_JACOBIAN_TYPE), POINTER :: " // &
      & "JACOBIAN_MATRIX " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_JACOBIAN_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: JACOBIAN_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRICES_TYPE (CheckVariable0), SOLVER_EQUATIONS_TYPE (CheckVariable1), SOLVER_MAPPING_TYPE (CheckVariable2), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"JACOBIAN_MATRIX"
      CALL Print_EQUATIONS_JACOBIAN_TYPE(Variable%JACOBIAN_MATRIX, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_JACOBIAN_TYPE), POINTER :: " // &
      & "JACOBIAN_MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOLVER_MATRIX
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MATRIX)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MATRIX_TYPE), POINTER :: " // &
      & "SOLVER_MATRIX " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MATRIX_TYPE has the following CheckVariable types: SOLVER_MATRICES_TYPE, SOLVERS_TYPE, SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, 
! The type to handle in this routine is: JACOBIAN_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRICES_TYPE (CheckVariable0), SOLVER_EQUATIONS_TYPE (CheckVariable1), SOLVER_MAPPING_TYPE (CheckVariable2), 
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable2
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MATRIX"
      CALL Print_SOLVER_MATRIX_TYPE(Variable% &
        & SOLVER_MATRIX, CheckVariable0, NullPtr0, NullPtr1, CheckVariable1, CheckVariable2, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MATRIX_TYPE), POINTER :: " // &
      & "SOLVER_MATRIX (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%JACOBIAN_COL_TO_SOLVER_COLS_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%JACOBIAN_COL_TO_SOLVER_COLS_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%JACOBIAN_COL_TO_SOLVER_COLS_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(JACOBIAN_COL_TO_SOLVER_COLS_MAP_TYPE), ALLOCATABLE :: " // &
      & "JACOBIAN_COL_TO_SOLVER_COLS_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%JACOBIAN_COL_TO_SOLVER_COLS_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%JACOBIAN_COL_TO_SOLVER_COLS_MAP,1), MIN(LBOUND(Variable% &
      & JACOBIAN_COL_TO_SOLVER_COLS_MAP,1)+MaxArrayLength, UBOUND(Variable%JACOBIAN_COL_TO_SOLVER_COLS_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_JACOBIAN_COL_TO_SOLVER_COLS_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: JACOBIAN_TO_SOLVER_MAP_TYPE (Variable)
! Available CheckVariables are: SOLVER_MATRICES_TYPE (CheckVariable0), SOLVER_EQUATIONS_TYPE (CheckVariable1), SOLVER_MAPPING_TYPE (CheckVariable2), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"JACOBIAN_COL_TO_SOLVER_COLS_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_JACOBIAN_COL_TO_SOLVER_COLS_MAP_TYPE(Variable% &
          & JACOBIAN_COL_TO_SOLVER_COLS_MAP(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(JACOBIAN_COL_TO_SOLVER_COLS_MAP_TYPE), ALLOCATABLE :: " // &
      & "JACOBIAN_COL_TO_SOLVER_COLS_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_JACOBIAN_TO_SOLVER_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CONTROL_LOOP_PTR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, Depth, MaxDepth, MaxArrayLength)
  TYPE(CONTROL_LOOP_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable11

  ! iterator variables

  ! null pointers
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(GeometricTransformationSolverType), POINTER :: NullPtr3
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr7
  TYPE(DAE_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: NullPtr9

  TYPE(CONTROL_LOOP_TYPE), POINTER :: Ptr0

  TYPE(CONTROL_LOOP_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)

  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_CONTROL_LOOP_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, PROBLEMS_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CONTROL_LOOP_PTR_TYPE (Variable)
! Available CheckVariables are: HISTORY_TYPE (CheckVariable0), PROBLEMS_TYPE (CheckVariable1), SOLVERS_TYPE (CheckVariable2), SOLVER_TYPE (CheckVariable3), CONTROL_LOOP_TYPE (CheckVariable4), CONTROL_LOOP_FIXED_TYPE (CheckVariable5), CONTROL_LOOP_TIME_TYPE (CheckVariable6), PROBLEM_PTR_TYPE (CheckVariable7), CONTROL_LOOP_WHILE_TYPE (CheckVariable8), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable9), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable10), PROBLEM_TYPE (CheckVariable11), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type OPTIMISER_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type OPTIMISER_SOLVER_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type DYNAMIC_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DYNAMIC_SOLVER_TYPE
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EVALUATOR_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   is not available in passing variables, use NullPtr of type GeometricTransformationSolverType
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EIGENPROBLEM_SOLVER_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type NONLINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NONLINEAR_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type DAE_SOLVER_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type LINEAR_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr0 => Variable%PTR
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_CONTROL_LOOP_TYPE(Variable% &
        & PTR, CheckVariable8, CheckVariable1, CheckVariable5, CheckVariable6, NullPtr0, CheckVariable4, NullPtr1, &
        & NullPtr2, NullPtr3, NullPtr4, NullPtr5, CheckVariable9, NullPtr6, NullPtr7, CheckVariable10, CheckVariable0, &
        & NullPtr8, CheckVariable2, CheckVariable3, CheckVariable7, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CONTROL_LOOP_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_CONTROL_LOOP_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_COORDINATE_SYSTEM_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(COORDINATE_SYSTEM_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(COORDINATE_SYSTEM_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_COORDINATE_SYSTEM_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: COORDINATE_SYSTEM_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_COORDINATE_SYSTEM_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_COORDINATE_SYSTEM_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DATA_PROJECTION_RESULT_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DATA_PROJECTION_RESULT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(DATA_PROJECTION_RESULT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "DISTANCE:                    ", &
    & Variable%DISTANCE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ELEMENT_NUMBER:                  ", &
    & Variable%ELEMENT_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ELEMENT_FACE_NUMBER:             ", &
    & Variable%ELEMENT_FACE_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ELEMENT_LINE_NUMBER:             ", &
    & Variable%ELEMENT_LINE_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "EXIT_TAG:                        ", &
    & Variable%EXIT_TAG
  
  ! Variable%XI(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%XI)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%XI),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "XI(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%XI, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%XI,1), MIN(LBOUND(Variable%XI,1)+MaxArrayLength, UBOUND(Variable%XI,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%XI(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "XI(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%projectionVector(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%projectionVector)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%projectionVector),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "projectionVector(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%projectionVector, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%projectionVector,1), MIN(LBOUND(Variable%projectionVector,1)+MaxArrayLength, UBOUND(Variable% &
      & projectionVector,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%projectionVector(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "projectionVector(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_DATA_PROJECTION_RESULT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_DOF_TO_PARAM_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_DOF_TO_PARAM_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers


  TYPE(FIELD_DOF_TO_PARAM_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DOFS:                  ", &
    & Variable%NUMBER_OF_DOFS
  
  ! Variable%DOF_TYPE(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DOF_TYPE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DOF_TYPE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_TYPE(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DOF_TYPE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DOF_TYPE,1), MIN(LBOUND(Variable%DOF_TYPE,1)+MaxArrayLength, UBOUND(Variable%DOF_TYPE,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%DOF_TYPE,2), MIN(LBOUND(Variable%DOF_TYPE,2)+MaxArrayLength, UBOUND(Variable%DOF_TYPE,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%DOF_TYPE(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DOF_TYPE(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_CONSTANT_DOFS:         ", &
    & Variable%NUMBER_OF_CONSTANT_DOFS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ELEMENT_DOFS:          ", &
    & Variable%NUMBER_OF_ELEMENT_DOFS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_NODE_DOFS:             ", &
    & Variable%NUMBER_OF_NODE_DOFS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GRID_POINT_DOFS:       ", &
    & Variable%NUMBER_OF_GRID_POINT_DOFS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GAUSS_POINT_DOFS:      ", &
    & Variable%NUMBER_OF_GAUSS_POINT_DOFS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DATA_POINT_DOFS:       ", &
    & Variable%NUMBER_OF_DATA_POINT_DOFS
  
  ! Variable%CONSTANT_DOF2PARAM_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%CONSTANT_DOF2PARAM_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%CONSTANT_DOF2PARAM_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "CONSTANT_DOF2PARAM_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%CONSTANT_DOF2PARAM_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%CONSTANT_DOF2PARAM_MAP,1), MIN(LBOUND(Variable% &
      & CONSTANT_DOF2PARAM_MAP,1)+MaxArrayLength, UBOUND(Variable%CONSTANT_DOF2PARAM_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%CONSTANT_DOF2PARAM_MAP(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "CONSTANT_DOF2PARAM_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ELEMENT_DOF2PARAM_MAP(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_DOF2PARAM_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_DOF2PARAM_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_DOF2PARAM_MAP(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_DOF2PARAM_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENT_DOF2PARAM_MAP,1), MIN(LBOUND(Variable% &
      & ELEMENT_DOF2PARAM_MAP,1)+MaxArrayLength, UBOUND(Variable%ELEMENT_DOF2PARAM_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%ELEMENT_DOF2PARAM_MAP,2), MIN(LBOUND(Variable% &
        & ELEMENT_DOF2PARAM_MAP,2)+MaxArrayLength, UBOUND(Variable%ELEMENT_DOF2PARAM_MAP,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%ELEMENT_DOF2PARAM_MAP(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_DOF2PARAM_MAP(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%NODE_DOF2PARAM_MAP(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODE_DOF2PARAM_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODE_DOF2PARAM_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_DOF2PARAM_MAP(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODE_DOF2PARAM_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NODE_DOF2PARAM_MAP,1), MIN(LBOUND(Variable% &
      & NODE_DOF2PARAM_MAP,1)+MaxArrayLength, UBOUND(Variable%NODE_DOF2PARAM_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%NODE_DOF2PARAM_MAP,2), MIN(LBOUND(Variable% &
        & NODE_DOF2PARAM_MAP,2)+MaxArrayLength, UBOUND(Variable%NODE_DOF2PARAM_MAP,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%NODE_DOF2PARAM_MAP(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_DOF2PARAM_MAP(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%GRID_POINT_DOF2PARAM_MAP(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GRID_POINT_DOF2PARAM_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GRID_POINT_DOF2PARAM_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "GRID_POINT_DOF2PARAM_MAP(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GRID_POINT_DOF2PARAM_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%GRID_POINT_DOF2PARAM_MAP,1), MIN(LBOUND(Variable% &
      & GRID_POINT_DOF2PARAM_MAP,1)+MaxArrayLength, UBOUND(Variable%GRID_POINT_DOF2PARAM_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%GRID_POINT_DOF2PARAM_MAP,2), MIN(LBOUND(Variable% &
        & GRID_POINT_DOF2PARAM_MAP,2)+MaxArrayLength, UBOUND(Variable%GRID_POINT_DOF2PARAM_MAP,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%GRID_POINT_DOF2PARAM_MAP(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "GRID_POINT_DOF2PARAM_MAP(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%GAUSS_POINT_DOF2PARAM_MAP(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%GAUSS_POINT_DOF2PARAM_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%GAUSS_POINT_DOF2PARAM_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "GAUSS_POINT_DOF2PARAM_MAP(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%GAUSS_POINT_DOF2PARAM_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%GAUSS_POINT_DOF2PARAM_MAP,1), MIN(LBOUND(Variable% &
      & GAUSS_POINT_DOF2PARAM_MAP,1)+MaxArrayLength, UBOUND(Variable%GAUSS_POINT_DOF2PARAM_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%GAUSS_POINT_DOF2PARAM_MAP,2), MIN(LBOUND(Variable% &
        & GAUSS_POINT_DOF2PARAM_MAP,2)+MaxArrayLength, UBOUND(Variable%GAUSS_POINT_DOF2PARAM_MAP,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%GAUSS_POINT_DOF2PARAM_MAP(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "GAUSS_POINT_DOF2PARAM_MAP(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%DATA_POINT_DOF2PARAM_MAP(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DATA_POINT_DOF2PARAM_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DATA_POINT_DOF2PARAM_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "DATA_POINT_DOF2PARAM_MAP(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DATA_POINT_DOF2PARAM_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%DATA_POINT_DOF2PARAM_MAP,1), MIN(LBOUND(Variable% &
      & DATA_POINT_DOF2PARAM_MAP,1)+MaxArrayLength, UBOUND(Variable%DATA_POINT_DOF2PARAM_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%DATA_POINT_DOF2PARAM_MAP,2), MIN(LBOUND(Variable% &
        & DATA_POINT_DOF2PARAM_MAP,2)+MaxArrayLength, UBOUND(Variable%DATA_POINT_DOF2PARAM_MAP,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%DATA_POINT_DOF2PARAM_MAP(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "DATA_POINT_DOF2PARAM_MAP(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_DOF_TO_PARAM_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_VARIABLE_COMPONENT_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_VARIABLE_COMPONENT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable7

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr1
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr2
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr5
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr6
  TYPE(NODES_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: NullPtr10
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: NullPtr11
  TYPE(DOMAIN_LINES_TYPE), POINTER :: NullPtr12
  TYPE(DOMAIN_DOFS_TYPE), POINTER :: NullPtr13
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr14
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: NullPtr15
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: NullPtr16
  TYPE(MESH_TYPE), POINTER :: NullPtr17
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr18
  TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: NullPtr19
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr20
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr21
  TYPE(DOMAIN_FACES_TYPE), POINTER :: NullPtr22
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: NullPtr23
  TYPE(DecompositionDataPointsType), POINTER :: NullPtr24
  TYPE(DOMAIN_NODES_TYPE), POINTER :: NullPtr25
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: NullPtr26

  TYPE(FIELD_VARIABLE_TYPE), POINTER :: Ptr0

  TYPE(FIELD_VARIABLE_COMPONENT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "COMPONENT_NUMBER:                ", &
    & Variable%COMPONENT_NUMBER
  
  ! Variable%FIELD_VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIELD_VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "FIELD_VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: FIELD_VARIABLE_COMPONENT_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_VARIABLE_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE

    ! if variable was already followed
    Ptr0 => Variable%FIELD_VARIABLE
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIELD_VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & FIELD_VARIABLE, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, NullPtr1, NullPtr2, CheckVariable3, &
        & NullPtr3, NullPtr4, CheckVariable4, CheckVariable5, NullPtr5, CheckVariable6, NullPtr6, NullPtr7, NullPtr8, &
        & CheckVariable7, NullPtr9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "FIELD_VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "INTERPOLATION_TYPE:              ", &
    & Variable%INTERPOLATION_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MESH_COMPONENT_NUMBER:           ", &
    & Variable%MESH_COMPONENT_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SCALING_INDEX:                   ", &
    & Variable%SCALING_INDEX
  
  ! Variable%DOMAIN
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DOMAIN)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_TYPE has the following CheckVariable types: DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, DOMAIN_LINES_TYPE, FIELD_TYPE, DOMAIN_DOFS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, FIELDS_TYPE, DECOMPOSITION_FACES_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, DOMAIN_ELEMENTS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DOMAIN_FACES_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DOMAIN_NODES_TYPE, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: FIELD_VARIABLE_COMPONENT_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), FIELD_GEOMETRIC_PARAMETERS_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), FIELD_VARIABLE_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), INTERFACE_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type DOMAIN_MAPPINGS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_MAPPINGS_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TOPOLOGY_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type DOMAIN_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_LINES_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DOMAIN_DOFS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_DOFS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_FACES_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_ELEMENTS_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type DOMAIN_ELEMENTS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_ELEMENTS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type DOMAIN_FACES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_FACES_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TOPOLOGY_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type DecompositionDataPointsType
!   is not available in passing variables, use NullPtr of type DecompositionDataPointsType
! - signature type DOMAIN_NODES_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_NODES_TYPE
! - signature type DECOMPOSITION_LINES_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_LINES_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DOMAIN"
      CALL Print_DOMAIN_TYPE(Variable% &
        & DOMAIN, NullPtr10, NullPtr11, CheckVariable3, NullPtr12, CheckVariable5, NullPtr13, CheckVariable6, NullPtr14, &
        & CheckVariable2, NullPtr15, NullPtr6, NullPtr4, NullPtr16, NullPtr17, NullPtr18, NullPtr19, NullPtr20, NullPtr21, &
        & NullPtr22, CheckVariable0, NullPtr23, NullPtr1, NullPtr24, NullPtr25, NullPtr26, CheckVariable7, Depth+1, &
        & MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_TYPE), POINTER :: " // &
      & "DOMAIN (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "maxNumberElementInterpolationParameters: ", &
    & Variable%maxNumberElementInterpolationParameters
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "maxNumberNodeInterpolationParameters: ", &
    & Variable%maxNumberNodeInterpolationParameters

  
END SUBROUTINE Print_FIELD_VARIABLE_COMPONENT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_MAPPING_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(SOLVER_MATRIX_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable20

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr1
  TYPE(FIELD_TYPE), POINTER :: NullPtr2
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr9
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr10
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: NullPtr11
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: NullPtr12
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr13
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr14
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: NullPtr15
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr16
  TYPE(HISTORY_TYPE), POINTER :: NullPtr17
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: NullPtr18
  TYPE(MESHES_TYPE), POINTER :: NullPtr19
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr20
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr21
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr22
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr23
  TYPE(FIELDS_TYPE), POINTER :: NullPtr24
  TYPE(NODES_TYPE), POINTER :: NullPtr25
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr26
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr27
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr28
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr29
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr30
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr31
  TYPE(REGION_TYPE), POINTER :: NullPtr32
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr33
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr34
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr35
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr36
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr37
  TYPE(MESH_TYPE), POINTER :: NullPtr38

  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: Ptr0

  TYPE(SOLVER_MAPPING_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable10)) THEN
    Variable2 => CheckVariable10
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)
  Nullify(NullPtr29)
  Nullify(NullPtr30)
  Nullify(NullPtr31)
  Nullify(NullPtr32)
  Nullify(NullPtr33)
  Nullify(NullPtr34)
  Nullify(NullPtr35)
  Nullify(NullPtr36)
  Nullify(NullPtr37)
  Nullify(NullPtr38)

  
  ! Variable%SOLVER_EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: " // &
      & "SOLVER_EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_EQUATIONS_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, PROBLEM_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, LINEAR_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), DAE_SOLVER_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), BOUNDARY_CONDITIONS_TYPE (CheckVariable4), CELLML_EQUATIONS_TYPE (CheckVariable5), EQUATIONS_TYPE (CheckVariable6), SOLVERS_TYPE (CheckVariable7), SOLVER_TYPE (CheckVariable8), INTERFACE_EQUATIONS_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), SOLVER_MATRICES_TYPE (CheckVariable11), SOLVER_MATRIX_TYPE (CheckVariable12), LINEAR_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), EIGENPROBLEM_SOLVER_TYPE (CheckVariable20), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable19
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable14
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable20

    ! if variable was already followed
    Ptr0 => Variable%SOLVER_EQUATIONS
    IF (ASSOCIATED(Ptr0, CheckVariable14)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_EQUATIONS"
      CALL Print_SOLVER_EQUATIONS_TYPE(Variable% &
        & SOLVER_EQUATIONS, CheckVariable0, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, &
        & CheckVariable3, NullPtr7, NullPtr8, NullPtr9, NullPtr10, NullPtr11, NullPtr12, CheckVariable15, NullPtr13, &
        & CheckVariable17, CheckVariable18, CheckVariable19, NullPtr14, CheckVariable2, CheckVariable4, CheckVariable5, &
        & CheckVariable16, NullPtr15, CheckVariable14, NullPtr16, NullPtr17, CheckVariable1, CheckVariable7, NullPtr18, &
        & CheckVariable8, Variable2, CheckVariable11, CheckVariable13, CheckVariable20, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: " // &
      & "SOLVER_EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "SOLVER_MAPPING_FINISHED:                         ", &
    & Variable%SOLVER_MAPPING_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SOLVER_MATRICES:       ", &
    & Variable%NUMBER_OF_SOLVER_MATRICES
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ROWS:                  ", &
    & Variable%NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_ROWS:           ", &
    & Variable%NUMBER_OF_GLOBAL_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_EQUATIONS_SETS:        ", &
    & Variable%NUMBER_OF_EQUATIONS_SETS
  
  ! Variable%EQUATIONS_SETS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_SETS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_SETS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_PTR_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_SETS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_SETS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_SETS,1), MIN(LBOUND(Variable%EQUATIONS_SETS,1)+MaxArrayLength, UBOUND(Variable% &
      & EQUATIONS_SETS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_SET_PTR_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, SOLVER_EQUATIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, GENERATED_MESHES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: SOLVER_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), DAE_SOLVER_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), BOUNDARY_CONDITIONS_TYPE (CheckVariable4), CELLML_EQUATIONS_TYPE (CheckVariable5), EQUATIONS_TYPE (CheckVariable6), SOLVERS_TYPE (CheckVariable7), SOLVER_TYPE (CheckVariable8), INTERFACE_EQUATIONS_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), SOLVER_MATRICES_TYPE (CheckVariable11), SOLVER_MATRIX_TYPE (CheckVariable12), LINEAR_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), EIGENPROBLEM_SOLVER_TYPE (CheckVariable20), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SETS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_SET_PTR_TYPE(Variable% &
          & EQUATIONS_SETS(I0), NullPtr19, NullPtr2, NullPtr20, NullPtr21, NullPtr22, NullPtr23, CheckVariable16, &
          & CheckVariable2, CheckVariable4, NullPtr24, CheckVariable14, NullPtr25, NullPtr26, NullPtr27, NullPtr28, &
          & CheckVariable7, NullPtr29, CheckVariable8, Variable2, CheckVariable11, NullPtr30, NullPtr31, NullPtr32, &
          & Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_PTR_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_SETS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_SET_TO_SOLVER_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_SET_TO_SOLVER_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_SET_TO_SOLVER_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TO_SOLVER_MAP_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_SET_TO_SOLVER_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_SET_TO_SOLVER_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_SET_TO_SOLVER_MAP,1), MIN(LBOUND(Variable% &
      & EQUATIONS_SET_TO_SOLVER_MAP,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_SET_TO_SOLVER_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_SET_TO_SOLVER_MAP_TYPE has the following CheckVariable types: EQUATIONS_TYPE, BOUNDARY_CONDITIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, 
! The type to handle in this routine is: SOLVER_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), DAE_SOLVER_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), BOUNDARY_CONDITIONS_TYPE (CheckVariable4), CELLML_EQUATIONS_TYPE (CheckVariable5), EQUATIONS_TYPE (CheckVariable6), SOLVERS_TYPE (CheckVariable7), SOLVER_TYPE (CheckVariable8), INTERFACE_EQUATIONS_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), SOLVER_MATRICES_TYPE (CheckVariable11), SOLVER_MATRIX_TYPE (CheckVariable12), LINEAR_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), EIGENPROBLEM_SOLVER_TYPE (CheckVariable20), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable16
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SET_TO_SOLVER_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_SET_TO_SOLVER_MAP_TYPE(Variable% &
          & EQUATIONS_SET_TO_SOLVER_MAP(I0), CheckVariable6, CheckVariable4, CheckVariable7, CheckVariable8, Variable2, &
          & CheckVariable11, CheckVariable14, CheckVariable16, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TO_SOLVER_MAP_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_SET_TO_SOLVER_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_INTERFACE_CONDITIONS:  ", &
    & Variable%NUMBER_OF_INTERFACE_CONDITIONS
  
  ! Variable%INTERFACE_CONDITIONS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_CONDITIONS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_CONDITIONS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_CONDITION_PTR_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_CONDITIONS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_CONDITIONS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_CONDITIONS,1), MIN(LBOUND(Variable% &
      & INTERFACE_CONDITIONS,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_CONDITIONS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_CONDITION_PTR_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, SOLVER_EQUATIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, GENERATED_MESHES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: SOLVER_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), DAE_SOLVER_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), BOUNDARY_CONDITIONS_TYPE (CheckVariable4), CELLML_EQUATIONS_TYPE (CheckVariable5), EQUATIONS_TYPE (CheckVariable6), SOLVERS_TYPE (CheckVariable7), SOLVER_TYPE (CheckVariable8), INTERFACE_EQUATIONS_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), SOLVER_MATRICES_TYPE (CheckVariable11), SOLVER_MATRIX_TYPE (CheckVariable12), LINEAR_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), EIGENPROBLEM_SOLVER_TYPE (CheckVariable20), 
! - signature type INTERFACE_CONDITION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_CONDITIONS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_CONDITION_PTR_TYPE(Variable% &
          & INTERFACE_CONDITIONS(I0), CheckVariable0, NullPtr19, NullPtr33, NullPtr34, NullPtr2, NullPtr35, NullPtr22, &
          & NullPtr36, CheckVariable16, NullPtr37, NullPtr38, CheckVariable4, NullPtr24, CheckVariable14, NullPtr25, &
          & NullPtr26, NullPtr27, NullPtr28, CheckVariable7, NullPtr29, CheckVariable8, Variable2, CheckVariable11, &
          & NullPtr31, NullPtr32, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_CONDITION_PTR_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_CONDITIONS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%INTERFACE_CONDITION_TO_SOLVER_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%INTERFACE_CONDITION_TO_SOLVER_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%INTERFACE_CONDITION_TO_SOLVER_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_CONDITION_TO_SOLVER_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%INTERFACE_CONDITION_TO_SOLVER_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%INTERFACE_CONDITION_TO_SOLVER_MAP,1), MIN(LBOUND(Variable% &
      & INTERFACE_CONDITION_TO_SOLVER_MAP,1)+MaxArrayLength, UBOUND(Variable%INTERFACE_CONDITION_TO_SOLVER_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE has the following CheckVariable types: BOUNDARY_CONDITIONS_TYPE, INTERFACE_EQUATIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, 
! The type to handle in this routine is: SOLVER_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), DAE_SOLVER_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), BOUNDARY_CONDITIONS_TYPE (CheckVariable4), CELLML_EQUATIONS_TYPE (CheckVariable5), EQUATIONS_TYPE (CheckVariable6), SOLVERS_TYPE (CheckVariable7), SOLVER_TYPE (CheckVariable8), INTERFACE_EQUATIONS_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), SOLVER_MATRICES_TYPE (CheckVariable11), SOLVER_MATRIX_TYPE (CheckVariable12), LINEAR_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), EIGENPROBLEM_SOLVER_TYPE (CheckVariable20), 
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACE_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable16
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE_CONDITION_TO_SOLVER_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE(Variable% &
          & INTERFACE_CONDITION_TO_SOLVER_MAP(I0), CheckVariable4, CheckVariable9, CheckVariable7, CheckVariable8, &
          & Variable2, CheckVariable11, CheckVariable14, CheckVariable16, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE), ALLOCATABLE :: " // &
      & "INTERFACE_CONDITION_TO_SOLVER_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%VARIABLES_LIST(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLES_LIST)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLES_LIST),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MAPPING_VARIABLES_TYPE), ALLOCATABLE :: " // &
      & "VARIABLES_LIST(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLES_LIST, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%VARIABLES_LIST,1), MIN(LBOUND(Variable%VARIABLES_LIST,1)+MaxArrayLength, UBOUND(Variable% &
      & VARIABLES_LIST,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_MAPPING_VARIABLES_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: SOLVER_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), DAE_SOLVER_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), BOUNDARY_CONDITIONS_TYPE (CheckVariable4), CELLML_EQUATIONS_TYPE (CheckVariable5), EQUATIONS_TYPE (CheckVariable6), SOLVERS_TYPE (CheckVariable7), SOLVER_TYPE (CheckVariable8), INTERFACE_EQUATIONS_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), SOLVER_MATRICES_TYPE (CheckVariable11), SOLVER_MATRIX_TYPE (CheckVariable12), LINEAR_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), EIGENPROBLEM_SOLVER_TYPE (CheckVariable20), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLES_LIST("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_MAPPING_VARIABLES_TYPE(Variable%VARIABLES_LIST(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MAPPING_VARIABLES_TYPE), ALLOCATABLE :: " // &
      & "VARIABLES_LIST(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%SOLVER_COL_TO_EQUATIONS_COLS_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOLVER_COL_TO_EQUATIONS_COLS_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOLVER_COL_TO_EQUATIONS_COLS_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_COL_TO_EQUATIONS_MAPS_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_COL_TO_EQUATIONS_COLS_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOLVER_COL_TO_EQUATIONS_COLS_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%SOLVER_COL_TO_EQUATIONS_COLS_MAP,1), MIN(LBOUND(Variable% &
      & SOLVER_COL_TO_EQUATIONS_COLS_MAP,1)+MaxArrayLength, UBOUND(Variable%SOLVER_COL_TO_EQUATIONS_COLS_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_COL_TO_EQUATIONS_MAPS_TYPE has the following CheckVariable types: SOLVER_MATRIX_TYPE, BOUNDARY_CONDITIONS_TYPE, SOLVER_MATRICES_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVERS_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, 
! The type to handle in this routine is: SOLVER_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), DAE_SOLVER_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), BOUNDARY_CONDITIONS_TYPE (CheckVariable4), CELLML_EQUATIONS_TYPE (CheckVariable5), EQUATIONS_TYPE (CheckVariable6), SOLVERS_TYPE (CheckVariable7), SOLVER_TYPE (CheckVariable8), INTERFACE_EQUATIONS_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), SOLVER_MATRICES_TYPE (CheckVariable11), SOLVER_MATRIX_TYPE (CheckVariable12), LINEAR_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), EIGENPROBLEM_SOLVER_TYPE (CheckVariable20), 
! - signature type SOLVER_MATRIX_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_MAPPING_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable16
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_COL_TO_EQUATIONS_COLS_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_COL_TO_EQUATIONS_MAPS_TYPE(Variable% &
          & SOLVER_COL_TO_EQUATIONS_COLS_MAP(I0), CheckVariable12, CheckVariable4, CheckVariable11, CheckVariable8, &
          & Variable2, CheckVariable7, CheckVariable14, CheckVariable16, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_COL_TO_EQUATIONS_MAPS_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_COL_TO_EQUATIONS_COLS_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%SOLVER_ROW_TO_EQUATIONS_ROWS_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SOLVER_ROW_TO_EQUATIONS_ROWS_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SOLVER_ROW_TO_EQUATIONS_ROWS_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_ROW_TO_EQUATIONS_MAPS_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_ROW_TO_EQUATIONS_ROWS_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SOLVER_ROW_TO_EQUATIONS_ROWS_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%SOLVER_ROW_TO_EQUATIONS_ROWS_MAP,1), MIN(LBOUND(Variable% &
      & SOLVER_ROW_TO_EQUATIONS_ROWS_MAP,1)+MaxArrayLength, UBOUND(Variable%SOLVER_ROW_TO_EQUATIONS_ROWS_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_ROW_TO_EQUATIONS_MAPS_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: SOLVER_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), DAE_SOLVER_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), BOUNDARY_CONDITIONS_TYPE (CheckVariable4), CELLML_EQUATIONS_TYPE (CheckVariable5), EQUATIONS_TYPE (CheckVariable6), SOLVERS_TYPE (CheckVariable7), SOLVER_TYPE (CheckVariable8), INTERFACE_EQUATIONS_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), SOLVER_MATRICES_TYPE (CheckVariable11), SOLVER_MATRIX_TYPE (CheckVariable12), LINEAR_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), EIGENPROBLEM_SOLVER_TYPE (CheckVariable20), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_ROW_TO_EQUATIONS_ROWS_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_ROW_TO_EQUATIONS_MAPS_TYPE(Variable% &
          & SOLVER_ROW_TO_EQUATIONS_ROWS_MAP(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_ROW_TO_EQUATIONS_MAPS_TYPE), ALLOCATABLE :: " // &
      & "SOLVER_ROW_TO_EQUATIONS_ROWS_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ROW_DOFS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ROW_DOFS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "ROW_DOFS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: SOLVER_MAPPING_TYPE (Variable)
! Available CheckVariables are: INTERFACE_CONDITION_TYPE (CheckVariable0), DAE_SOLVER_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), BOUNDARY_CONDITIONS_TYPE (CheckVariable4), CELLML_EQUATIONS_TYPE (CheckVariable5), EQUATIONS_TYPE (CheckVariable6), SOLVERS_TYPE (CheckVariable7), SOLVER_TYPE (CheckVariable8), INTERFACE_EQUATIONS_TYPE (CheckVariable9), SOLVER_MAPPING_TYPE (CheckVariable10), SOLVER_MATRICES_TYPE (CheckVariable11), SOLVER_MATRIX_TYPE (CheckVariable12), LINEAR_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), OPTIMISER_SOLVER_TYPE (CheckVariable15), CONTROL_LOOP_TYPE (CheckVariable16), DYNAMIC_SOLVER_TYPE (CheckVariable17), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable18), GeometricTransformationSolverType (CheckVariable19), EIGENPROBLEM_SOLVER_TYPE (CheckVariable20), 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ROW_DOFS_MAPPING"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%ROW_DOFS_MAPPING, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "ROW_DOFS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CREATE_VALUES_CACHE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CREATE_VALUES_CACHE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOlVER_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER :: " // &
      & "CREATE_VALUES_CACHE " // &
      & "(associated): " 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(SOlVER_MAPPING_CREATE_VALUES_CACHE_TYPE) :: Variable%" // &
        & "CREATE_VALUES_CACHE (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOlVER_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER :: " // &
      & "CREATE_VALUES_CACHE (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_SOLVER_MAPPING_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MATRICES_NONLINEAR_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: NullPtr1
  TYPE(SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: NullPtr4
  TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: NullPtr5
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr6
  TYPE(FIELD_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER :: NullPtr8
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr9
  TYPE(REGION_TYPE), POINTER :: NullPtr10
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: NullPtr11
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr12
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: NullPtr13

  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: Ptr0

  TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)

  
  ! Variable%EQUATIONS_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MATRICES_DYNAMIC_TYPE, SOLVER_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_MATRICES_RHS_TYPE, EQUATIONS_MATRICES_LINEAR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_MATRICES_SOURCE_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_MATRICES_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_NONLINEAR_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_MATRICES_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), EQUATIONS_TYPE (CheckVariable2), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EQUATIONS_MATRICES_DYNAMIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_DYNAMIC_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EQUATIONS_MATRICES_RHS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_RHS_TYPE
! - signature type EQUATIONS_MATRICES_LINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_LINEAR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type EQUATIONS_MATRICES_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_SOURCE_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type EQUATIONS_MATRICES_NONLINEAR_TYPE
!   is type of this print routine, use Variable2

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_MATRICES
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MATRICES"
      CALL Print_EQUATIONS_MATRICES_TYPE(Variable% &
        & EQUATIONS_MATRICES, CheckVariable2, NullPtr0, NullPtr1, NullPtr2, NullPtr3, CheckVariable1, NullPtr4, NullPtr5, &
        & NullPtr6, NullPtr7, NullPtr8, NullPtr9, NullPtr10, Variable2, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: " // &
      & "EQUATIONS_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_JACOBIANS:             ", &
    & Variable%NUMBER_OF_JACOBIANS
  
  ! Variable%JACOBIANS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%JACOBIANS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%JACOBIANS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_JACOBIAN_PTR_TYPE), ALLOCATABLE :: " // &
      & "JACOBIANS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%JACOBIANS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%JACOBIANS,1), MIN(LBOUND(Variable%JACOBIANS,1)+MaxArrayLength, UBOUND(Variable%JACOBIANS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_JACOBIAN_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MATRICES_NONLINEAR_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_MATRICES_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), EQUATIONS_TYPE (CheckVariable2), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"JACOBIANS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_JACOBIAN_PTR_TYPE(Variable%JACOBIANS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_JACOBIAN_PTR_TYPE), ALLOCATABLE :: " // &
      & "JACOBIANS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "UPDATE_RESIDUAL:                                 ", &
    & Variable%UPDATE_RESIDUAL
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "FIRST_ASSEMBLY:                                  ", &
    & Variable%FIRST_ASSEMBLY
  
  ! Variable%RESIDUAL
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RESIDUAL)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "RESIDUAL " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MATRICES_NONLINEAR_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_MATRICES_TYPE (CheckVariable0), SOLVER_MAPPING_TYPE (CheckVariable1), EQUATIONS_TYPE (CheckVariable2), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RESIDUAL"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%RESIDUAL, NullPtr11, NullPtr12, NullPtr13, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "RESIDUAL (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NodalResidualCalculated:         ", &
    & Variable%NodalResidualCalculated
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ELEMENT_RESIDUAL_CALCULATED:     ", &
    & Variable%ELEMENT_RESIDUAL_CALCULATED

  
END SUBROUTINE Print_EQUATIONS_MATRICES_NONLINEAR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_EVALUATOR_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
  & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, &
  & CheckVariable31, CheckVariable32, CheckVariable33, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable31
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable32
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable33

  ! iterator variables

  ! null pointers
  TYPE(FIELD_TYPE), POINTER :: NullPtr0
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr2
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr6
  TYPE(MESHES_TYPE), POINTER :: NullPtr7
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr8
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: NullPtr9
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr11
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr12
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr13
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: NullPtr14
  TYPE(CELLML_TYPE), POINTER :: NullPtr15
  TYPE(MESH_TYPE), POINTER :: NullPtr16
  TYPE(FIELDS_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: NullPtr18
  TYPE(CELLML_MODEL_TYPE), POINTER :: NullPtr19
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr20
  TYPE(NODES_TYPE), POINTER :: NullPtr21
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr22
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr23
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr24
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: NullPtr25
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr26
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr27
  TYPE(REGION_TYPE), POINTER :: NullPtr28

  TYPE(SOLVER_TYPE), POINTER :: Ptr0

  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable15)) THEN
    Variable2 => CheckVariable15
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)

  
  ! Variable%SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: CELLML_EVALUATOR_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), PROBLEM_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), SOLVER_EQUATIONS_TYPE (CheckVariable22), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), HISTORY_TYPE (CheckVariable25), DAE_SOLVER_TYPE (CheckVariable26), SOLVERS_TYPE (CheckVariable27), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable28), SOLVER_TYPE (CheckVariable29), SOLVER_MAPPING_TYPE (CheckVariable30), EULER_DAE_SOLVER_TYPE (CheckVariable31), LINEAR_SOLVER_TYPE (CheckVariable32), EIGENPROBLEM_SOLVER_TYPE (CheckVariable33), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable16
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable29
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable17

    ! if variable was already followed
    Ptr0 => Variable%SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable29)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & SOLVER, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, CheckVariable3, CheckVariable4, NullPtr1, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, Variable2, CheckVariable16, CheckVariable33, CheckVariable18, &
        & CheckVariable19, CheckVariable20, CheckVariable21, NullPtr2, CheckVariable22, NullPtr3, CheckVariable23, &
        & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, NullPtr4, &
        & NullPtr5, CheckVariable30, CheckVariable31, NullPtr6, CheckVariable32, CheckVariable17, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)
  
  ! Variable%CELLML
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CELLML)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML " // &
      & "(associated): " 
  
! Signature of Print_CELLML_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, CELLML_MODEL_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_EVALUATOR_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), PROBLEM_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), SOLVER_EQUATIONS_TYPE (CheckVariable22), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), HISTORY_TYPE (CheckVariable25), DAE_SOLVER_TYPE (CheckVariable26), SOLVERS_TYPE (CheckVariable27), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable28), SOLVER_TYPE (CheckVariable29), SOLVER_MAPPING_TYPE (CheckVariable30), EULER_DAE_SOLVER_TYPE (CheckVariable31), LINEAR_SOLVER_TYPE (CheckVariable32), EIGENPROBLEM_SOLVER_TYPE (CheckVariable33), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type CELLML_MODELS_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_MODELS_FIELD_TYPE
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_INTERMEDIATE_FIELD_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CELLML_STATE_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_STATE_FIELD_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type CELLML_FIELD_MAPS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_FIELD_MAPS_TYPE
! - signature type CELLML_MODEL_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_MODEL_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_PARAMETERS_FIELD_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML"
      CALL Print_CELLML_TYPE(Variable% &
        & CELLML, NullPtr7, NullPtr0, NullPtr8, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, &
        & NullPtr16, NullPtr17, NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, NullPtr23, NullPtr24, NullPtr25, &
        & NullPtr26, NullPtr27, NullPtr28, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "CURRENT_TIME:                ", &
    & Variable%CURRENT_TIME

  
END SUBROUTINE Print_CELLML_EVALUATOR_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_CELLML_INTERMEDIATE_FIELD_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, Depth, MaxDepth, MaxArrayLength)
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(CELLML_FIELD_MAPS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CELLML_STATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CELLML_MODELS_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable12

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr2
  TYPE(MESH_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_MODEL_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr9
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr11
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr12
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr13
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr14
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr15
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr16
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr17
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr18
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr19
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr20
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr21

  TYPE(CELLML_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable12)) THEN
    Variable2 => CheckVariable12
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)

  
  ! Variable%CELLML
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CELLML)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML " // &
      & "(associated): " 
  
! Signature of Print_CELLML_TYPE has the following CheckVariable types: MESHES_TYPE, FIELD_TYPE, REGION_PTR_TYPE, CELLML_MODELS_FIELD_TYPE, CELLML_INTERMEDIATE_FIELD_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, CELLML_ENVIRONMENTS_TYPE, CELLML_STATE_FIELD_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, CELLML_FIELD_MAPS_TYPE, CELLML_MODEL_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, CELLML_PARAMETERS_FIELD_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_INTERMEDIATE_FIELD_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), CELLML_FIELD_MAPS_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), CELLML_ENVIRONMENTS_TYPE (CheckVariable6), CELLML_STATE_FIELD_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), CELLML_MODELS_FIELD_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable12), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type CELLML_MODELS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_INTERMEDIATE_FIELD_TYPE
!   is type of this print routine, use Variable2
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_STATE_FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CELLML_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CELLML_FIELD_MAPS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type CELLML_MODEL_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_MODEL_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CELLML_PARAMETERS_FIELD_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr0 => Variable%CELLML
    IF (ASSOCIATED(Ptr0, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML"
      CALL Print_CELLML_TYPE(Variable% &
        & CELLML, NullPtr0, CheckVariable8, NullPtr1, CheckVariable10, Variable2, CheckVariable5, NullPtr2, CheckVariable6, &
        & CheckVariable7, CheckVariable9, NullPtr3, CheckVariable2, CheckVariable4, NullPtr4, NullPtr5, NullPtr6, NullPtr7, &
        & NullPtr8, CheckVariable0, CheckVariable1, CheckVariable3, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_TYPE), POINTER :: " // &
      & "CELLML (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "INTERMEDIATE_FIELD_FINISHED:                     ", &
    & Variable%INTERMEDIATE_FIELD_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "INTERMEDIATE_FIELD_AUTO_CREATED:                 ", &
    & Variable%INTERMEDIATE_FIELD_AUTO_CREATED
  
  ! Variable%INTERMEDIATE_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERMEDIATE_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "INTERMEDIATE_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: CELLML_INTERMEDIATE_FIELD_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), CELLML_PARAMETERS_FIELD_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), DECOMPOSITION_TYPE (CheckVariable3), CELLML_FIELD_MAPS_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), CELLML_ENVIRONMENTS_TYPE (CheckVariable6), CELLML_STATE_FIELD_TYPE (CheckVariable7), FIELD_TYPE (CheckVariable8), CELLML_TYPE (CheckVariable9), CELLML_MODELS_FIELD_TYPE (CheckVariable10), REGION_TYPE (CheckVariable11), CELLML_INTERMEDIATE_FIELD_TYPE (CheckVariable12), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr1 => Variable%INTERMEDIATE_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERMEDIATE_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & INTERMEDIATE_FIELD, NullPtr0, NullPtr10, NullPtr11, NullPtr12, CheckVariable8, NullPtr1, NullPtr13, NullPtr14, &
        & CheckVariable5, NullPtr15, CheckVariable6, NullPtr16, CheckVariable9, NullPtr17, NullPtr3, CheckVariable2, &
        & NullPtr5, NullPtr18, NullPtr6, NullPtr19, NullPtr7, NullPtr8, CheckVariable0, NullPtr20, CheckVariable3, &
        & NullPtr21, NullPtr9, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "INTERMEDIATE_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_CELLML_INTERMEDIATE_FIELD_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_LINEAR_ITERATIVE_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, Depth, MaxDepth, MaxArrayLength)
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14

  ! iterator variables

  ! null pointers
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr6
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr9
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr10
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: NullPtr11
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr12
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr13
  TYPE(HISTORY_TYPE), POINTER :: NullPtr14
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: NullPtr15
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr16
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr17
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr18

  TYPE(LINEAR_SOLVER_TYPE), POINTER :: Ptr0

  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable13)) THEN
    Variable2 => CheckVariable13
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)

  
  ! Variable%LINEAR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINEAR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(LINEAR_SOLVER_TYPE), POINTER :: " // &
      & "LINEAR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_LINEAR_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: LINEAR_ITERATIVE_SOLVER_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), CELLML_EQUATIONS_TYPE (CheckVariable2), SOLVERS_TYPE (CheckVariable3), SOLVER_TYPE (CheckVariable4), GeometricTransformationSolverType (CheckVariable5), LINEAR_SOLVER_TYPE (CheckVariable6), SOLVER_EQUATIONS_TYPE (CheckVariable7), OPTIMISER_SOLVER_TYPE (CheckVariable8), CONTROL_LOOP_TYPE (CheckVariable9), DYNAMIC_SOLVER_TYPE (CheckVariable10), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable11), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable12), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable13), EIGENPROBLEM_SOLVER_TYPE (CheckVariable14), 
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable5
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable6
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE

    ! if variable was already followed
    Ptr0 => Variable%LINEAR_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINEAR_SOLVER"
      CALL Print_LINEAR_SOLVER_TYPE(Variable% &
        & LINEAR_SOLVER, NullPtr0, NullPtr1, NullPtr2, CheckVariable12, Variable2, NullPtr3, CheckVariable1, NullPtr4, &
        & NullPtr5, NullPtr6, NullPtr7, NullPtr8, CheckVariable8, NullPtr9, CheckVariable10, CheckVariable11, &
        & CheckVariable5, CheckVariable14, NullPtr10, CheckVariable2, CheckVariable9, NullPtr11, CheckVariable7, NullPtr12, &
        & NullPtr13, NullPtr14, CheckVariable0, CheckVariable3, NullPtr15, CheckVariable4, NullPtr16, NullPtr17, &
        & CheckVariable6, NullPtr18, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(LINEAR_SOLVER_TYPE), POINTER :: " // &
      & "LINEAR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRICES_LIBRARY:         ", &
    & Variable%SOLVER_MATRICES_LIBRARY
  Comment = ""
  IF (Variable%ITERATIVE_SOLVER_TYPE == 1) THEN
    Comment = "SOLVER_ITERATIVE_RICHARDSON " // & 
      & "!Richardson iterative solver type"
  ENDIF
  IF (Variable%ITERATIVE_SOLVER_TYPE == 2) THEN
    Comment = "SOLVER_ITERATIVE_CHEBYSHEV " // & 
      & "!Chebyshev iterative solver type"
  ENDIF
  IF (Variable%ITERATIVE_SOLVER_TYPE == 3) THEN
    Comment = "SOLVER_ITERATIVE_CONJUGATE_GRADIENT " // & 
      & "!Conjugate gradient iterative solver type"
  ENDIF
  IF (Variable%ITERATIVE_SOLVER_TYPE == 4) THEN
    Comment = "SOLVER_ITERATIVE_BICONJUGATE_GRADIENT " // & 
      & "!Bi-conjugate gradient iterative solver type"
  ENDIF
  IF (Variable%ITERATIVE_SOLVER_TYPE == 5) THEN
    Comment = "SOLVER_ITERATIVE_GMRES " // & 
      & "!Generalised minimum residual iterative solver type"
  ENDIF
  IF (Variable%ITERATIVE_SOLVER_TYPE == 6) THEN
    Comment = "SOLVER_ITERATIVE_BiCGSTAB " // & 
      & "!Stabalised bi-conjugate gradient iterative solver type"
  ENDIF
  IF (Variable%ITERATIVE_SOLVER_TYPE == 7) THEN
    Comment = "SOLVER_ITERATIVE_CONJGRAD_SQUARED " // & 
      & "!Conjugate gradient squared iterative solver type"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ITERATIVE_SOLVER_TYPE:           ", &
    & Variable%ITERATIVE_SOLVER_TYPE, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%ITERATIVE_PRECONDITIONER_TYPE == 0) THEN
    Comment = "SOLVER_ITERATIVE_NO_PRECONDITIONER " // & 
      & "!No preconditioner type"
  ENDIF
  IF (Variable%ITERATIVE_PRECONDITIONER_TYPE == 1) THEN
    Comment = "SOLVER_ITERATIVE_JACOBI_PRECONDITIONER " // & 
      & "!Jacobi preconditioner type"
  ENDIF
  IF (Variable%ITERATIVE_PRECONDITIONER_TYPE == 2) THEN
    Comment = "SOLVER_ITERATIVE_BLOCK_JACOBI_PRECONDITIONER " // & 
      & "!Iterative block Jacobi preconditioner type"
  ENDIF
  IF (Variable%ITERATIVE_PRECONDITIONER_TYPE == 3) THEN
    Comment = "SOLVER_ITERATIVE_SOR_PRECONDITIONER " // & 
      & "!Successive over relaxation preconditioner type"
  ENDIF
  IF (Variable%ITERATIVE_PRECONDITIONER_TYPE == 4) THEN
    Comment = "SOLVER_ITERATIVE_INCOMPLETE_CHOLESKY_PRECONDITIONER " // & 
      & "!Incomplete Cholesky preconditioner type"
  ENDIF
  IF (Variable%ITERATIVE_PRECONDITIONER_TYPE == 5) THEN
    Comment = "SOLVER_ITERATIVE_INCOMPLETE_LU_PRECONDITIONER " // & 
      & "!Incomplete LU preconditioner type"
  ENDIF
  IF (Variable%ITERATIVE_PRECONDITIONER_TYPE == 6) THEN
    Comment = "SOLVER_ITERATIVE_ADDITIVE_SCHWARZ_PRECONDITIONER " // & 
      & "!Additive Schwrz preconditioner type"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ITERATIVE_PRECONDITIONER_TYPE:   ", &
    & Variable%ITERATIVE_PRECONDITIONER_TYPE, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%SOLUTION_INITIALISE_TYPE == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%SOLUTION_INITIALISE_TYPE == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%SOLUTION_INITIALISE_TYPE == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLUTION_INITIALISE_TYPE:        ", &
    & Variable%SOLUTION_INITIALISE_TYPE, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%MAXIMUM_NUMBER_OF_ITERATIONS == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%MAXIMUM_NUMBER_OF_ITERATIONS == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%MAXIMUM_NUMBER_OF_ITERATIONS == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MAXIMUM_NUMBER_OF_ITERATIONS:    ", &
    & Variable%MAXIMUM_NUMBER_OF_ITERATIONS, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "RELATIVE_TOLERANCE:          ", &
    & Variable%RELATIVE_TOLERANCE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "ABSOLUTE_TOLERANCE:          ", &
    & Variable%ABSOLUTE_TOLERANCE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "DIVERGENCE_TOLERANCE:        ", &
    & Variable%DIVERGENCE_TOLERANCE
  Comment = ""
  IF (Variable%GMRES_RESTART == 0) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_ZERO " // & 
      & "!Initialise the solution by zeroing it before a solve"
  ENDIF
  IF (Variable%GMRES_RESTART == 1) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_CURRENT_FIELD " // & 
      & "!Initialise the solution by copying in the current dependent field values"
  ENDIF
  IF (Variable%GMRES_RESTART == 2) THEN
    Comment = "SOLVER_SOLUTION_INITIALISE_NO_CHANGE " // & 
      & "!Do not change the solution before a solve"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GMRES_RESTART:                   ", &
    & Variable%GMRES_RESTART, " ", TRIM(Comment)

  
END SUBROUTINE Print_LINEAR_ITERATIVE_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr1
  TYPE(FIELDS_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr4
  TYPE(FIELD_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr6
  TYPE(REGION_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr9
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr11


  TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRIX_NUMBER:            ", &
    & Variable%SOLVER_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_VARIABLES:             ", &
    & Variable%NUMBER_OF_VARIABLES
  
  ! Variable%VARIABLE_TYPES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLE_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLE_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "VARIABLE_TYPES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLE_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%VARIABLE_TYPES,1), MIN(LBOUND(Variable%VARIABLE_TYPES,1)+MaxArrayLength, UBOUND(Variable% &
      & VARIABLE_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%VARIABLE_TYPES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "VARIABLE_TYPES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%VARIABLES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_PTR_TYPE), ALLOCATABLE :: " // &
      & "VARIABLES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%VARIABLES,1), MIN(LBOUND(Variable%VARIABLES,1)+MaxArrayLength, UBOUND(Variable%VARIABLES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_VARIABLE_PTR_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, FIELDS_TYPE, FIELD_PTR_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACE_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_VARIABLE_PTR_TYPE(Variable% &
          & VARIABLES(I0), NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, &
          & Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_PTR_TYPE), ALLOCATABLE :: " // &
      & "VARIABLES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%VARIABLE_TO_SOLVER_COL_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLE_TO_SOLVER_COL_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLE_TO_SOLVER_COL_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(VARIABLE_TO_SOLVER_COL_MAP_TYPE), ALLOCATABLE :: " // &
      & "VARIABLE_TO_SOLVER_COL_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLE_TO_SOLVER_COL_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%VARIABLE_TO_SOLVER_COL_MAPS,1), MIN(LBOUND(Variable% &
      & VARIABLE_TO_SOLVER_COL_MAPS,1)+MaxArrayLength, UBOUND(Variable%VARIABLE_TO_SOLVER_COL_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_VARIABLE_TO_SOLVER_COL_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLE_TO_SOLVER_COL_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_VARIABLE_TO_SOLVER_COL_MAP_TYPE(Variable%VARIABLE_TO_SOLVER_COL_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(VARIABLE_TO_SOLVER_COL_MAP_TYPE), ALLOCATABLE :: " // &
      & "VARIABLE_TO_SOLVER_COL_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DYNAMIC_EQUATIONS_MATRICES: ", &
    & Variable%NUMBER_OF_DYNAMIC_EQUATIONS_MATRICES
  
  ! Variable%DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE), ALLOCATABLE :: " // &
      & "DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS,1), MIN(LBOUND(Variable% &
      & DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS,1)+MaxArrayLength, UBOUND(Variable%DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE(Variable% &
          & DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE), ALLOCATABLE :: " // &
      & "DYNAMIC_EQUATIONS_TO_SOLVER_MATRIX_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LINEAR_EQUATIONS_MATRICES: ", &
    & Variable%NUMBER_OF_LINEAR_EQUATIONS_MATRICES
  
  ! Variable%LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE), ALLOCATABLE :: " // &
      & "LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS,1), MIN(LBOUND(Variable% &
      & LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS,1)+MaxArrayLength, UBOUND(Variable%LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE(Variable% &
          & LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE), ALLOCATABLE :: " // &
      & "LINEAR_EQUATIONS_TO_SOLVER_MATRIX_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_EQUATIONS_JACOBIANS:   ", &
    & Variable%NUMBER_OF_EQUATIONS_JACOBIANS
  
  ! Variable%JACOBIAN_TO_SOLVER_MATRIX_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%JACOBIAN_TO_SOLVER_MATRIX_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%JACOBIAN_TO_SOLVER_MATRIX_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(JACOBIAN_TO_SOLVER_MAP_PTR_TYPE), ALLOCATABLE :: " // &
      & "JACOBIAN_TO_SOLVER_MATRIX_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%JACOBIAN_TO_SOLVER_MATRIX_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%JACOBIAN_TO_SOLVER_MATRIX_MAPS,1), MIN(LBOUND(Variable% &
      & JACOBIAN_TO_SOLVER_MATRIX_MAPS,1)+MaxArrayLength, UBOUND(Variable%JACOBIAN_TO_SOLVER_MATRIX_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_JACOBIAN_TO_SOLVER_MAP_PTR_TYPE has the following CheckVariable types: SOLVER_MATRICES_TYPE, SOLVER_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, 
! The type to handle in this routine is: EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE (Variable)
! Available CheckVariables are: 
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"JACOBIAN_TO_SOLVER_MATRIX_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_JACOBIAN_TO_SOLVER_MAP_PTR_TYPE(Variable% &
          & JACOBIAN_TO_SOLVER_MATRIX_MAPS(I0), NullPtr9, NullPtr10, NullPtr11, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(JACOBIAN_TO_SOLVER_MAP_PTR_TYPE), ALLOCATABLE :: " // &
      & "JACOBIAN_TO_SOLVER_MATRIX_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_NODE_PARAM_TO_DOF_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_NODE_PARAMETERS:       ", &
    & Variable%NUMBER_OF_NODE_PARAMETERS
  
  ! Variable%NODES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_NODE_TYPE), ALLOCATABLE :: " // &
      & "NODES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%NODES,1), MIN(LBOUND(Variable%NODES,1)+MaxArrayLength, UBOUND(Variable%NODES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_NODE_PARAM_TO_DOF_MAP_NODE_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: FIELD_NODE_PARAM_TO_DOF_MAP_TYPE (Variable)
! Available CheckVariables are: 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NODES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_NODE_PARAM_TO_DOF_MAP_NODE_TYPE(Variable%NODES(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_NODE_TYPE), ALLOCATABLE :: " // &
      & "NODES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_NODE_PARAM_TO_DOF_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_NONLINEAR_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
  & CheckVariable32, CheckVariable33, CheckVariable34, CheckVariable35, CheckVariable36, CheckVariable37, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable31
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable32
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable33
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable34
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable35
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable36
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable37

  ! iterator variables

  ! null pointers
  TYPE(FIELD_TYPE), POINTER :: NullPtr0
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr1
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr2

  TYPE(SOLVER_TYPE), POINTER :: Ptr0
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: Ptr1
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: Ptr2

  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)

  
  ! Variable%SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: NONLINEAR_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable5), QUASI_NEWTON_SOLVER_TYPE (CheckVariable6), NONLINEAR_SOLVER_TYPE (CheckVariable7), NEWTON_SOLVER_TYPE (CheckVariable8), CONTROL_LOOP_FIXED_TYPE (CheckVariable9), CONTROL_LOOP_TIME_TYPE (CheckVariable10), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable11), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable12), OPTIMISER_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), GeometricTransformationSolverType (CheckVariable17), EIGENPROBLEM_SOLVER_TYPE (CheckVariable18), BOUNDARY_CONDITIONS_TYPE (CheckVariable19), CELLML_EQUATIONS_TYPE (CheckVariable20), CONTROL_LOOP_TYPE (CheckVariable21), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable22), SOLVER_EQUATIONS_TYPE (CheckVariable23), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable24), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable25), SOLVER_MATRICES_TYPE (CheckVariable26), HISTORY_TYPE (CheckVariable27), DAE_SOLVER_TYPE (CheckVariable28), SOLVERS_TYPE (CheckVariable29), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable30), SOLVER_TYPE (CheckVariable31), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable32), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable33), SOLVER_MAPPING_TYPE (CheckVariable34), EULER_DAE_SOLVER_TYPE (CheckVariable35), LINEAR_SOLVER_TYPE (CheckVariable36), PROBLEM_TYPE (CheckVariable37), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NONLINEAR_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable17
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable31
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable35
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable37

    ! if variable was already followed
    Ptr0 => Variable%SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable31)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & SOLVER, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, Variable2, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, &
        & CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, &
        & CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable33, NullPtr1, CheckVariable23, CheckVariable24, &
        & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, &
        & CheckVariable31, CheckVariable32, CheckVariable22, CheckVariable34, CheckVariable35, NullPtr2, CheckVariable36, &
        & CheckVariable37, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%NONLINEAR_SOLVE_TYPE == 1) THEN
    Comment = "SOLVER_NONLINEAR_NEWTON " // & 
      & "!Newton nonlinear solver type"
  ENDIF
  IF (Variable%NONLINEAR_SOLVE_TYPE == 2) THEN
    Comment = "SOLVER_NONLINEAR_BFGS_INVERSE " // & 
      & "!BFGS inverse nonlinear solver type"
  ENDIF
  IF (Variable%NONLINEAR_SOLVE_TYPE == 3) THEN
    Comment = "SOLVER_NONLINEAR_SQP " // & 
      & "!Sequential Quadratic Program nonlinear solver type"
  ENDIF
  IF (Variable%NONLINEAR_SOLVE_TYPE == 4) THEN
    Comment = "SOLVER_NONLINEAR_QUASI_NEWTON " // & 
      & "!Sequential Quasi-Newton nonlinear solver type"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NONLINEAR_SOLVE_TYPE:            ", &
    & Variable%NONLINEAR_SOLVE_TYPE, " ", TRIM(Comment)
  
  ! Variable%NEWTON_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NEWTON_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NEWTON_SOLVER_TYPE), POINTER :: " // &
      & "NEWTON_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_NEWTON_SOLVER_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, PROBLEM_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, LINEAR_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: NONLINEAR_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable5), QUASI_NEWTON_SOLVER_TYPE (CheckVariable6), NONLINEAR_SOLVER_TYPE (CheckVariable7), NEWTON_SOLVER_TYPE (CheckVariable8), CONTROL_LOOP_FIXED_TYPE (CheckVariable9), CONTROL_LOOP_TIME_TYPE (CheckVariable10), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable11), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable12), OPTIMISER_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), GeometricTransformationSolverType (CheckVariable17), EIGENPROBLEM_SOLVER_TYPE (CheckVariable18), BOUNDARY_CONDITIONS_TYPE (CheckVariable19), CELLML_EQUATIONS_TYPE (CheckVariable20), CONTROL_LOOP_TYPE (CheckVariable21), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable22), SOLVER_EQUATIONS_TYPE (CheckVariable23), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable24), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable25), SOLVER_MATRICES_TYPE (CheckVariable26), HISTORY_TYPE (CheckVariable27), DAE_SOLVER_TYPE (CheckVariable28), SOLVERS_TYPE (CheckVariable29), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable30), SOLVER_TYPE (CheckVariable31), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable32), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable33), SOLVER_MAPPING_TYPE (CheckVariable34), EULER_DAE_SOLVER_TYPE (CheckVariable35), LINEAR_SOLVER_TYPE (CheckVariable36), PROBLEM_TYPE (CheckVariable37), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NONLINEAR_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable17
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18

    ! if variable was already followed
    Ptr1 => Variable%NEWTON_SOLVER
    IF (ASSOCIATED(Ptr1, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NEWTON_SOLVER"
      CALL Print_NEWTON_SOLVER_TYPE(Variable% &
        & NEWTON_SOLVER, CheckVariable1, CheckVariable5, CheckVariable6, Variable2, CheckVariable8, CheckVariable9, &
        & CheckVariable10, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable37, CheckVariable20, CheckVariable21, CheckVariable23, CheckVariable24, CheckVariable25, &
        & CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable31, CheckVariable36, CheckVariable18, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NEWTON_SOLVER_TYPE), POINTER :: " // &
      & "NEWTON_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%QUASI_NEWTON_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%QUASI_NEWTON_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: " // &
      & "QUASI_NEWTON_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_QUASI_NEWTON_SOLVER_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: NONLINEAR_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable5), QUASI_NEWTON_SOLVER_TYPE (CheckVariable6), NONLINEAR_SOLVER_TYPE (CheckVariable7), NEWTON_SOLVER_TYPE (CheckVariable8), CONTROL_LOOP_FIXED_TYPE (CheckVariable9), CONTROL_LOOP_TIME_TYPE (CheckVariable10), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable11), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable12), OPTIMISER_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), GeometricTransformationSolverType (CheckVariable17), EIGENPROBLEM_SOLVER_TYPE (CheckVariable18), BOUNDARY_CONDITIONS_TYPE (CheckVariable19), CELLML_EQUATIONS_TYPE (CheckVariable20), CONTROL_LOOP_TYPE (CheckVariable21), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable22), SOLVER_EQUATIONS_TYPE (CheckVariable23), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable24), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable25), SOLVER_MATRICES_TYPE (CheckVariable26), HISTORY_TYPE (CheckVariable27), DAE_SOLVER_TYPE (CheckVariable28), SOLVERS_TYPE (CheckVariable29), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable30), SOLVER_TYPE (CheckVariable31), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable32), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable33), SOLVER_MAPPING_TYPE (CheckVariable34), EULER_DAE_SOLVER_TYPE (CheckVariable35), LINEAR_SOLVER_TYPE (CheckVariable36), PROBLEM_TYPE (CheckVariable37), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable6
! - signature type NONLINEAR_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable17
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable37

    ! if variable was already followed
    Ptr2 => Variable%QUASI_NEWTON_SOLVER
    IF (ASSOCIATED(Ptr2, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"QUASI_NEWTON_SOLVER"
      CALL Print_QUASI_NEWTON_SOLVER_TYPE(Variable% &
        & QUASI_NEWTON_SOLVER, CheckVariable1, CheckVariable6, Variable2, CheckVariable8, CheckVariable9, CheckVariable10, &
        & CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, &
        & CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable25, CheckVariable27, &
        & CheckVariable28, CheckVariable29, CheckVariable31, CheckVariable32, CheckVariable36, CheckVariable37, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: " // &
      & "QUASI_NEWTON_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_NONLINEAR_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_COORDINATE_SYSTEM_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(COORDINATE_SYSTEM_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers


  TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "USER_NUMBER:                     ", &
    & Variable%USER_NUMBER
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "COORDINATE_SYSTEM_FINISHED:                      ", &
    & Variable%COORDINATE_SYSTEM_FINISHED
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TYPE:                            ", &
    & Variable%TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "RADIAL_INTERPOLATION_TYPE:       ", &
    & Variable%RADIAL_INTERPOLATION_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DIMENSIONS:            ", &
    & Variable%NUMBER_OF_DIMENSIONS
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "FOCUS:                       ", &
    & Variable%FOCUS
    PRINT*," "
    DO I0 = LBOUND(Variable%ORIGIN,1), 3
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ORIGIN(I0)

    ENDDO  ! I0
    PRINT*," "
    DO I0 = LBOUND(Variable%ORIENTATION,1), 3
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%ORIENTATION,2), 3
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%ORIENTATION(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0

  
END SUBROUTINE Print_COORDINATE_SYSTEM_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EIGENPROBLEM_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
  & CheckVariable17, CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
  & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, &
  & CheckVariable31, CheckVariable32, CheckVariable33, Depth, MaxDepth, MaxArrayLength)
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable31
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable32
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable33

  ! iterator variables

  ! null pointers
  TYPE(FIELD_TYPE), POINTER :: NullPtr0
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr2
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr6

  TYPE(SOLVER_TYPE), POINTER :: Ptr0

  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable17)) THEN
    Variable2 => CheckVariable17
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: EIGENPROBLEM_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), SOLVER_EQUATIONS_TYPE (CheckVariable22), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), HISTORY_TYPE (CheckVariable25), DAE_SOLVER_TYPE (CheckVariable26), SOLVERS_TYPE (CheckVariable27), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable28), SOLVER_TYPE (CheckVariable29), SOLVER_MAPPING_TYPE (CheckVariable30), EULER_DAE_SOLVER_TYPE (CheckVariable31), LINEAR_SOLVER_TYPE (CheckVariable32), PROBLEM_TYPE (CheckVariable33), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable16
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable29
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable33

    ! if variable was already followed
    Ptr0 => Variable%SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable29)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & SOLVER, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, CheckVariable3, CheckVariable4, NullPtr1, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, Variable2, CheckVariable18, &
        & CheckVariable19, CheckVariable20, CheckVariable21, NullPtr2, CheckVariable22, NullPtr3, CheckVariable23, &
        & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, NullPtr4, &
        & NullPtr5, CheckVariable30, CheckVariable31, NullPtr6, CheckVariable32, CheckVariable33, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_MATRICES_LIBRARY:         ", &
    & Variable%SOLVER_MATRICES_LIBRARY

  
END SUBROUTINE Print_EIGENPROBLEM_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DECOMPOSITION_FACE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(DECOMPOSITION_FACE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(DECOMPOSITION_FACE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER:                          ", &
    & Variable%NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "XI_DIRECTION:                    ", &
    & Variable%XI_DIRECTION
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_SURROUNDING_ELEMENTS:  ", &
    & Variable%NUMBER_OF_SURROUNDING_ELEMENTS
  
  ! Variable%SURROUNDING_ELEMENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%SURROUNDING_ELEMENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%SURROUNDING_ELEMENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "SURROUNDING_ELEMENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%SURROUNDING_ELEMENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%SURROUNDING_ELEMENTS,1), MIN(LBOUND(Variable% &
      & SURROUNDING_ELEMENTS,1)+MaxArrayLength, UBOUND(Variable%SURROUNDING_ELEMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%SURROUNDING_ELEMENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "SURROUNDING_ELEMENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ELEMENT_FACES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENT_FACES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENT_FACES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_FACES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENT_FACES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENT_FACES,1), MIN(LBOUND(Variable%ELEMENT_FACES,1)+MaxArrayLength, UBOUND(Variable%ELEMENT_FACES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ELEMENT_FACES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENT_FACES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "BOUNDARY_FACE:                                   ", &
    & Variable%BOUNDARY_FACE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "ELEMENT_NUMBER:                  ", &
    & Variable%ELEMENT_NUMBER

  
END SUBROUTINE Print_DECOMPOSITION_FACE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_LINEAR_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
  & CheckVariable32, CheckVariable33, Depth, MaxDepth, MaxArrayLength)
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable31
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable32
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable33

  ! iterator variables

  ! null pointers
  TYPE(FIELD_TYPE), POINTER :: NullPtr0
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr2
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr6

  TYPE(SOLVER_TYPE), POINTER :: Ptr0
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: Ptr1
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: Ptr2

  TYPE(LINEAR_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable32)) THEN
    Variable2 => CheckVariable32
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: LINEAR_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), SOLVER_EQUATIONS_TYPE (CheckVariable22), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), HISTORY_TYPE (CheckVariable25), DAE_SOLVER_TYPE (CheckVariable26), SOLVERS_TYPE (CheckVariable27), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable28), SOLVER_TYPE (CheckVariable29), SOLVER_MAPPING_TYPE (CheckVariable30), EULER_DAE_SOLVER_TYPE (CheckVariable31), LINEAR_SOLVER_TYPE (CheckVariable32), PROBLEM_TYPE (CheckVariable33), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable16
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable29
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable33

    ! if variable was already followed
    Ptr0 => Variable%SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable29)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & SOLVER, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, CheckVariable3, CheckVariable4, NullPtr1, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, NullPtr2, CheckVariable22, NullPtr3, &
        & CheckVariable23, CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, &
        & CheckVariable29, NullPtr4, NullPtr5, CheckVariable30, CheckVariable31, NullPtr6, Variable2, CheckVariable33, &
        & Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%LINEAR_SOLVE_TYPE == 1) THEN
    Comment = "SOLVER_LINEAR_DIRECT_SOLVE_TYPE " // & 
      & "!Direct linear solver type"
  ENDIF
  IF (Variable%LINEAR_SOLVE_TYPE == 2) THEN
    Comment = "SOLVER_LINEAR_ITERATIVE_SOLVE_TYPE " // & 
      & "!Iterative linear solver type"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LINEAR_SOLVE_TYPE:               ", &
    & Variable%LINEAR_SOLVE_TYPE, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "LINKED_NEWTON_PETSC_SOLVER:                      ", &
    & Variable%LINKED_NEWTON_PETSC_SOLVER
  
  ! Variable%DIRECT_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DIRECT_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: " // &
      & "DIRECT_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_LINEAR_DIRECT_SOLVER_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, GeometricTransformationSolverType, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: LINEAR_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), SOLVER_EQUATIONS_TYPE (CheckVariable22), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), HISTORY_TYPE (CheckVariable25), DAE_SOLVER_TYPE (CheckVariable26), SOLVERS_TYPE (CheckVariable27), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable28), SOLVER_TYPE (CheckVariable29), SOLVER_MAPPING_TYPE (CheckVariable30), EULER_DAE_SOLVER_TYPE (CheckVariable31), LINEAR_SOLVER_TYPE (CheckVariable32), PROBLEM_TYPE (CheckVariable33), 
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable16
! - signature type LINEAR_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17

    ! if variable was already followed
    Ptr1 => Variable%DIRECT_SOLVER
    IF (ASSOCIATED(Ptr1, CheckVariable3)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DIRECT_SOLVER"
      CALL Print_LINEAR_DIRECT_SOLVER_TYPE(Variable% &
        & DIRECT_SOLVER, CheckVariable26, CheckVariable6, CheckVariable19, CheckVariable27, CheckVariable29, &
        & CheckVariable16, Variable2, CheckVariable22, CheckVariable12, CheckVariable20, CheckVariable14, CheckVariable15, &
        & CheckVariable3, CheckVariable4, CheckVariable17, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: " // &
      & "DIRECT_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%ITERATIVE_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ITERATIVE_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: " // &
      & "ITERATIVE_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_LINEAR_ITERATIVE_SOLVER_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, GeometricTransformationSolverType, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: LINEAR_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable13), DYNAMIC_SOLVER_TYPE (CheckVariable14), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable15), GeometricTransformationSolverType (CheckVariable16), EIGENPROBLEM_SOLVER_TYPE (CheckVariable17), BOUNDARY_CONDITIONS_TYPE (CheckVariable18), CELLML_EQUATIONS_TYPE (CheckVariable19), CONTROL_LOOP_TYPE (CheckVariable20), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable21), SOLVER_EQUATIONS_TYPE (CheckVariable22), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable23), SOLVER_MATRICES_TYPE (CheckVariable24), HISTORY_TYPE (CheckVariable25), DAE_SOLVER_TYPE (CheckVariable26), SOLVERS_TYPE (CheckVariable27), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable28), SOLVER_TYPE (CheckVariable29), SOLVER_MAPPING_TYPE (CheckVariable30), EULER_DAE_SOLVER_TYPE (CheckVariable31), LINEAR_SOLVER_TYPE (CheckVariable32), PROBLEM_TYPE (CheckVariable33), 
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable16
! - signature type LINEAR_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17

    ! if variable was already followed
    Ptr2 => Variable%ITERATIVE_SOLVER
    IF (ASSOCIATED(Ptr2, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ITERATIVE_SOLVER"
      CALL Print_LINEAR_ITERATIVE_SOLVER_TYPE(Variable% &
        & ITERATIVE_SOLVER, CheckVariable26, CheckVariable6, CheckVariable19, CheckVariable27, CheckVariable29, &
        & CheckVariable16, Variable2, CheckVariable22, CheckVariable12, CheckVariable20, CheckVariable14, CheckVariable15, &
        & CheckVariable3, CheckVariable4, CheckVariable17, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: " // &
      & "ITERATIVE_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_LINEAR_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DECOMPOSITIONS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, Depth, MaxDepth, MaxArrayLength)
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MeshComponentTopologyType), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(DecompositionDataPointsType), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable27

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: NullPtr0
  TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: NullPtr1
  TYPE(INTERFACE_PTR_TYPE), POINTER :: NullPtr2
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr3
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr5
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: NullPtr6
  TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: NullPtr7

  TYPE(MESH_TYPE), POINTER :: Ptr0
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: Ptr1

  TYPE(DECOMPOSITIONS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable19)) THEN
    Variable2 => CheckVariable19
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)

  
  ! Variable%MESH
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MESH)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_TYPE), POINTER :: " // &
      & "MESH " // &
      & "(associated): " 
  
! Signature of Print_MESH_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, GENERATED_MESH_CYLINDER_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, GENERATED_MESH_ELLIPSOID_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, MeshComponentTopologyPtrType, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, REGION_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, GENERATED_MESH_REGULAR_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DECOMPOSITIONS_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable4), FIELD_PTR_TYPE (CheckVariable5), GENERATED_MESH_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), MeshComponentTopologyPtrType (CheckVariable8), InterfacePointsConnectivityType (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), DECOMPOSITION_FACES_TYPE (CheckVariable13), DECOMPOSITION_ELEMENTS_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), DECOMPOSITION_PTR_TYPE (CheckVariable16), FIELDS_TYPE (CheckVariable17), GENERATED_MESHES_TYPE (CheckVariable18), DECOMPOSITIONS_TYPE (CheckVariable19), NODES_TYPE (CheckVariable20), DOMAIN_PTR_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), DATA_PROJECTION_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), DecompositionDataPointsType (CheckVariable25), DECOMPOSITION_LINES_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type MeshComponentTopologyType
!   matches available passing type, use it as CheckVariable0
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type GENERATED_MESH_CYLINDER_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_CYLINDER_TYPE
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_ELLIPSOID_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_ELLIPSOID_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable8
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type INTERFACE_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_PTR_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type MESH_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable15
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DECOMPOSITIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type GENERATED_MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_PTR_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type GENERATED_MESH_REGULAR_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_REGULAR_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27

    ! if variable was already followed
    Ptr0 => Variable%MESH
    IF (ASSOCIATED(Ptr0, CheckVariable15)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MESH"
      CALL Print_MESH_TYPE(Variable% &
        & MESH, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, CheckVariable3, NullPtr1, CheckVariable4, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & NullPtr2, NullPtr3, CheckVariable12, NullPtr4, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, Variable2, CheckVariable20, CheckVariable21, NullPtr5, CheckVariable22, NullPtr6, &
        & CheckVariable23, NullPtr7, CheckVariable24, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_TYPE), POINTER :: " // &
      & "MESH (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DECOMPOSITIONS:        ", &
    & Variable%NUMBER_OF_DECOMPOSITIONS
  
  ! Variable%DECOMPOSITIONS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%DECOMPOSITIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: " // &
      & "DECOMPOSITIONS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%DECOMPOSITIONS,1), "): "
  
    DO I0 = LBOUND(Variable%DECOMPOSITIONS,1), MIN(LBOUND(Variable%DECOMPOSITIONS,1)+MaxArrayLength, UBOUND(Variable% &
      & DECOMPOSITIONS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DECOMPOSITION_PTR_TYPE has the following CheckVariable types: DECOMPOSITION_PTR_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, MESHES_TYPE, DOMAIN_TYPE, MESH_PTR_TYPE, DECOMPOSITION_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, DECOMPOSITION_FACES_TYPE, DecompositionDataPointsType, REGION_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, GENERATED_MESH_TYPE, DECOMPOSITION_LINES_TYPE, FIELD_TYPE, DECOMPOSITIONS_TYPE, InterfacePointsConnectivityType, DOMAIN_PTR_TYPE, INTERFACE_TYPE, 
! The type to handle in this routine is: DECOMPOSITIONS_TYPE (Variable)
! Available CheckVariables are: MeshComponentTopologyType (CheckVariable0), MESHES_TYPE (CheckVariable1), MESH_PTR_TYPE (CheckVariable2), INTERFACE_CONDITIONS_TYPE (CheckVariable3), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable4), FIELD_PTR_TYPE (CheckVariable5), GENERATED_MESH_TYPE (CheckVariable6), FIELD_TYPE (CheckVariable7), MeshComponentTopologyPtrType (CheckVariable8), InterfacePointsConnectivityType (CheckVariable9), INTERFACE_TYPE (CheckVariable10), DOMAIN_TYPE (CheckVariable11), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable12), DECOMPOSITION_FACES_TYPE (CheckVariable13), DECOMPOSITION_ELEMENTS_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), DECOMPOSITION_PTR_TYPE (CheckVariable16), FIELDS_TYPE (CheckVariable17), GENERATED_MESHES_TYPE (CheckVariable18), DECOMPOSITIONS_TYPE (CheckVariable19), NODES_TYPE (CheckVariable20), DOMAIN_PTR_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), DATA_PROJECTION_TYPE (CheckVariable23), DECOMPOSITION_TYPE (CheckVariable24), DecompositionDataPointsType (CheckVariable25), DECOMPOSITION_LINES_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable16
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MESHES_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable25
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITIONS_TYPE
!   is type of this print routine, use Variable2
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable9
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable10

      ! if variable was already followed
      Ptr1 => Variable%DECOMPOSITIONS(I0)
      IF (ASSOCIATED(Ptr1, CheckVariable16)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DECOMPOSITIONS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DECOMPOSITION_PTR_TYPE(Variable% &
          & DECOMPOSITIONS(I0), CheckVariable16, CheckVariable14, CheckVariable15, CheckVariable1, CheckVariable11, &
          & CheckVariable2, CheckVariable24, CheckVariable4, CheckVariable13, CheckVariable25, CheckVariable27, &
          & CheckVariable12, CheckVariable6, CheckVariable26, CheckVariable7, Variable2, CheckVariable9, CheckVariable21, &
          & CheckVariable10, Depth+1, MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: " // &
      & "DECOMPOSITIONS(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DECOMPOSITIONS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_INTERPOLATION_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable7

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EquationsSetDerivedType), POINTER :: NullPtr0
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr3
  TYPE(SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: NullPtr5
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: NullPtr6
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: NullPtr8
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr9
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: NullPtr10
  TYPE(MESHES_TYPE), POINTER :: NullPtr11
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr12
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr13
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr14
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr15
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr16
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr18
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr19
  TYPE(CELLML_TYPE), POINTER :: NullPtr20
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr21
  TYPE(MESH_TYPE), POINTER :: NullPtr22
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr23
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr24
  TYPE(NODES_TYPE), POINTER :: NullPtr25
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr26
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr27
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr28
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr29
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr30
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr31
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr32

  TYPE(EQUATIONS_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)
  Nullify(NullPtr26)
  Nullify(NullPtr27)
  Nullify(NullPtr28)
  Nullify(NullPtr29)
  Nullify(NullPtr30)
  Nullify(NullPtr31)
  Nullify(NullPtr32)

  
  ! Variable%EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EquationsSetDerivedType, BOUNDARY_CONDITIONS_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, FIELDS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, EQUATIONS_MAPPING_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_SET_MATERIALS_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, INTERFACE_TYPE, EQUATIONS_INTERPOLATION_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EquationsSetDerivedType
!   is not available in passing variables, use NullPtr of type EquationsSetDerivedType
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_ANALYTIC_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_MATERIALS_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type EQUATIONS_INTERPOLATION_TYPE
!   is type of this print routine, use Variable2
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_INDEPENDENT_TYPE

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS
    IF (ASSOCIATED(Ptr0, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS"
      CALL Print_EQUATIONS_TYPE(Variable% &
        & EQUATIONS, CheckVariable0, CheckVariable1, NullPtr0, NullPtr1, NullPtr2, CheckVariable2, NullPtr3, NullPtr4, &
        & NullPtr5, NullPtr6, CheckVariable3, NullPtr7, NullPtr8, NullPtr9, CheckVariable4, CheckVariable5, Variable2, &
        & CheckVariable6, CheckVariable7, NullPtr10, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_TYPE), POINTER :: " // &
      & "EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%GEOMETRIC_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%GEOMETRIC_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "GEOMETRIC_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7

    ! if variable was already followed
    Ptr1 => Variable%GEOMETRIC_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GEOMETRIC_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & GEOMETRIC_FIELD, NullPtr11, NullPtr12, NullPtr13, NullPtr14, CheckVariable4, NullPtr15, NullPtr16, &
        & CheckVariable6, CheckVariable5, NullPtr17, NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, CheckVariable2, &
        & NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, NullPtr29, NullPtr30, NullPtr31, NullPtr8, &
        & NullPtr32, CheckVariable7, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "GEOMETRIC_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%FIBRE_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FIBRE_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIBRE_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7

    ! if variable was already followed
    Ptr1 => Variable%FIBRE_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIBRE_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & FIBRE_FIELD, NullPtr11, NullPtr12, NullPtr13, NullPtr14, CheckVariable4, NullPtr15, NullPtr16, CheckVariable6, &
        & CheckVariable5, NullPtr17, NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, CheckVariable2, NullPtr23, &
        & NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, NullPtr29, NullPtr30, NullPtr31, NullPtr8, NullPtr32, &
        & CheckVariable7, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "FIBRE_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DEPENDENT_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DEPENDENT_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "DEPENDENT_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7

    ! if variable was already followed
    Ptr1 => Variable%DEPENDENT_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DEPENDENT_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & DEPENDENT_FIELD, NullPtr11, NullPtr12, NullPtr13, NullPtr14, CheckVariable4, NullPtr15, NullPtr16, &
        & CheckVariable6, CheckVariable5, NullPtr17, NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, CheckVariable2, &
        & NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, NullPtr29, NullPtr30, NullPtr31, NullPtr8, &
        & NullPtr32, CheckVariable7, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "DEPENDENT_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INDEPENDENT_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INDEPENDENT_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "INDEPENDENT_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7

    ! if variable was already followed
    Ptr1 => Variable%INDEPENDENT_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INDEPENDENT_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & INDEPENDENT_FIELD, NullPtr11, NullPtr12, NullPtr13, NullPtr14, CheckVariable4, NullPtr15, NullPtr16, &
        & CheckVariable6, CheckVariable5, NullPtr17, NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, CheckVariable2, &
        & NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, NullPtr29, NullPtr30, NullPtr31, NullPtr8, &
        & NullPtr32, CheckVariable7, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "INDEPENDENT_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MATERIALS_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%MATERIALS_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "MATERIALS_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7

    ! if variable was already followed
    Ptr1 => Variable%MATERIALS_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATERIALS_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & MATERIALS_FIELD, NullPtr11, NullPtr12, NullPtr13, NullPtr14, CheckVariable4, NullPtr15, NullPtr16, &
        & CheckVariable6, CheckVariable5, NullPtr17, NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, CheckVariable2, &
        & NullPtr23, NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, NullPtr29, NullPtr30, NullPtr31, NullPtr8, &
        & NullPtr32, CheckVariable7, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "MATERIALS_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOURCE_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOURCE_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "SOURCE_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable7

    ! if variable was already followed
    Ptr1 => Variable%SOURCE_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOURCE_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & SOURCE_FIELD, NullPtr11, NullPtr12, NullPtr13, NullPtr14, CheckVariable4, NullPtr15, NullPtr16, CheckVariable6, &
        & CheckVariable5, NullPtr17, NullPtr18, NullPtr19, NullPtr20, NullPtr21, NullPtr22, CheckVariable2, NullPtr23, &
        & NullPtr24, NullPtr25, NullPtr26, NullPtr27, NullPtr28, NullPtr29, NullPtr30, NullPtr31, NullPtr8, NullPtr32, &
        & CheckVariable7, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "SOURCE_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%GEOMETRIC_INTERP_PARAMETERS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%GEOMETRIC_INTERP_PARAMETERS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "GEOMETRIC_INTERP_PARAMETERS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%GEOMETRIC_INTERP_PARAMETERS,1), "): "
  
    DO I0 = LBOUND(Variable%GEOMETRIC_INTERP_PARAMETERS,1), MIN(LBOUND(Variable% &
      & GEOMETRIC_INTERP_PARAMETERS,1)+MaxArrayLength, UBOUND(Variable%GEOMETRIC_INTERP_PARAMETERS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE has the following CheckVariable types: FIELD_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GEOMETRIC_INTERP_PARAMETERS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE(Variable% &
          & GEOMETRIC_INTERP_PARAMETERS(I0), CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "GEOMETRIC_INTERP_PARAMETERS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%FIBRE_INTERP_PARAMETERS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%FIBRE_INTERP_PARAMETERS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "FIBRE_INTERP_PARAMETERS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%FIBRE_INTERP_PARAMETERS,1), "): "
  
    DO I0 = LBOUND(Variable%FIBRE_INTERP_PARAMETERS,1), MIN(LBOUND(Variable% &
      & FIBRE_INTERP_PARAMETERS,1)+MaxArrayLength, UBOUND(Variable%FIBRE_INTERP_PARAMETERS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE has the following CheckVariable types: FIELD_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIBRE_INTERP_PARAMETERS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE(Variable% &
          & FIBRE_INTERP_PARAMETERS(I0), CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "FIBRE_INTERP_PARAMETERS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DEPENDENT_INTERP_PARAMETERS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%DEPENDENT_INTERP_PARAMETERS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "DEPENDENT_INTERP_PARAMETERS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%DEPENDENT_INTERP_PARAMETERS,1), "): "
  
    DO I0 = LBOUND(Variable%DEPENDENT_INTERP_PARAMETERS,1), MIN(LBOUND(Variable% &
      & DEPENDENT_INTERP_PARAMETERS,1)+MaxArrayLength, UBOUND(Variable%DEPENDENT_INTERP_PARAMETERS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE has the following CheckVariable types: FIELD_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DEPENDENT_INTERP_PARAMETERS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE(Variable% &
          & DEPENDENT_INTERP_PARAMETERS(I0), CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "DEPENDENT_INTERP_PARAMETERS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INDEPENDENT_INTERP_PARAMETERS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%INDEPENDENT_INTERP_PARAMETERS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "INDEPENDENT_INTERP_PARAMETERS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%INDEPENDENT_INTERP_PARAMETERS,1), "): "
  
    DO I0 = LBOUND(Variable%INDEPENDENT_INTERP_PARAMETERS,1), MIN(LBOUND(Variable% &
      & INDEPENDENT_INTERP_PARAMETERS,1)+MaxArrayLength, UBOUND(Variable%INDEPENDENT_INTERP_PARAMETERS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE has the following CheckVariable types: FIELD_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INDEPENDENT_INTERP_PARAMETERS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE(Variable% &
          & INDEPENDENT_INTERP_PARAMETERS(I0), CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "INDEPENDENT_INTERP_PARAMETERS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MATERIALS_INTERP_PARAMETERS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%MATERIALS_INTERP_PARAMETERS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "MATERIALS_INTERP_PARAMETERS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%MATERIALS_INTERP_PARAMETERS,1), "): "
  
    DO I0 = LBOUND(Variable%MATERIALS_INTERP_PARAMETERS,1), MIN(LBOUND(Variable% &
      & MATERIALS_INTERP_PARAMETERS,1)+MaxArrayLength, UBOUND(Variable%MATERIALS_INTERP_PARAMETERS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE has the following CheckVariable types: FIELD_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATERIALS_INTERP_PARAMETERS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE(Variable% &
          & MATERIALS_INTERP_PARAMETERS(I0), CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "MATERIALS_INTERP_PARAMETERS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOURCE_INTERP_PARAMETERS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%SOURCE_INTERP_PARAMETERS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "SOURCE_INTERP_PARAMETERS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%SOURCE_INTERP_PARAMETERS,1), "): "
  
    DO I0 = LBOUND(Variable%SOURCE_INTERP_PARAMETERS,1), MIN(LBOUND(Variable% &
      & SOURCE_INTERP_PARAMETERS,1)+MaxArrayLength, UBOUND(Variable%SOURCE_INTERP_PARAMETERS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE has the following CheckVariable types: FIELD_TYPE, 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable4
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOURCE_INTERP_PARAMETERS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE(Variable% &
          & SOURCE_INTERP_PARAMETERS(I0), CheckVariable4, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: " // &
      & "SOURCE_INTERP_PARAMETERS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%GEOMETRIC_INTERP_POINT(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%GEOMETRIC_INTERP_POINT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "GEOMETRIC_INTERP_POINT(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%GEOMETRIC_INTERP_POINT,1), "): "
  
    DO I0 = LBOUND(Variable%GEOMETRIC_INTERP_POINT,1), MIN(LBOUND(Variable% &
      & GEOMETRIC_INTERP_POINT,1)+MaxArrayLength, UBOUND(Variable%GEOMETRIC_INTERP_POINT,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATED_POINT_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GEOMETRIC_INTERP_POINT("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATED_POINT_PTR_TYPE(Variable%GEOMETRIC_INTERP_POINT(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "GEOMETRIC_INTERP_POINT(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%FIBRE_INTERP_POINT(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%FIBRE_INTERP_POINT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "FIBRE_INTERP_POINT(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%FIBRE_INTERP_POINT,1), "): "
  
    DO I0 = LBOUND(Variable%FIBRE_INTERP_POINT,1), MIN(LBOUND(Variable% &
      & FIBRE_INTERP_POINT,1)+MaxArrayLength, UBOUND(Variable%FIBRE_INTERP_POINT,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATED_POINT_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIBRE_INTERP_POINT("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATED_POINT_PTR_TYPE(Variable%FIBRE_INTERP_POINT(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "FIBRE_INTERP_POINT(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DEPENDENT_INTERP_POINT(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%DEPENDENT_INTERP_POINT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "DEPENDENT_INTERP_POINT(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%DEPENDENT_INTERP_POINT,1), "): "
  
    DO I0 = LBOUND(Variable%DEPENDENT_INTERP_POINT,1), MIN(LBOUND(Variable% &
      & DEPENDENT_INTERP_POINT,1)+MaxArrayLength, UBOUND(Variable%DEPENDENT_INTERP_POINT,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATED_POINT_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DEPENDENT_INTERP_POINT("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATED_POINT_PTR_TYPE(Variable%DEPENDENT_INTERP_POINT(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "DEPENDENT_INTERP_POINT(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INDEPENDENT_INTERP_POINT(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%INDEPENDENT_INTERP_POINT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "INDEPENDENT_INTERP_POINT(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%INDEPENDENT_INTERP_POINT,1), "): "
  
    DO I0 = LBOUND(Variable%INDEPENDENT_INTERP_POINT,1), MIN(LBOUND(Variable% &
      & INDEPENDENT_INTERP_POINT,1)+MaxArrayLength, UBOUND(Variable%INDEPENDENT_INTERP_POINT,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATED_POINT_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INDEPENDENT_INTERP_POINT("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATED_POINT_PTR_TYPE(Variable%INDEPENDENT_INTERP_POINT(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "INDEPENDENT_INTERP_POINT(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%MATERIALS_INTERP_POINT(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%MATERIALS_INTERP_POINT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "MATERIALS_INTERP_POINT(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%MATERIALS_INTERP_POINT,1), "): "
  
    DO I0 = LBOUND(Variable%MATERIALS_INTERP_POINT,1), MIN(LBOUND(Variable% &
      & MATERIALS_INTERP_POINT,1)+MaxArrayLength, UBOUND(Variable%MATERIALS_INTERP_POINT,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATED_POINT_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATERIALS_INTERP_POINT("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATED_POINT_PTR_TYPE(Variable%MATERIALS_INTERP_POINT(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "MATERIALS_INTERP_POINT(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOURCE_INTERP_POINT(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%SOURCE_INTERP_POINT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "SOURCE_INTERP_POINT(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%SOURCE_INTERP_POINT,1), "): "
  
    DO I0 = LBOUND(Variable%SOURCE_INTERP_POINT,1), MIN(LBOUND(Variable% &
      & SOURCE_INTERP_POINT,1)+MaxArrayLength, UBOUND(Variable%SOURCE_INTERP_POINT,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATED_POINT_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOURCE_INTERP_POINT("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATED_POINT_PTR_TYPE(Variable%SOURCE_INTERP_POINT(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: " // &
      & "SOURCE_INTERP_POINT(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DEPENDENT_PHYSICAL_POINT(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%DEPENDENT_PHYSICAL_POINT)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_PHYSICAL_POINT_PTR_TYPE), POINTER :: " // &
      & "DEPENDENT_PHYSICAL_POINT(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%DEPENDENT_PHYSICAL_POINT,1), "): "
  
    DO I0 = LBOUND(Variable%DEPENDENT_PHYSICAL_POINT,1), MIN(LBOUND(Variable% &
      & DEPENDENT_PHYSICAL_POINT,1)+MaxArrayLength, UBOUND(Variable%DEPENDENT_PHYSICAL_POINT,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_PHYSICAL_POINT_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DEPENDENT_PHYSICAL_POINT("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_PHYSICAL_POINT_PTR_TYPE(Variable%DEPENDENT_PHYSICAL_POINT(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_PHYSICAL_POINT_PTR_TYPE), POINTER :: " // &
      & "DEPENDENT_PHYSICAL_POINT(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DEPENDENT_INTERP_POINT_METRICS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%DEPENDENT_INTERP_POINT_METRICS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: " // &
      & "DEPENDENT_INTERP_POINT_METRICS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%DEPENDENT_INTERP_POINT_METRICS,1), "): "
  
    DO I0 = LBOUND(Variable%DEPENDENT_INTERP_POINT_METRICS,1), MIN(LBOUND(Variable% &
      & DEPENDENT_INTERP_POINT_METRICS,1)+MaxArrayLength, UBOUND(Variable%DEPENDENT_INTERP_POINT_METRICS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DEPENDENT_INTERP_POINT_METRICS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE(Variable% &
          & DEPENDENT_INTERP_POINT_METRICS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: " // &
      & "DEPENDENT_INTERP_POINT_METRICS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INDEPENDENT_INTERP_POINT_METRICS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%INDEPENDENT_INTERP_POINT_METRICS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: " // &
      & "INDEPENDENT_INTERP_POINT_METRICS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%INDEPENDENT_INTERP_POINT_METRICS,1), "): "
  
    DO I0 = LBOUND(Variable%INDEPENDENT_INTERP_POINT_METRICS,1), MIN(LBOUND(Variable% &
      & INDEPENDENT_INTERP_POINT_METRICS,1)+MaxArrayLength, UBOUND(Variable%INDEPENDENT_INTERP_POINT_METRICS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INDEPENDENT_INTERP_POINT_METRICS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE(Variable% &
          & INDEPENDENT_INTERP_POINT_METRICS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: " // &
      & "INDEPENDENT_INTERP_POINT_METRICS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%GEOMETRIC_INTERP_POINT_METRICS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%GEOMETRIC_INTERP_POINT_METRICS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: " // &
      & "GEOMETRIC_INTERP_POINT_METRICS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%GEOMETRIC_INTERP_POINT_METRICS,1), "): "
  
    DO I0 = LBOUND(Variable%GEOMETRIC_INTERP_POINT_METRICS,1), MIN(LBOUND(Variable% &
      & GEOMETRIC_INTERP_POINT_METRICS,1)+MaxArrayLength, UBOUND(Variable%GEOMETRIC_INTERP_POINT_METRICS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"GEOMETRIC_INTERP_POINT_METRICS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE(Variable% &
          & GEOMETRIC_INTERP_POINT_METRICS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: " // &
      & "GEOMETRIC_INTERP_POINT_METRICS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%FIBRE_INTERP_POINT_METRICS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%FIBRE_INTERP_POINT_METRICS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: " // &
      & "FIBRE_INTERP_POINT_METRICS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%FIBRE_INTERP_POINT_METRICS,1), "): "
  
    DO I0 = LBOUND(Variable%FIBRE_INTERP_POINT_METRICS,1), MIN(LBOUND(Variable% &
      & FIBRE_INTERP_POINT_METRICS,1)+MaxArrayLength, UBOUND(Variable%FIBRE_INTERP_POINT_METRICS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_INTERPOLATION_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_SET_TYPE (CheckVariable1), FIELDS_TYPE (CheckVariable2), SOLVER_MAPPING_TYPE (CheckVariable3), FIELD_TYPE (CheckVariable4), INTERFACE_TYPE (CheckVariable5), EQUATIONS_SETS_TYPE (CheckVariable6), REGION_TYPE (CheckVariable7), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FIBRE_INTERP_POINT_METRICS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE(Variable% &
          & FIBRE_INTERP_POINT_METRICS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: " // &
      & "FIBRE_INTERP_POINT_METRICS(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_INTERPOLATION_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_InterfacePointConnectivityType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(InterfacePointConnectivityType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(InterfacePointConnectivityType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "coupledMeshElementNumber:        ", &
    & Variable%coupledMeshElementNumber
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "elementLineFaceNumber:           ", &
    & Variable%elementLineFaceNumber
  
  ! Variable%xi(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%xi)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%xi),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "xi(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%xi, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%xi,1), MIN(LBOUND(Variable%xi,1)+MaxArrayLength, UBOUND(Variable%xi,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%xi(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "xi(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%reducedXi(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%reducedXi)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%reducedXi),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "reducedXi(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%reducedXi, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%reducedXi,1), MIN(LBOUND(Variable%reducedXi,1)+MaxArrayLength, UBOUND(Variable%reducedXi,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%reducedXi(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "reducedXi(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_InterfacePointConnectivityType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_JACOBIAN_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_JACOBIAN_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr0
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr2
  TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER :: NullPtr3
  TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER :: NullPtr4


  TYPE(EQUATIONS_JACOBIAN_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "JACOBIAN_NUMBER:                 ", &
    & Variable%JACOBIAN_NUMBER
  
  ! Variable%NONLINEAR_MATRICES
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NONLINEAR_MATRICES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: " // &
      & "NONLINEAR_MATRICES " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MATRICES_NONLINEAR_TYPE has the following CheckVariable types: EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, EQUATIONS_TYPE, 
! The type to handle in this routine is: EQUATIONS_JACOBIAN_TYPE (Variable)
! Available CheckVariables are: 
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NONLINEAR_MATRICES"
      CALL Print_EQUATIONS_MATRICES_NONLINEAR_TYPE(Variable% &
        & NONLINEAR_MATRICES, NullPtr0, NullPtr1, NullPtr2, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: " // &
      & "NONLINEAR_MATRICES (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "STORAGE_TYPE:                    ", &
    & Variable%STORAGE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "STRUCTURE_TYPE:                  ", &
    & Variable%STRUCTURE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_COLUMNS:               ", &
    & Variable%NUMBER_OF_COLUMNS
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "UPDATE_JACOBIAN:                                 ", &
    & Variable%UPDATE_JACOBIAN
  
  ! Variable%JACOBIAN
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%JACOBIAN)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "JACOBIAN " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_MATRIX_TYPE has the following CheckVariable types: DISTRIBUTED_MATRIX_CMISS_TYPE, DISTRIBUTED_MATRIX_PETSC_TYPE, 
! The type to handle in this routine is: EQUATIONS_JACOBIAN_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DISTRIBUTED_MATRIX_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_CMISS_TYPE
! - signature type DISTRIBUTED_MATRIX_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_PETSC_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"JACOBIAN"
      CALL Print_DISTRIBUTED_MATRIX_TYPE(Variable%JACOBIAN, NullPtr3, NullPtr4, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "JACOBIAN (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "FIRST_ASSEMBLY:                                  ", &
    & Variable%FIRST_ASSEMBLY
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "JACOBIAN_CALCULATION_TYPE:       ", &
    & Variable%JACOBIAN_CALCULATION_TYPE

  
END SUBROUTINE Print_EQUATIONS_JACOBIAN_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_MAPPING_DYNAMIC_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, Depth, MaxDepth, MaxArrayLength)
  TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable3

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER :: NullPtr1
  TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER :: NullPtr2
  TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: NullPtr3
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr4
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: NullPtr5
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr6
  TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER :: NullPtr7
  TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER :: NullPtr8
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr10
  TYPE(MESHES_TYPE), POINTER :: NullPtr11
  TYPE(FIELDS_TYPE), POINTER :: NullPtr12
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr13
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr16
  TYPE(CELLML_TYPE), POINTER :: NullPtr17
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr19
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr20
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr21
  TYPE(NODES_TYPE), POINTER :: NullPtr22
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr23

  TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: Ptr0

  TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)

  
  ! Variable%EQUATIONS_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_MAPPING_TYPE has the following CheckVariable types: EQUATIONS_TYPE, EQUATIONS_SET_TYPE, EQUATIONS_MAPPING_LINEAR_TYPE, EQUATIONS_MAPPING_DYNAMIC_TYPE, EQUATIONS_MAPPING_RHS_TYPE, EQUATIONS_MATRICES_TYPE, SOLVER_MAPPING_TYPE, REGION_TYPE, SOLVER_EQUATIONS_TYPE, FIELD_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_MAPPING_SOURCE_TYPE, EQUATIONS_MAPPING_NONLINEAR_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_DYNAMIC_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), REGION_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type EQUATIONS_MAPPING_LINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_LINEAR_TYPE
! - signature type EQUATIONS_MAPPING_DYNAMIC_TYPE
!   is type of this print routine, use Variable2
! - signature type EQUATIONS_MAPPING_RHS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_RHS_TYPE
! - signature type EQUATIONS_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MATRICES_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type SOLVER_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_EQUATIONS_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type EQUATIONS_MAPPING_SOURCE_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_SOURCE_TYPE
! - signature type EQUATIONS_MAPPING_NONLINEAR_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_MAPPING_NONLINEAR_TYPE

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_MAPPING
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MAPPING"
      CALL Print_EQUATIONS_MAPPING_TYPE(Variable% &
        & EQUATIONS_MAPPING, CheckVariable0, NullPtr0, NullPtr1, Variable2, NullPtr2, NullPtr3, NullPtr4, CheckVariable2, &
        & NullPtr5, CheckVariable3, NullPtr6, NullPtr7, NullPtr8, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: " // &
      & "EQUATIONS_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DYNAMIC_EQUATIONS_MATRICES: ", &
    & Variable%NUMBER_OF_DYNAMIC_EQUATIONS_MATRICES
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "STIFFNESS_MATRIX_NUMBER:         ", &
    & Variable%STIFFNESS_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DAMPING_MATRIX_NUMBER:           ", &
    & Variable%DAMPING_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "MASS_MATRIX_NUMBER:              ", &
    & Variable%MASS_MATRIX_NUMBER
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DYNAMIC_VARIABLE_TYPE:           ", &
    & Variable%DYNAMIC_VARIABLE_TYPE
  
  ! Variable%DYNAMIC_VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DYNAMIC_VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "DYNAMIC_VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: EQUATIONS_MAPPING_DYNAMIC_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), REGION_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DYNAMIC_VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & DYNAMIC_VARIABLE, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, &
        & NullPtr17, NullPtr18, CheckVariable3, NullPtr19, NullPtr20, NullPtr21, NullPtr22, NullPtr6, CheckVariable2, &
        & NullPtr23, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "DYNAMIC_VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%VAR_TO_EQUATIONS_MATRICES_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VAR_TO_EQUATIONS_MATRICES_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VAR_TO_EQUATIONS_MATRICES_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(VAR_TO_EQUATIONS_MATRICES_MAP_TYPE), ALLOCATABLE :: " // &
      & "VAR_TO_EQUATIONS_MATRICES_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VAR_TO_EQUATIONS_MATRICES_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%VAR_TO_EQUATIONS_MATRICES_MAPS,1), MIN(LBOUND(Variable% &
      & VAR_TO_EQUATIONS_MATRICES_MAPS,1)+MaxArrayLength, UBOUND(Variable%VAR_TO_EQUATIONS_MATRICES_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_VAR_TO_EQUATIONS_MATRICES_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MAPPING_DYNAMIC_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), REGION_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VAR_TO_EQUATIONS_MATRICES_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_VAR_TO_EQUATIONS_MATRICES_MAP_TYPE(Variable% &
          & VAR_TO_EQUATIONS_MATRICES_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(VAR_TO_EQUATIONS_MATRICES_MAP_TYPE), ALLOCATABLE :: " // &
      & "VAR_TO_EQUATIONS_MATRICES_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_MATRIX_TO_VAR_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_MATRIX_TO_VAR_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_MATRIX_TO_VAR_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_MATRIX_TO_VAR_MAP_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_MATRIX_TO_VAR_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_MATRIX_TO_VAR_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%EQUATIONS_MATRIX_TO_VAR_MAPS,1), MIN(LBOUND(Variable% &
      & EQUATIONS_MATRIX_TO_VAR_MAPS,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_MATRIX_TO_VAR_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_EQUATIONS_MATRIX_TO_VAR_MAP_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: EQUATIONS_MAPPING_DYNAMIC_TYPE (Variable)
! Available CheckVariables are: EQUATIONS_TYPE (CheckVariable0), EQUATIONS_MAPPING_TYPE (CheckVariable1), REGION_TYPE (CheckVariable2), FIELD_TYPE (CheckVariable3), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_MATRIX_TO_VAR_MAPS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_EQUATIONS_MATRIX_TO_VAR_MAP_TYPE(Variable%EQUATIONS_MATRIX_TO_VAR_MAPS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_MATRIX_TO_VAR_MAP_TYPE), ALLOCATABLE :: " // &
      & "EQUATIONS_MATRIX_TO_VAR_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS,1), MIN(LBOUND(Variable% &
      & EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_ROW_TO_VARIABLE_DOF_MAPS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EQUATIONS_MAPPING_DYNAMIC_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_DYNAMIC_EQUATIONS_MATRICES: ", &
    & Variable%NUMBER_OF_DYNAMIC_EQUATIONS_MATRICES
  
  ! Variable%EQUATIONS_MATRIX_NUMBERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_MATRIX_NUMBERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_MATRIX_NUMBERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_MATRIX_NUMBERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_MATRIX_NUMBERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_MATRIX_NUMBERS,1), MIN(LBOUND(Variable% &
      & EQUATIONS_MATRIX_NUMBERS,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_MATRIX_NUMBERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_MATRIX_NUMBERS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_MATRIX_NUMBERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_COL_NUMBERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_COL_NUMBERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_COL_NUMBERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_COL_NUMBERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_COL_NUMBERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_COL_NUMBERS,1), MIN(LBOUND(Variable% &
      & EQUATIONS_COL_NUMBERS,1)+MaxArrayLength, UBOUND(Variable%EQUATIONS_COL_NUMBERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_COL_NUMBERS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_COL_NUMBERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%COUPLING_COEFFICIENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%COUPLING_COEFFICIENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%COUPLING_COEFFICIENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%COUPLING_COEFFICIENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%COUPLING_COEFFICIENTS,1), MIN(LBOUND(Variable% &
      & COUPLING_COEFFICIENTS,1)+MaxArrayLength, UBOUND(Variable%COUPLING_COEFFICIENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%COUPLING_COEFFICIENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "COUPLING_COEFFICIENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EQUATIONS_SET_DEPENDENT_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(EQUATIONS_SET_DEPENDENT_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(EquationsSetDerivedType), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER, INTENT(IN) :: CheckVariable15

  ! iterator variables

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr1
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr2
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr3
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr4
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr5
  TYPE(NODES_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8
  TYPE(SOLVERS_TYPE), POINTER :: NullPtr9
  TYPE(SOLVER_TYPE), POINTER :: NullPtr10
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr12
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr13
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: NullPtr14
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr15
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr16
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr17
  TYPE(CELLML_TYPE), POINTER :: NullPtr18
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: NullPtr19
  TYPE(MESH_TYPE), POINTER :: NullPtr20
  TYPE(DECOMPOSITIONS_TYPE), POINTER :: NullPtr21
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr22
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr23
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr24

  TYPE(EQUATIONS_SET_TYPE), POINTER :: Ptr0
  TYPE(FIELD_TYPE), POINTER :: Ptr1

  TYPE(EQUATIONS_SET_DEPENDENT_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)

  
  ! Variable%EQUATIONS_SET
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EQUATIONS_SET)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET " // &
      & "(associated): " 
  
! Signature of Print_EQUATIONS_SET_TYPE has the following CheckVariable types: EQUATIONS_TYPE, MESHES_TYPE, EquationsSetDerivedType, FIELD_TYPE, REGION_PTR_TYPE, EQUATIONS_SETS_TYPE, EQUATIONS_SET_MATERIALS_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, EQUATIONS_SET_ANALYTIC_TYPE, SOLVERS_TYPE, DECOMPOSITION_TYPE, SOLVER_TYPE, EQUATIONS_SET_SOURCE_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, EQUATIONS_SET_PTR_TYPE, SOLVER_EQUATIONS_TYPE, REGION_TYPE, EQUATIONS_SET_INDEPENDENT_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_DEPENDENT_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type EquationsSetDerivedType
!   matches available passing type, use it as CheckVariable3
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type EQUATIONS_SET_MATERIALS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type EQUATIONS_SET_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_ANALYTIC_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVERS_TYPE
!   is not available in passing variables, use NullPtr of type SOLVERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_TYPE
! - signature type EQUATIONS_SET_SOURCE_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type EQUATIONS_SET_INDEPENDENT_TYPE
!   matches available passing type, use it as CheckVariable15

    ! if variable was already followed
    Ptr0 => Variable%EQUATIONS_SET
    IF (ASSOCIATED(Ptr0, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EQUATIONS_SET"
      CALL Print_EQUATIONS_SET_TYPE(Variable% &
        & EQUATIONS_SET, CheckVariable1, NullPtr0, CheckVariable3, CheckVariable12, NullPtr1, CheckVariable13, &
        & CheckVariable8, CheckVariable9, NullPtr2, NullPtr3, CheckVariable2, NullPtr4, CheckVariable5, NullPtr5, NullPtr6, &
        & NullPtr7, NullPtr8, CheckVariable0, CheckVariable4, NullPtr9, CheckVariable6, NullPtr10, CheckVariable7, &
        & NullPtr11, NullPtr12, CheckVariable10, CheckVariable11, CheckVariable14, CheckVariable15, Depth+1, MaxDepth, &
        & MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EQUATIONS_SET_TYPE), POINTER :: " // &
      & "EQUATIONS_SET (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "DEPENDENT_FINISHED:                              ", &
    & Variable%DEPENDENT_FINISHED
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "DEPENDENT_FIELD_AUTO_CREATED:                    ", &
    & Variable%DEPENDENT_FIELD_AUTO_CREATED
  
  ! Variable%DEPENDENT_FIELD
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DEPENDENT_FIELD)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_TYPE), POINTER :: " // &
      & "DEPENDENT_FIELD " // &
      & "(associated): " 
  
! Signature of Print_FIELD_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: EQUATIONS_SET_DEPENDENT_TYPE (Variable)
! Available CheckVariables are: DATA_PROJECTION_TYPE (CheckVariable0), EQUATIONS_TYPE (CheckVariable1), EQUATIONS_SET_TYPE (CheckVariable2), EquationsSetDerivedType (CheckVariable3), EQUATIONS_SET_ANALYTIC_TYPE (CheckVariable4), FIELDS_TYPE (CheckVariable5), DECOMPOSITION_TYPE (CheckVariable6), EQUATIONS_SET_SOURCE_TYPE (CheckVariable7), EQUATIONS_SET_MATERIALS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), EQUATIONS_SET_PTR_TYPE (CheckVariable10), SOLVER_EQUATIONS_TYPE (CheckVariable11), FIELD_TYPE (CheckVariable12), EQUATIONS_SETS_TYPE (CheckVariable13), REGION_TYPE (CheckVariable14), EQUATIONS_SET_INDEPENDENT_TYPE (CheckVariable15), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type INTERFACE_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITIONS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable12
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_PTR_TYPE
! - signature type MESH_TYPE
!   is not available in passing variables, use NullPtr of type MESH_TYPE
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITIONS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable14

    ! if variable was already followed
    Ptr1 => Variable%DEPENDENT_FIELD
    IF (ASSOCIATED(Ptr1, CheckVariable12)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DEPENDENT_FIELD"
      CALL Print_FIELD_TYPE(Variable% &
        & DEPENDENT_FIELD, NullPtr0, NullPtr13, NullPtr14, NullPtr15, CheckVariable12, NullPtr1, NullPtr16, &
        & CheckVariable13, CheckVariable9, NullPtr17, NullPtr2, NullPtr3, NullPtr18, NullPtr19, NullPtr20, CheckVariable5, &
        & NullPtr5, NullPtr21, NullPtr6, NullPtr22, NullPtr7, NullPtr8, CheckVariable0, NullPtr23, CheckVariable6, &
        & CheckVariable10, NullPtr24, CheckVariable14, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_TYPE), POINTER :: " // &
      & "DEPENDENT_FIELD (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_EQUATIONS_SET_DEPENDENT_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EMBEDDING_XI_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(EMBEDDING_XI_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers


  TYPE(EMBEDDING_XI_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_NODES:                 ", &
    & Variable%NUMBER_OF_NODES
  
  ! Variable%NODE_NUMBERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%NODE_NUMBERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%NODE_NUMBERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_NUMBERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%NODE_NUMBERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%NODE_NUMBERS,1), MIN(LBOUND(Variable%NODE_NUMBERS,1)+MaxArrayLength, UBOUND(Variable%NODE_NUMBERS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%NODE_NUMBERS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "NODE_NUMBERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%XI_COORDS(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%XI_COORDS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%XI_COORDS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "XI_COORDS(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%XI_COORDS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%XI_COORDS,1), MIN(LBOUND(Variable%XI_COORDS,1)+MaxArrayLength, UBOUND(Variable%XI_COORDS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%XI_COORDS,2), MIN(LBOUND(Variable%XI_COORDS,2)+MaxArrayLength, UBOUND(Variable%XI_COORDS,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%XI_COORDS(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "XI_COORDS(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_EMBEDDING_XI_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_FIELD_ELEMENT_PARAM_TO_DOF_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(FIELD_ELEMENT_PARAM_TO_DOF_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(FIELD_ELEMENT_PARAM_TO_DOF_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ELEMENT_PARAMETERS:    ", &
    & Variable%NUMBER_OF_ELEMENT_PARAMETERS
  
  ! Variable%ELEMENTS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ELEMENTS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ELEMENTS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENTS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ELEMENTS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ELEMENTS,1), MIN(LBOUND(Variable%ELEMENTS,1)+MaxArrayLength, UBOUND(Variable%ELEMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ELEMENTS(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "ELEMENTS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_FIELD_ELEMENT_PARAM_TO_DOF_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_DOF_TO_VARIABLE_MAP_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_DOF_TO_VARIABLE_MAP_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr1
  TYPE(FIELDS_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr4
  TYPE(FIELD_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr6
  TYPE(REGION_TYPE), POINTER :: NullPtr7
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr8


  TYPE(SOLVER_DOF_TO_VARIABLE_MAP_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)

  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_EQUATION_DOFS:         ", &
    & Variable%NUMBER_OF_EQUATION_DOFS
  
  ! Variable%EQUATIONS_TYPES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_TYPES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_TYPES,1), MIN(LBOUND(Variable%EQUATIONS_TYPES,1)+MaxArrayLength, UBOUND(Variable% &
      & EQUATIONS_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_TYPES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_TYPES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATIONS_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATIONS_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATIONS_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATIONS_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATIONS_INDICES,1), MIN(LBOUND(Variable%EQUATIONS_INDICES,1)+MaxArrayLength, UBOUND(Variable% &
      & EQUATIONS_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATIONS_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATIONS_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%VARIABLE(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLE)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLE),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_PTR_TYPE), ALLOCATABLE :: " // &
      & "VARIABLE(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLE, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%VARIABLE,1), MIN(LBOUND(Variable%VARIABLE,1)+MaxArrayLength, UBOUND(Variable%VARIABLE,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_FIELD_VARIABLE_PTR_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, FIELDS_TYPE, FIELD_PTR_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACE_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: SOLVER_DOF_TO_VARIABLE_MAP_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLE("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_FIELD_VARIABLE_PTR_TYPE(Variable% &
          & VARIABLE(I0), NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, &
          & Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_PTR_TYPE), ALLOCATABLE :: " // &
      & "VARIABLE(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%VARIABLE_DOF(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLE_DOF)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLE_DOF),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "VARIABLE_DOF(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLE_DOF, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%VARIABLE_DOF,1), MIN(LBOUND(Variable%VARIABLE_DOF,1)+MaxArrayLength, UBOUND(Variable%VARIABLE_DOF,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%VARIABLE_DOF(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "VARIABLE_DOF(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%VARIABLE_COEFFICIENT(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%VARIABLE_COEFFICIENT)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%VARIABLE_COEFFICIENT),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "VARIABLE_COEFFICIENT(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%VARIABLE_COEFFICIENT, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%VARIABLE_COEFFICIENT,1), MIN(LBOUND(Variable% &
      & VARIABLE_COEFFICIENT,1)+MaxArrayLength, UBOUND(Variable%VARIABLE_COEFFICIENT,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%VARIABLE_COEFFICIENT(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "VARIABLE_COEFFICIENT(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%ADDITIVE_CONSTANT(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%ADDITIVE_CONSTANT)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%ADDITIVE_CONSTANT),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "ADDITIVE_CONSTANT(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%ADDITIVE_CONSTANT, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%ADDITIVE_CONSTANT,1), MIN(LBOUND(Variable%ADDITIVE_CONSTANT,1)+MaxArrayLength, UBOUND(Variable% &
      & ADDITIVE_CONSTANT,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%ADDITIVE_CONSTANT(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "ADDITIVE_CONSTANT(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_SOLVER_DOF_TO_VARIABLE_MAP_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_MATRICES_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, Depth, MaxDepth, &
  & MaxArrayLength)
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(SOLVER_MATRIX_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr0
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_TYPE), POINTER :: NullPtr3
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr6
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr7
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr8
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr9
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr10
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr11
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: NullPtr12
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: NullPtr13
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr14
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr15
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr16
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: NullPtr17
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr18
  TYPE(HISTORY_TYPE), POINTER :: NullPtr19
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: NullPtr20
  TYPE(EQUATIONS_TYPE), POINTER :: NullPtr21
  TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: NullPtr22
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: NullPtr23
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr24
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: NullPtr25

  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: Ptr0
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: Ptr1

  TYPE(SOLVER_MATRICES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable7)) THEN
    Variable2 => CheckVariable7
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)
  Nullify(NullPtr18)
  Nullify(NullPtr19)
  Nullify(NullPtr20)
  Nullify(NullPtr21)
  Nullify(NullPtr22)
  Nullify(NullPtr23)
  Nullify(NullPtr24)
  Nullify(NullPtr25)

  
  ! Variable%SOLVER_EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: " // &
      & "SOLVER_EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_EQUATIONS_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, PROBLEM_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, LINEAR_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_MATRICES_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), BOUNDARY_CONDITIONS_TYPE (CheckVariable2), CELLML_EQUATIONS_TYPE (CheckVariable3), SOLVERS_TYPE (CheckVariable4), SOLVER_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), SOLVER_MATRICES_TYPE (CheckVariable7), SOLVER_MATRIX_TYPE (CheckVariable8), LINEAR_SOLVER_TYPE (CheckVariable9), SOLVER_EQUATIONS_TYPE (CheckVariable10), OPTIMISER_SOLVER_TYPE (CheckVariable11), CONTROL_LOOP_TYPE (CheckVariable12), DYNAMIC_SOLVER_TYPE (CheckVariable13), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable14), GeometricTransformationSolverType (CheckVariable15), EIGENPROBLEM_SOLVER_TYPE (CheckVariable16), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type BDF_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BDF_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUSH_LARSON_DAE_SOLVER_TYPE
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EULER_DAE_SOLVER_TYPE
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type EXTERNAL_DAE_SOLVER_TYPE
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type RUNGE_KUTTA_DAE_SOLVER_TYPE
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable15
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type CRANK_NICOLSON_DAE_SOLVER_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable10
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type ADAMS_MOULTON_DAE_SOLVER_TYPE
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVER_MATRICES_TYPE
!   is type of this print routine, use Variable2
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16

    ! if variable was already followed
    Ptr0 => Variable%SOLVER_EQUATIONS
    IF (ASSOCIATED(Ptr0, CheckVariable10)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_EQUATIONS"
      CALL Print_SOLVER_EQUATIONS_TYPE(Variable% &
        & SOLVER_EQUATIONS, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, CheckVariable1, &
        & NullPtr8, NullPtr9, NullPtr10, NullPtr11, NullPtr12, NullPtr13, CheckVariable11, NullPtr14, CheckVariable13, &
        & CheckVariable14, CheckVariable15, NullPtr15, NullPtr16, CheckVariable2, CheckVariable3, CheckVariable12, &
        & NullPtr17, CheckVariable10, NullPtr18, NullPtr19, CheckVariable0, CheckVariable4, NullPtr20, CheckVariable5, &
        & CheckVariable6, Variable2, CheckVariable9, CheckVariable16, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: " // &
      & "SOLVER_EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "SOLVER_MATRICES_FINISHED:                        ", &
    & Variable%SOLVER_MATRICES_FINISHED
  
  ! Variable%SOLVER_MAPPING
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_MAPPING)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_MAPPING_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, DAE_SOLVER_TYPE, EQUATIONS_SET_TYPE, NONLINEAR_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, EQUATIONS_TYPE, SOLVERS_TYPE, SOLVER_TYPE, INTERFACE_EQUATIONS_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, SOLVER_MATRIX_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_MATRICES_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), BOUNDARY_CONDITIONS_TYPE (CheckVariable2), CELLML_EQUATIONS_TYPE (CheckVariable3), SOLVERS_TYPE (CheckVariable4), SOLVER_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), SOLVER_MATRICES_TYPE (CheckVariable7), SOLVER_MATRIX_TYPE (CheckVariable8), LINEAR_SOLVER_TYPE (CheckVariable9), SOLVER_EQUATIONS_TYPE (CheckVariable10), OPTIMISER_SOLVER_TYPE (CheckVariable11), CONTROL_LOOP_TYPE (CheckVariable12), DYNAMIC_SOLVER_TYPE (CheckVariable13), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable14), GeometricTransformationSolverType (CheckVariable15), EIGENPROBLEM_SOLVER_TYPE (CheckVariable16), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_TYPE
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type INTERFACE_EQUATIONS_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_EQUATIONS_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable6
! - signature type SOLVER_MATRICES_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MATRIX_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable15
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16

    ! if variable was already followed
    Ptr1 => Variable%SOLVER_MAPPING
    IF (ASSOCIATED(Ptr1, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_MAPPING"
      CALL Print_SOLVER_MAPPING_TYPE(Variable% &
        & SOLVER_MAPPING, NullPtr0, CheckVariable0, NullPtr16, CheckVariable1, CheckVariable2, CheckVariable3, NullPtr21, &
        & CheckVariable4, CheckVariable5, NullPtr22, CheckVariable6, Variable2, CheckVariable8, CheckVariable9, &
        & CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, &
        & CheckVariable16, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MAPPING_TYPE), POINTER :: " // &
      & "SOLVER_MAPPING (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ROWS:                  ", &
    & Variable%NUMBER_OF_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_ROWS:           ", &
    & Variable%NUMBER_OF_GLOBAL_ROWS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "LIBRARY_TYPE:                    ", &
    & Variable%LIBRARY_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_MATRICES:              ", &
    & Variable%NUMBER_OF_MATRICES
  
  ! Variable%MATRICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%MATRICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%MATRICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_MATRIX_PTR_TYPE), ALLOCATABLE :: " // &
      & "MATRICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%MATRICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%MATRICES,1), MIN(LBOUND(Variable%MATRICES,1)+MaxArrayLength, UBOUND(Variable%MATRICES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_MATRIX_PTR_TYPE has the following CheckVariable types: SOLVER_MATRIX_TYPE, SOLVER_MATRICES_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVERS_TYPE, SOLVER_EQUATIONS_TYPE, 
! The type to handle in this routine is: SOLVER_MATRICES_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), BOUNDARY_CONDITIONS_TYPE (CheckVariable2), CELLML_EQUATIONS_TYPE (CheckVariable3), SOLVERS_TYPE (CheckVariable4), SOLVER_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), SOLVER_MATRICES_TYPE (CheckVariable7), SOLVER_MATRIX_TYPE (CheckVariable8), LINEAR_SOLVER_TYPE (CheckVariable9), SOLVER_EQUATIONS_TYPE (CheckVariable10), OPTIMISER_SOLVER_TYPE (CheckVariable11), CONTROL_LOOP_TYPE (CheckVariable12), DYNAMIC_SOLVER_TYPE (CheckVariable13), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable14), GeometricTransformationSolverType (CheckVariable15), EIGENPROBLEM_SOLVER_TYPE (CheckVariable16), 
! - signature type SOLVER_MATRIX_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_MATRICES_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable10
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MATRICES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_MATRIX_PTR_TYPE(Variable% &
          & MATRICES(I0), CheckVariable8, Variable2, CheckVariable5, CheckVariable6, CheckVariable4, CheckVariable10, &
          & Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_MATRIX_PTR_TYPE), ALLOCATABLE :: " // &
      & "MATRICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "UPDATE_RESIDUAL:                                 ", &
    & Variable%UPDATE_RESIDUAL
  
  ! Variable%RESIDUAL
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RESIDUAL)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "RESIDUAL " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: SOLVER_MATRICES_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), BOUNDARY_CONDITIONS_TYPE (CheckVariable2), CELLML_EQUATIONS_TYPE (CheckVariable3), SOLVERS_TYPE (CheckVariable4), SOLVER_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), SOLVER_MATRICES_TYPE (CheckVariable7), SOLVER_MATRIX_TYPE (CheckVariable8), LINEAR_SOLVER_TYPE (CheckVariable9), SOLVER_EQUATIONS_TYPE (CheckVariable10), OPTIMISER_SOLVER_TYPE (CheckVariable11), CONTROL_LOOP_TYPE (CheckVariable12), DYNAMIC_SOLVER_TYPE (CheckVariable13), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable14), GeometricTransformationSolverType (CheckVariable15), EIGENPROBLEM_SOLVER_TYPE (CheckVariable16), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RESIDUAL"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%RESIDUAL, NullPtr23, NullPtr24, NullPtr25, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "RESIDUAL (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "UPDATE_RHS_VECTOR:                               ", &
    & Variable%UPDATE_RHS_VECTOR
  
  ! Variable%RHS_VECTOR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RHS_VECTOR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "RHS_VECTOR " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: SOLVER_MATRICES_TYPE (Variable)
! Available CheckVariables are: DAE_SOLVER_TYPE (CheckVariable0), NONLINEAR_SOLVER_TYPE (CheckVariable1), BOUNDARY_CONDITIONS_TYPE (CheckVariable2), CELLML_EQUATIONS_TYPE (CheckVariable3), SOLVERS_TYPE (CheckVariable4), SOLVER_TYPE (CheckVariable5), SOLVER_MAPPING_TYPE (CheckVariable6), SOLVER_MATRICES_TYPE (CheckVariable7), SOLVER_MATRIX_TYPE (CheckVariable8), LINEAR_SOLVER_TYPE (CheckVariable9), SOLVER_EQUATIONS_TYPE (CheckVariable10), OPTIMISER_SOLVER_TYPE (CheckVariable11), CONTROL_LOOP_TYPE (CheckVariable12), DYNAMIC_SOLVER_TYPE (CheckVariable13), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable14), GeometricTransformationSolverType (CheckVariable15), EIGENPROBLEM_SOLVER_TYPE (CheckVariable16), 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RHS_VECTOR"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%RHS_VECTOR, NullPtr23, NullPtr24, NullPtr25, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "RHS_VECTOR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_SOLVER_MATRICES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_TO_SOLVER_MAPS_PTR_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_TO_SOLVER_MAPS_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(INTERFACE_TO_SOLVER_MAPS_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TO_SOLVER_MAPS_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TO_SOLVER_MAPS_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: INTERFACE_TO_SOLVER_MAPS_PTR_TYPE (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_INTERFACE_TO_SOLVER_MAPS_TYPE(Variable%PTR, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TO_SOLVER_MAPS_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_TO_SOLVER_MAPS_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_MAPPING_VARIABLE_TYPE(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_MAPPING_VARIABLE_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr1
  TYPE(MESHES_TYPE), POINTER :: NullPtr2
  TYPE(FIELDS_TYPE), POINTER :: NullPtr3
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr4
  TYPE(REGION_PTR_TYPE), POINTER :: NullPtr5
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr6
  TYPE(GENERATED_MESHES_TYPE), POINTER :: NullPtr7
  TYPE(CELLML_TYPE), POINTER :: NullPtr8
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr9
  TYPE(FIELD_TYPE), POINTER :: NullPtr10
  TYPE(INTERFACES_TYPE), POINTER :: NullPtr11
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr12
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: NullPtr13
  TYPE(NODES_TYPE), POINTER :: NullPtr14
  TYPE(EQUATIONS_SETS_TYPE), POINTER :: NullPtr15
  TYPE(REGION_TYPE), POINTER :: NullPtr16
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr17


  TYPE(SOLVER_MAPPING_VARIABLE_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)
  Nullify(NullPtr14)
  Nullify(NullPtr15)
  Nullify(NullPtr16)
  Nullify(NullPtr17)

  
  ! Variable%VARIABLE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%VARIABLE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE " // &
      & "(associated): " 
  
! Signature of Print_FIELD_VARIABLE_TYPE has the following CheckVariable types: DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, MESHES_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, REGION_PTR_TYPE, FIELD_PTR_TYPE, GENERATED_MESHES_TYPE, CELLML_TYPE, FIELD_VARIABLE_TYPE, FIELD_TYPE, INTERFACES_TYPE, INTERFACE_TYPE, CELLML_ENVIRONMENTS_TYPE, NODES_TYPE, EQUATIONS_SETS_TYPE, REGION_TYPE, DATA_POINTS_TYPE, 
! The type to handle in this routine is: SOLVER_MAPPING_VARIABLE_TYPE (Variable)
! Available CheckVariables are: 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type REGION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type REGION_PTR_TYPE
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESHES_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESHES_TYPE
! - signature type CELLML_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_TYPE
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type INTERFACES_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACES_TYPE
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type CELLML_ENVIRONMENTS_TYPE
!   is not available in passing variables, use NullPtr of type CELLML_ENVIRONMENTS_TYPE
! - signature type NODES_TYPE
!   is not available in passing variables, use NullPtr of type NODES_TYPE
! - signature type EQUATIONS_SETS_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SETS_TYPE
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"VARIABLE"
      CALL Print_FIELD_VARIABLE_TYPE(Variable% &
        & VARIABLE, NullPtr0, NullPtr1, NullPtr2, NullPtr3, NullPtr4, NullPtr5, NullPtr6, NullPtr7, NullPtr8, NullPtr9, &
        & NullPtr10, NullPtr11, NullPtr12, NullPtr13, NullPtr14, NullPtr15, NullPtr16, NullPtr17, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FIELD_VARIABLE_TYPE), POINTER :: " // &
      & "VARIABLE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "VARIABLE_TYPE:                   ", &
    & Variable%VARIABLE_TYPE
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_EQUATIONS:             ", &
    & Variable%NUMBER_OF_EQUATIONS
  
  ! Variable%EQUATION_TYPES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATION_TYPES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATION_TYPES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATION_TYPES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATION_TYPES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATION_TYPES,1), MIN(LBOUND(Variable%EQUATION_TYPES,1)+MaxArrayLength, UBOUND(Variable% &
      & EQUATION_TYPES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATION_TYPES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATION_TYPES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%EQUATION_INDICES(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%EQUATION_INDICES)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%EQUATION_INDICES),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATION_INDICES(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%EQUATION_INDICES, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%EQUATION_INDICES,1), MIN(LBOUND(Variable%EQUATION_INDICES,1)+MaxArrayLength, UBOUND(Variable% &
      & EQUATION_INDICES,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%EQUATION_INDICES(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "EQUATION_INDICES(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_SOLVER_MAPPING_VARIABLE_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DECOMPOSITION_ELEMENTS_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, &
  & CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, &
  & CheckVariable10, CheckVariable11, Depth, MaxDepth, MaxArrayLength)
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(DecompositionDataPointsType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITION_FACES_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(DECOMPOSITION_LINES_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable11

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(MESHES_TYPE), POINTER :: NullPtr0
  TYPE(MESH_PTR_TYPE), POINTER :: NullPtr1
  TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: NullPtr2
  TYPE(FIELD_PTR_TYPE), POINTER :: NullPtr3
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr4
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr5
  TYPE(INTERFACE_TYPE), POINTER :: NullPtr6
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr7
  TYPE(FIELDS_TYPE), POINTER :: NullPtr8
  TYPE(DATA_POINTS_TYPE), POINTER :: NullPtr9
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr10
  TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: NullPtr11
  TYPE(REGION_TYPE), POINTER :: NullPtr12

  TYPE(DECOMPOSITION_TYPE), POINTER :: Ptr0

  TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable0)) THEN
    Variable2 => CheckVariable0
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)

  
  ! Variable%DECOMPOSITION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DECOMPOSITION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "DECOMPOSITION " // &
      & "(associated): " 
  
! Signature of Print_DECOMPOSITION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, DOMAIN_MAPPINGS_TYPE, DECOMPOSITION_TOPOLOGY_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, DECOMPOSITION_FACES_TYPE, DECOMPOSITION_ELEMENTS_TYPE, MESH_TYPE, DECOMPOSITION_PTR_TYPE, FIELDS_TYPE, DECOMPOSITIONS_TYPE, DOMAIN_PTR_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DOMAIN_TOPOLOGY_TYPE, DECOMPOSITION_TYPE, DecompositionDataPointsType, DECOMPOSITION_LINES_TYPE, REGION_TYPE, 
! The type to handle in this routine is: DECOMPOSITION_ELEMENTS_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DecompositionDataPointsType (CheckVariable6), DECOMPOSITION_FACES_TYPE (CheckVariable7), DECOMPOSITION_LINES_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITIONS_TYPE (CheckVariable10), DOMAIN_PTR_TYPE (CheckVariable11), 
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type MESH_PTR_TYPE
!   is not available in passing variables, use NullPtr of type MESH_PTR_TYPE
! - signature type DOMAIN_MAPPINGS_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_MAPPINGS_TYPE
! - signature type DECOMPOSITION_TOPOLOGY_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type FIELD_PTR_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_PTR_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_TYPE
! - signature type DOMAIN_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type DECOMPOSITION_FACES_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type DECOMPOSITION_ELEMENTS_TYPE
!   is type of this print routine, use Variable2
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type DECOMPOSITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type DOMAIN_PTR_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type DATA_POINTS_TYPE
!   is not available in passing variables, use NullPtr of type DATA_POINTS_TYPE
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type DOMAIN_TOPOLOGY_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TOPOLOGY_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable4
! - signature type DecompositionDataPointsType
!   matches available passing type, use it as CheckVariable6
! - signature type DECOMPOSITION_LINES_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DECOMPOSITION
    IF (ASSOCIATED(Ptr0, CheckVariable4)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DECOMPOSITION"
      CALL Print_DECOMPOSITION_TYPE(Variable% &
        & DECOMPOSITION, NullPtr0, NullPtr1, NullPtr2, CheckVariable5, NullPtr3, NullPtr4, CheckVariable9, NullPtr5, &
        & NullPtr6, CheckVariable3, NullPtr7, CheckVariable7, Variable2, CheckVariable1, CheckVariable2, NullPtr8, &
        & CheckVariable10, CheckVariable11, NullPtr9, NullPtr10, NullPtr11, CheckVariable4, CheckVariable6, CheckVariable8, &
        & NullPtr12, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_TYPE), POINTER :: " // &
      & "DECOMPOSITION (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ELEMENTS:              ", &
    & Variable%NUMBER_OF_ELEMENTS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "TOTAL_NUMBER_OF_ELEMENTS:        ", &
    & Variable%TOTAL_NUMBER_OF_ELEMENTS
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_GLOBAL_ELEMENTS:       ", &
    & Variable%NUMBER_OF_GLOBAL_ELEMENTS
  
  ! Variable%ELEMENTS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%ELEMENTS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DECOMPOSITION_ELEMENT_TYPE), POINTER :: " // &
      & "ELEMENTS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%ELEMENTS,1), "): "
  
    DO I0 = LBOUND(Variable%ELEMENTS,1), MIN(LBOUND(Variable%ELEMENTS,1)+MaxArrayLength, UBOUND(Variable%ELEMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_DECOMPOSITION_ELEMENT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: DECOMPOSITION_ELEMENTS_TYPE (Variable)
! Available CheckVariables are: DECOMPOSITION_ELEMENTS_TYPE (CheckVariable0), MESH_TYPE (CheckVariable1), DECOMPOSITION_PTR_TYPE (CheckVariable2), DOMAIN_TYPE (CheckVariable3), DECOMPOSITION_TYPE (CheckVariable4), DECOMPOSITION_TOPOLOGY_TYPE (CheckVariable5), DecompositionDataPointsType (CheckVariable6), DECOMPOSITION_FACES_TYPE (CheckVariable7), DECOMPOSITION_LINES_TYPE (CheckVariable8), FIELD_TYPE (CheckVariable9), DECOMPOSITIONS_TYPE (CheckVariable10), DOMAIN_PTR_TYPE (CheckVariable11), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ELEMENTS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_DECOMPOSITION_ELEMENT_TYPE(Variable%ELEMENTS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DECOMPOSITION_ELEMENT_TYPE), POINTER :: " // &
      & "ELEMENTS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%ELEMENTS_TREE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ELEMENTS_TREE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(TREE_TYPE), POINTER :: " // &
      & "ELEMENTS_TREE " // &
      & "(associated): " 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(TREE_TYPE) :: Variable%" // &
        & "ELEMENTS_TREE (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(TREE_TYPE), POINTER :: " // &
      & "ELEMENTS_TREE (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DECOMPOSITION_ELEMENTS_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_INTERFACE_MATRIX_PTR_TYPE(Variable, CheckVariable0, Depth, MaxDepth, MaxArrayLength)
  TYPE(INTERFACE_MATRIX_PTR_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(INTERFACE_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable0

  ! iterator variables

  ! null pointers


  TYPE(INTERFACE_MATRIX_PTR_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%PTR
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%PTR)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_MATRIX_TYPE), POINTER :: " // &
      & "PTR " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_MATRIX_TYPE has the following CheckVariable types: INTERFACE_MATRICES_TYPE, 
! The type to handle in this routine is: INTERFACE_MATRIX_PTR_TYPE (Variable)
! Available CheckVariables are: INTERFACE_MATRICES_TYPE (CheckVariable0), 
! - signature type INTERFACE_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable0
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"PTR"
      CALL Print_INTERFACE_MATRIX_TYPE(Variable%PTR, CheckVariable0, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_MATRIX_TYPE), POINTER :: " // &
      & "PTR (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_INTERFACE_MATRIX_PTR_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_InterfaceCoupledElementsType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(InterfaceCoupledElementsType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers


  TYPE(InterfaceCoupledElementsType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfCoupledElements:         ", &
    & Variable%numberOfCoupledElements
  
  ! Variable%elementNumbers(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%elementNumbers)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%elementNumbers),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "elementNumbers(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%elementNumbers, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%elementNumbers,1), MIN(LBOUND(Variable%elementNumbers,1)+MaxArrayLength, UBOUND(Variable% &
      & elementNumbers,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%elementNumbers(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "elementNumbers(:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_InterfaceCoupledElementsType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_NodalMatrixType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(NodalMatrixType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0, I1
  CHARACTER(LEN=30) :: I0_STR, I1_STR

  ! null pointers


  TYPE(NodalMatrixType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "equationsMatrixNumber:           ", &
    & Variable%equationsMatrixNumber
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "structureType:                   ", &
    & Variable%structureType
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfRows:                    ", &
    & Variable%numberOfRows
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "numberOfColumns:                 ", &
    & Variable%numberOfColumns
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "maxNumberOfRows:                 ", &
    & Variable%maxNumberOfRows
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "maxNumberOfColumns:              ", &
    & Variable%maxNumberOfColumns
  
  ! Variable%rowDofs(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%rowDofs)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%rowDofs),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "rowDofs(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%rowDofs, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%rowDofs,1), MIN(LBOUND(Variable%rowDofs,1)+MaxArrayLength, UBOUND(Variable%rowDofs,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%rowDofs(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "rowDofs(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%columnDofs(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%columnDofs)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%columnDofs),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "columnDofs(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%columnDofs, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%columnDofs,1), MIN(LBOUND(Variable%columnDofs,1)+MaxArrayLength, UBOUND(Variable%columnDofs,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%columnDofs(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "columnDofs(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%matrix(:,:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%matrix)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%matrix),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "REAL(DP), ALLOCATABLE :: " // &
      & "matrix(:,:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%matrix, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%matrix,1), MIN(LBOUND(Variable%matrix,1)+MaxArrayLength, UBOUND(Variable%matrix,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent),"("//TRIM(ADJUSTL(I0_STR))//",*): "
      DO I1 = LBOUND(Variable%matrix,2), MIN(LBOUND(Variable%matrix,2)+MaxArrayLength, UBOUND(Variable%matrix,2))
        WRITE(I1_STR,"(I4)") I1 

        PRINT*, TRIM(PrintIndent), Variable%matrix(I0,I1)

      ENDDO  ! I1
    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"REAL(DP), ALLOCATABLE :: " // &
      & "matrix(:,:) (not allocated)"
  ENDIF ! IF (IsAllocated)

  
END SUBROUTINE Print_NodalMatrixType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_DAE_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
  & CheckVariable32, CheckVariable33, CheckVariable34, CheckVariable35, CheckVariable36, Depth, MaxDepth, MaxArrayLength)
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable31
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable32
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable33
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable34
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable35
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable36

  ! iterator variables

  ! null pointers
  TYPE(FIELD_TYPE), POINTER :: NullPtr0
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(PROBLEMS_TYPE), POINTER :: NullPtr2
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: NullPtr5
  TYPE(PROBLEM_PTR_TYPE), POINTER :: NullPtr6

  TYPE(SOLVER_TYPE), POINTER :: Ptr0
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: Ptr1
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: Ptr2
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: Ptr3
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: Ptr4
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: Ptr5
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: Ptr6
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: Ptr7

  TYPE(DAE_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable28)) THEN
    Variable2 => CheckVariable28
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)

  
  ! Variable%SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), SOLVER_EQUATIONS_TYPE (CheckVariable24), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable25), SOLVER_MATRICES_TYPE (CheckVariable26), HISTORY_TYPE (CheckVariable27), DAE_SOLVER_TYPE (CheckVariable28), SOLVERS_TYPE (CheckVariable29), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable30), SOLVER_TYPE (CheckVariable31), SOLVER_MAPPING_TYPE (CheckVariable32), EULER_DAE_SOLVER_TYPE (CheckVariable33), LINEAR_SOLVER_TYPE (CheckVariable34), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable35), PROBLEM_TYPE (CheckVariable36), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type PROBLEMS_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEMS_TYPE
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable31
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type PROBLEM_PTR_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_PTR_TYPE
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable36

    ! if variable was already followed
    Ptr0 => Variable%SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable31)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & SOLVER, CheckVariable0, CheckVariable1, NullPtr0, CheckVariable2, CheckVariable3, CheckVariable4, NullPtr1, &
        & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable18, CheckVariable19, &
        & CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, NullPtr2, CheckVariable24, NullPtr3, &
        & CheckVariable25, CheckVariable26, CheckVariable27, Variable2, CheckVariable29, CheckVariable30, CheckVariable31, &
        & NullPtr4, NullPtr5, CheckVariable32, CheckVariable33, NullPtr6, CheckVariable34, CheckVariable36, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%DAE_TYPE == 0) THEN
    Comment = "SOLVER_DAE_DIFFERENTIAL_ONLY " // & 
      & "!Differential equations only"
  ENDIF
  IF (Variable%DAE_TYPE == 1) THEN
    Comment = "SOLVER_DAE_INDEX_1 " // & 
      & "!Index 1 differential-algebraic equation"
  ENDIF
  IF (Variable%DAE_TYPE == 2) THEN
    Comment = "SOLVER_DAE_INDEX_2 " // & 
      & "!Index 2 differential-algebraic equation"
  ENDIF
  IF (Variable%DAE_TYPE == 3) THEN
    Comment = "SOLVER_DAE_INDEX_3 " // & 
      & "!Index 3 differential-algebraic equation"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DAE_TYPE:                        ", &
    & Variable%DAE_TYPE, " ", TRIM(Comment)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "DAE_SOLVE_TYPE:                  ", &
    & Variable%DAE_SOLVE_TYPE
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "START_TIME:                  ", &
    & Variable%START_TIME
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "END_TIME:                    ", &
    & Variable%END_TIME
  PRINT*, TRIM(PrintIndent),"REAL(DP) :: " // &
    & "INITIAL_STEP:                ", &
    & Variable%INITIAL_STEP
  
  ! Variable%EULER_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EULER_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "EULER_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_EULER_DAE_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, EXTERNAL_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), SOLVER_EQUATIONS_TYPE (CheckVariable24), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable25), SOLVER_MATRICES_TYPE (CheckVariable26), HISTORY_TYPE (CheckVariable27), DAE_SOLVER_TYPE (CheckVariable28), SOLVERS_TYPE (CheckVariable29), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable30), SOLVER_TYPE (CheckVariable31), SOLVER_MAPPING_TYPE (CheckVariable32), EULER_DAE_SOLVER_TYPE (CheckVariable33), LINEAR_SOLVER_TYPE (CheckVariable34), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable35), PROBLEM_TYPE (CheckVariable36), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable35
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable33
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr1 => Variable%EULER_SOLVER
    IF (ASSOCIATED(Ptr1, CheckVariable33)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EULER_SOLVER"
      CALL Print_EULER_DAE_SOLVER_TYPE(Variable% &
        & EULER_SOLVER, CheckVariable0, CheckVariable17, CheckVariable2, CheckVariable6, CheckVariable10, CheckVariable12, &
        & CheckVariable13, CheckVariable22, CheckVariable15, CheckVariable16, CheckVariable18, CheckVariable19, &
        & CheckVariable21, CheckVariable23, CheckVariable24, Variable2, CheckVariable29, CheckVariable35, CheckVariable31, &
        & CheckVariable33, CheckVariable34, CheckVariable30, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "EULER_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CRANK_NICOLSON_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CRANK_NICOLSON_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: " // &
      & "CRANK_NICOLSON_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_CRANK_NICOLSON_DAE_SOLVER_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, GeometricTransformationSolverType, EXTERNAL_DAE_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, BDF_DAE_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), SOLVER_EQUATIONS_TYPE (CheckVariable24), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable25), SOLVER_MATRICES_TYPE (CheckVariable26), HISTORY_TYPE (CheckVariable27), DAE_SOLVER_TYPE (CheckVariable28), SOLVERS_TYPE (CheckVariable29), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable30), SOLVER_TYPE (CheckVariable31), SOLVER_MAPPING_TYPE (CheckVariable32), EULER_DAE_SOLVER_TYPE (CheckVariable33), LINEAR_SOLVER_TYPE (CheckVariable34), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable35), PROBLEM_TYPE (CheckVariable36), 
! - signature type DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable23
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr2 => Variable%CRANK_NICOLSON_SOLVER
    IF (ASSOCIATED(Ptr2, CheckVariable23)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CRANK_NICOLSON_SOLVER"
      CALL Print_CRANK_NICOLSON_DAE_SOLVER_TYPE(Variable% &
        & CRANK_NICOLSON_SOLVER, Variable2, CheckVariable6, CheckVariable21, CheckVariable29, CheckVariable30, &
        & CheckVariable31, CheckVariable18, CheckVariable10, CheckVariable33, CheckVariable23, CheckVariable34, &
        & CheckVariable24, CheckVariable12, CheckVariable22, CheckVariable15, CheckVariable16, CheckVariable0, &
        & CheckVariable19, CheckVariable2, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: " // &
      & "CRANK_NICOLSON_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%RUNGE_KUTTA_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RUNGE_KUTTA_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: " // &
      & "RUNGE_KUTTA_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_RUNGE_KUTTA_DAE_SOLVER_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, GeometricTransformationSolverType, EXTERNAL_DAE_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, BDF_DAE_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), SOLVER_EQUATIONS_TYPE (CheckVariable24), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable25), SOLVER_MATRICES_TYPE (CheckVariable26), HISTORY_TYPE (CheckVariable27), DAE_SOLVER_TYPE (CheckVariable28), SOLVERS_TYPE (CheckVariable29), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable30), SOLVER_TYPE (CheckVariable31), SOLVER_MAPPING_TYPE (CheckVariable32), EULER_DAE_SOLVER_TYPE (CheckVariable33), LINEAR_SOLVER_TYPE (CheckVariable34), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable35), PROBLEM_TYPE (CheckVariable36), 
! - signature type DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable11

    ! if variable was already followed
    Ptr3 => Variable%RUNGE_KUTTA_SOLVER
    IF (ASSOCIATED(Ptr3, CheckVariable11)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RUNGE_KUTTA_SOLVER"
      CALL Print_RUNGE_KUTTA_DAE_SOLVER_TYPE(Variable% &
        & RUNGE_KUTTA_SOLVER, Variable2, CheckVariable6, CheckVariable21, CheckVariable29, CheckVariable30, &
        & CheckVariable31, CheckVariable18, CheckVariable10, CheckVariable33, CheckVariable23, CheckVariable34, &
        & CheckVariable24, CheckVariable12, CheckVariable22, CheckVariable15, CheckVariable16, CheckVariable0, &
        & CheckVariable19, CheckVariable2, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: " // &
      & "RUNGE_KUTTA_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%ADAMS_MOULTON_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ADAMS_MOULTON_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: " // &
      & "ADAMS_MOULTON_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_ADAMS_MOULTON_DAE_SOLVER_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, GeometricTransformationSolverType, EXTERNAL_DAE_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, BDF_DAE_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), SOLVER_EQUATIONS_TYPE (CheckVariable24), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable25), SOLVER_MATRICES_TYPE (CheckVariable26), HISTORY_TYPE (CheckVariable27), DAE_SOLVER_TYPE (CheckVariable28), SOLVERS_TYPE (CheckVariable29), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable30), SOLVER_TYPE (CheckVariable31), SOLVER_MAPPING_TYPE (CheckVariable32), EULER_DAE_SOLVER_TYPE (CheckVariable33), LINEAR_SOLVER_TYPE (CheckVariable34), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable35), PROBLEM_TYPE (CheckVariable36), 
! - signature type DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable30
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr4 => Variable%ADAMS_MOULTON_SOLVER
    IF (ASSOCIATED(Ptr4, CheckVariable30)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ADAMS_MOULTON_SOLVER"
      CALL Print_ADAMS_MOULTON_DAE_SOLVER_TYPE(Variable% &
        & ADAMS_MOULTON_SOLVER, Variable2, CheckVariable6, CheckVariable21, CheckVariable29, CheckVariable30, &
        & CheckVariable31, CheckVariable18, CheckVariable10, CheckVariable33, CheckVariable23, CheckVariable34, &
        & CheckVariable24, CheckVariable12, CheckVariable22, CheckVariable15, CheckVariable16, CheckVariable0, &
        & CheckVariable19, CheckVariable2, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: " // &
      & "ADAMS_MOULTON_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%BDF_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%BDF_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: " // &
      & "BDF_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_BDF_DAE_SOLVER_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, GeometricTransformationSolverType, EXTERNAL_DAE_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, BDF_DAE_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), SOLVER_EQUATIONS_TYPE (CheckVariable24), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable25), SOLVER_MATRICES_TYPE (CheckVariable26), HISTORY_TYPE (CheckVariable27), DAE_SOLVER_TYPE (CheckVariable28), SOLVERS_TYPE (CheckVariable29), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable30), SOLVER_TYPE (CheckVariable31), SOLVER_MAPPING_TYPE (CheckVariable32), EULER_DAE_SOLVER_TYPE (CheckVariable33), LINEAR_SOLVER_TYPE (CheckVariable34), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable35), PROBLEM_TYPE (CheckVariable36), 
! - signature type DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable0
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr5 => Variable%BDF_SOLVER
    IF (ASSOCIATED(Ptr5, CheckVariable0)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BDF_SOLVER"
      CALL Print_BDF_DAE_SOLVER_TYPE(Variable% &
        & BDF_SOLVER, Variable2, CheckVariable6, CheckVariable21, CheckVariable29, CheckVariable30, CheckVariable31, &
        & CheckVariable18, CheckVariable10, CheckVariable33, CheckVariable23, CheckVariable34, CheckVariable24, &
        & CheckVariable12, CheckVariable22, CheckVariable15, CheckVariable16, CheckVariable0, CheckVariable19, &
        & CheckVariable2, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: " // &
      & "BDF_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%RUSH_LARSON_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%RUSH_LARSON_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: " // &
      & "RUSH_LARSON_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_RUSH_LARSON_DAE_SOLVER_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, GeometricTransformationSolverType, EXTERNAL_DAE_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, BDF_DAE_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), SOLVER_EQUATIONS_TYPE (CheckVariable24), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable25), SOLVER_MATRICES_TYPE (CheckVariable26), HISTORY_TYPE (CheckVariable27), DAE_SOLVER_TYPE (CheckVariable28), SOLVERS_TYPE (CheckVariable29), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable30), SOLVER_TYPE (CheckVariable31), SOLVER_MAPPING_TYPE (CheckVariable32), EULER_DAE_SOLVER_TYPE (CheckVariable33), LINEAR_SOLVER_TYPE (CheckVariable34), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable35), PROBLEM_TYPE (CheckVariable36), 
! - signature type DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable2
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr6 => Variable%RUSH_LARSON_SOLVER
    IF (ASSOCIATED(Ptr6, CheckVariable2)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"RUSH_LARSON_SOLVER"
      CALL Print_RUSH_LARSON_DAE_SOLVER_TYPE(Variable% &
        & RUSH_LARSON_SOLVER, Variable2, CheckVariable6, CheckVariable21, CheckVariable29, CheckVariable30, &
        & CheckVariable31, CheckVariable18, CheckVariable10, CheckVariable33, CheckVariable23, CheckVariable34, &
        & CheckVariable24, CheckVariable12, CheckVariable22, CheckVariable15, CheckVariable16, CheckVariable0, &
        & CheckVariable19, CheckVariable2, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: " // &
      & "RUSH_LARSON_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%EXTERNAL_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EXTERNAL_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: " // &
      & "EXTERNAL_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_EXTERNAL_DAE_SOLVER_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, GeometricTransformationSolverType, EXTERNAL_DAE_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, BDF_DAE_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable3), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable4), QUASI_NEWTON_SOLVER_TYPE (CheckVariable5), NONLINEAR_SOLVER_TYPE (CheckVariable6), NEWTON_SOLVER_TYPE (CheckVariable7), CONTROL_LOOP_FIXED_TYPE (CheckVariable8), CONTROL_LOOP_TIME_TYPE (CheckVariable9), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable10), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable11), OPTIMISER_SOLVER_TYPE (CheckVariable12), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable13), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable14), DYNAMIC_SOLVER_TYPE (CheckVariable15), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable16), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), SOLVER_EQUATIONS_TYPE (CheckVariable24), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable25), SOLVER_MATRICES_TYPE (CheckVariable26), HISTORY_TYPE (CheckVariable27), DAE_SOLVER_TYPE (CheckVariable28), SOLVERS_TYPE (CheckVariable29), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable30), SOLVER_TYPE (CheckVariable31), SOLVER_MAPPING_TYPE (CheckVariable32), EULER_DAE_SOLVER_TYPE (CheckVariable33), LINEAR_SOLVER_TYPE (CheckVariable34), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable35), PROBLEM_TYPE (CheckVariable36), 
! - signature type DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable10
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable33
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11

    ! if variable was already followed
    Ptr7 => Variable%EXTERNAL_SOLVER
    IF (ASSOCIATED(Ptr7, CheckVariable10)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EXTERNAL_SOLVER"
      CALL Print_EXTERNAL_DAE_SOLVER_TYPE(Variable% &
        & EXTERNAL_SOLVER, Variable2, CheckVariable6, CheckVariable21, CheckVariable29, CheckVariable30, CheckVariable31, &
        & CheckVariable18, CheckVariable10, CheckVariable33, CheckVariable23, CheckVariable34, CheckVariable24, &
        & CheckVariable12, CheckVariable22, CheckVariable15, CheckVariable16, CheckVariable0, CheckVariable19, &
        & CheckVariable2, CheckVariable11, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: " // &
      & "EXTERNAL_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_DAE_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BoundaryConditionsDofConstraintPtrType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(BoundaryConditionsDofConstraintPtrType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables

  ! null pointers


  TYPE(BoundaryConditionsDofConstraintPtrType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable


  
  ! Variable%ptr
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ptr)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BoundaryConditionsDofConstraintType), POINTER :: " // &
      & "ptr " // &
      & "(associated): " 
  
! Signature of Print_BoundaryConditionsDofConstraintType has the following CheckVariable types: 
! The type to handle in this routine is: BoundaryConditionsDofConstraintPtrType (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ptr"
      CALL Print_BoundaryConditionsDofConstraintType(Variable%ptr, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BoundaryConditionsDofConstraintType), POINTER :: " // &
      & "ptr (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_BoundaryConditionsDofConstraintPtrType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
  & CheckVariable32, CheckVariable33, CheckVariable34, CheckVariable35, CheckVariable36, CheckVariable37, CheckVariable38, &
  & CheckVariable39, CheckVariable40, Depth, MaxDepth, MaxArrayLength)
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: CheckVariable27
  TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: CheckVariable28
  TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: CheckVariable29
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable30
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable31
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable32
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable33
  TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable34
  TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable35
  TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: CheckVariable36
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable37
  TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable38
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable39
  TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: CheckVariable40

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr0
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr3
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr4

  TYPE(SOLVERS_TYPE), POINTER :: Ptr0
  TYPE(SOLVER_TYPE), POINTER :: Ptr1
  TYPE(LINEAR_SOLVER_TYPE), POINTER :: Ptr2
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: Ptr3
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: Ptr4
  TYPE(DAE_SOLVER_TYPE), POINTER :: Ptr5
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: Ptr6
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: Ptr7
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: Ptr8
  TYPE(GeometricTransformationSolverType), POINTER :: Ptr9
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: Ptr10
  TYPE(CELLML_EQUATIONS_TYPE), POINTER :: Ptr11

  TYPE(SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable33)) THEN
    Variable2 => CheckVariable33
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)

  
  ! Variable%SOLVERS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVERS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVERS_TYPE), POINTER :: " // &
      & "SOLVERS " // &
      & "(associated): " 
  
! Signature of Print_SOLVERS_TYPE has the following CheckVariable types: CONTROL_LOOP_WHILE_TYPE, QUASI_NEWTON_SOLVER_TYPE, PROBLEMS_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable31
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable38
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40

    ! if variable was already followed
    Ptr0 => Variable%SOLVERS
    IF (ASSOCIATED(Ptr0, CheckVariable31)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVERS"
      CALL Print_SOLVERS_TYPE(Variable% &
        & SOLVERS, CheckVariable1, CheckVariable7, CheckVariable24, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable14, CheckVariable22, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, &
        & CheckVariable21, CheckVariable15, CheckVariable8, CheckVariable25, CheckVariable27, CheckVariable29, &
        & CheckVariable30, CheckVariable31, Variable2, CheckVariable38, CheckVariable39, CheckVariable40, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVERS_TYPE), POINTER :: " // &
      & "SOLVERS (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "GLOBAL_NUMBER:                   ", &
    & Variable%GLOBAL_NUMBER
  
  ! Variable%LINKING_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINKING_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_TYPE), POINTER :: " // &
      & "LINKING_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, PROBLEMS_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable35
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable38
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40

    ! if variable was already followed
    Ptr1 => Variable%LINKING_SOLVER
    IF (ASSOCIATED(Ptr1, CheckVariable33)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINKING_SOLVER"
      CALL Print_SOLVER_TYPE(Variable% &
        & LINKING_SOLVER, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
        & CheckVariable24, CheckVariable25, CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, &
        & CheckVariable30, CheckVariable31, CheckVariable32, Variable2, CheckVariable34, CheckVariable35, CheckVariable36, &
        & CheckVariable37, CheckVariable38, CheckVariable39, CheckVariable40, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_TYPE), POINTER :: " // &
      & "LINKING_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_LINKED_SOLVERS:        ", &
    & Variable%NUMBER_OF_LINKED_SOLVERS
  
  ! Variable%LINKED_SOLVERS(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LINKED_SOLVERS)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LINKED_SOLVERS),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_PTR_TYPE), ALLOCATABLE :: " // &
      & "LINKED_SOLVERS(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LINKED_SOLVERS, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%LINKED_SOLVERS,1), MIN(LBOUND(Variable%LINKED_SOLVERS,1)+MaxArrayLength, UBOUND(Variable% &
      & LINKED_SOLVERS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_PTR_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, PROBLEMS_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable38
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINKED_SOLVERS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_PTR_TYPE(Variable% &
          & LINKED_SOLVERS(I0), CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable5, &
          & CheckVariable7, CheckVariable24, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, &
          & CheckVariable13, CheckVariable14, CheckVariable22, CheckVariable16, CheckVariable17, CheckVariable18, &
          & CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable15, CheckVariable23, CheckVariable8, &
          & CheckVariable25, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
          & CheckVariable32, Variable2, CheckVariable36, CheckVariable37, CheckVariable38, CheckVariable39, &
          & CheckVariable40, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_PTR_TYPE), ALLOCATABLE :: " // &
      & "LINKED_SOLVERS(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%LINKED_SOLVER_TYPE_MAP(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%LINKED_SOLVER_TYPE_MAP)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%LINKED_SOLVER_TYPE_MAP),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_PTR_TYPE), ALLOCATABLE :: " // &
      & "LINKED_SOLVER_TYPE_MAP(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%LINKED_SOLVER_TYPE_MAP, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
  
    DO I0 = LBOUND(Variable%LINKED_SOLVER_TYPE_MAP,1), MIN(LBOUND(Variable% &
      & LINKED_SOLVER_TYPE_MAP,1)+MaxArrayLength, UBOUND(Variable%LINKED_SOLVER_TYPE_MAP,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_SOLVER_PTR_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, PROBLEMS_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_SIMPLE_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, PROBLEM_PTR_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type PROBLEMS_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type PROBLEM_PTR_TYPE
!   matches available passing type, use it as CheckVariable38
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINKED_SOLVER_TYPE_MAP("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_SOLVER_PTR_TYPE(Variable% &
          & LINKED_SOLVER_TYPE_MAP(I0), CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable5, &
          & CheckVariable7, CheckVariable24, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, &
          & CheckVariable13, CheckVariable14, CheckVariable22, CheckVariable16, CheckVariable17, CheckVariable18, &
          & CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable15, CheckVariable23, CheckVariable8, &
          & CheckVariable25, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
          & CheckVariable32, Variable2, CheckVariable36, CheckVariable37, CheckVariable38, CheckVariable39, &
          & CheckVariable40, Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_PTR_TYPE), ALLOCATABLE :: " // &
      & "LINKED_SOLVER_TYPE_MAP(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "SOLVER_FINISHED:                                 ", &
    & Variable%SOLVER_FINISHED
  Comment = ""
  IF (Variable%OUTPUT_TYPE == 0) THEN
    Comment = "SOLVER_NO_OUTPUT " // & 
      & "!No output from the solver routines"
  ENDIF
  IF (Variable%OUTPUT_TYPE == 1) THEN
    Comment = "SOLVER_PROGRESS_OUTPUT " // & 
      & "!Progress output from solver routines"
  ENDIF
  IF (Variable%OUTPUT_TYPE == 2) THEN
    Comment = "SOLVER_TIMING_OUTPUT " // & 
      & "!Timing output from the solver routines plus below"
  ENDIF
  IF (Variable%OUTPUT_TYPE == 3) THEN
    Comment = "SOLVER_SOLVER_OUTPUT " // & 
      & "!Solver specific output from the solver routines plus below"
  ENDIF
  IF (Variable%OUTPUT_TYPE == 4) THEN
    Comment = "SOLVER_MATRIX_OUTPUT " // & 
      & "!Solver matrices output from the solver routines plus below"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "OUTPUT_TYPE:                     ", &
    & Variable%OUTPUT_TYPE, " ", TRIM(Comment)
  Comment = ""
  IF (Variable%SOLVE_TYPE == 9) THEN
    Comment = "SOLVER_NUMBER_OF_SOLVER_TYPES " // & 
      & "!Number of different solver types possible"
  ENDIF
  IF (Variable%SOLVE_TYPE == 1) THEN
    Comment = "SOLVER_LINEAR_TYPE " // & 
      & "!A linear solver"
  ENDIF
  IF (Variable%SOLVE_TYPE == 2) THEN
    Comment = "SOLVER_NONLINEAR_TYPE " // & 
      & "!A nonlinear solver"
  ENDIF
  IF (Variable%SOLVE_TYPE == 3) THEN
    Comment = "SOLVER_DYNAMIC_TYPE " // & 
      & "!A dynamic solver"
  ENDIF
  IF (Variable%SOLVE_TYPE == 4) THEN
    Comment = "SOLVER_DAE_TYPE " // & 
      & "!A differential-algebraic equation solver"
  ENDIF
  IF (Variable%SOLVE_TYPE == 5) THEN
    Comment = "SOLVER_EIGENPROBLEM_TYPE " // & 
      & "!A eigenproblem solver"
  ENDIF
  IF (Variable%SOLVE_TYPE == 6) THEN
    Comment = "SOLVER_OPTIMISER_TYPE " // & 
      & "!An optimiser solver"
  ENDIF
  IF (Variable%SOLVE_TYPE == 7) THEN
    Comment = "SOLVER_CELLML_EVALUATOR_TYPE " // & 
      & "!A CellML evaluation solver"
  ENDIF
  IF (Variable%SOLVE_TYPE == 8) THEN
    Comment = "SOLVER_STATE_ITERATION_TYPE " // & 
      & "!An state iteration solver"
  ENDIF
  IF (Variable%SOLVE_TYPE == 9) THEN
    Comment = "SOLVER_GEOMETRIC_TRANSFORMATION_TYPE " // & 
      & "!An geometric transformation solver"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVE_TYPE:                      ", &
    & Variable%SOLVE_TYPE, " ", TRIM(Comment)
  
  ! Variable%LINEAR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%LINEAR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(LINEAR_SOLVER_TYPE), POINTER :: " // &
      & "LINEAR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_LINEAR_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable39
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40

    ! if variable was already followed
    Ptr2 => Variable%LINEAR_SOLVER
    IF (ASSOCIATED(Ptr2, CheckVariable39)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"LINEAR_SOLVER"
      CALL Print_LINEAR_SOLVER_TYPE(Variable% &
        & LINEAR_SOLVER, CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable7, &
        & CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, &
        & CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, &
        & CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable25, CheckVariable27, &
        & CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, CheckVariable32, Variable2, CheckVariable36, &
        & CheckVariable37, CheckVariable39, CheckVariable40, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(LINEAR_SOLVER_TYPE), POINTER :: " // &
      & "LINEAR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%NONLINEAR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%NONLINEAR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: " // &
      & "NONLINEAR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_NONLINEAR_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, NEWTON_LINESEARCH_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, NEWTON_TRUSTREGION_SOLVER_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, QUASI_NEWTON_LINESEARCH_SOLVER_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable8
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable35
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type NEWTON_TRUSTREGION_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type QUASI_NEWTON_LINESEARCH_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable34
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40

    ! if variable was already followed
    Ptr3 => Variable%NONLINEAR_SOLVER
    IF (ASSOCIATED(Ptr3, CheckVariable8)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"NONLINEAR_SOLVER"
      CALL Print_NONLINEAR_SOLVER_TYPE(Variable% &
        & NONLINEAR_SOLVER, CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable6, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, &
        & CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, &
        & CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable35, CheckVariable25, &
        & CheckVariable26, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
        & CheckVariable32, Variable2, CheckVariable34, CheckVariable23, CheckVariable36, CheckVariable37, CheckVariable39, &
        & CheckVariable40, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: " // &
      & "NONLINEAR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DYNAMIC_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DYNAMIC_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: " // &
      & "DYNAMIC_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_DYNAMIC_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40

    ! if variable was already followed
    Ptr4 => Variable%DYNAMIC_SOLVER
    IF (ASSOCIATED(Ptr4, CheckVariable16)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DYNAMIC_SOLVER"
      CALL Print_DYNAMIC_SOLVER_TYPE(Variable% &
        & DYNAMIC_SOLVER, CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable7, &
        & CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, &
        & CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, &
        & CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable25, CheckVariable27, &
        & CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, CheckVariable32, Variable2, CheckVariable36, &
        & CheckVariable37, CheckVariable39, CheckVariable40, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: " // &
      & "DYNAMIC_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%DAE_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DAE_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_DAE_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type BACKWARD_EULER_DAE_SOLVER_TYPE
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type FORWARD_EULER_DAE_SOLVER_TYPE
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type IMPROVED_EULER_DAE_SOLVER_TYPE
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40

    ! if variable was already followed
    Ptr5 => Variable%DAE_SOLVER
    IF (ASSOCIATED(Ptr5, CheckVariable30)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DAE_SOLVER"
      CALL Print_DAE_SOLVER_TYPE(Variable% &
        & DAE_SOLVER, CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable7, &
        & CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, &
        & CheckVariable14, NullPtr0, CheckVariable15, CheckVariable16, CheckVariable17, NullPtr1, CheckVariable18, &
        & CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable25, &
        & CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, CheckVariable32, Variable2, &
        & CheckVariable36, CheckVariable37, CheckVariable39, NullPtr2, CheckVariable40, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%EIGENPROBLEM_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%EIGENPROBLEM_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: " // &
      & "EIGENPROBLEM_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_EIGENPROBLEM_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable19
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40

    ! if variable was already followed
    Ptr6 => Variable%EIGENPROBLEM_SOLVER
    IF (ASSOCIATED(Ptr6, CheckVariable19)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"EIGENPROBLEM_SOLVER"
      CALL Print_EIGENPROBLEM_SOLVER_TYPE(Variable% &
        & EIGENPROBLEM_SOLVER, CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, &
        & CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, &
        & CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable25, &
        & CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, CheckVariable32, Variable2, &
        & CheckVariable36, CheckVariable37, CheckVariable39, CheckVariable40, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: " // &
      & "EIGENPROBLEM_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%OPTIMISER_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%OPTIMISER_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: " // &
      & "OPTIMISER_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_OPTIMISER_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, PROBLEM_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable14
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19

    ! if variable was already followed
    Ptr7 => Variable%OPTIMISER_SOLVER
    IF (ASSOCIATED(Ptr7, CheckVariable14)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"OPTIMISER_SOLVER"
      CALL Print_OPTIMISER_SOLVER_TYPE(Variable% &
        & OPTIMISER_SOLVER, CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable7, &
        & CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, &
        & CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable40, &
        & CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable25, CheckVariable27, &
        & CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, CheckVariable32, Variable2, CheckVariable36, &
        & CheckVariable37, CheckVariable39, CheckVariable19, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: " // &
      & "OPTIMISER_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CELLML_EVALUATOR_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CELLML_EVALUATOR_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: " // &
      & "CELLML_EVALUATOR_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_CELLML_EVALUATOR_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, PROBLEM_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19

    ! if variable was already followed
    Ptr8 => Variable%CELLML_EVALUATOR_SOLVER
    IF (ASSOCIATED(Ptr8, CheckVariable17)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML_EVALUATOR_SOLVER"
      CALL Print_CELLML_EVALUATOR_SOLVER_TYPE(Variable% &
        & CELLML_EVALUATOR_SOLVER, CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, &
        & CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, &
        & CheckVariable40, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable25, &
        & CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, CheckVariable32, Variable2, &
        & CheckVariable36, CheckVariable37, CheckVariable39, CheckVariable19, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: " // &
      & "CELLML_EVALUATOR_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%geometricTransformationSolver
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%geometricTransformationSolver)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(GeometricTransformationSolverType), POINTER :: " // &
      & "geometricTransformationSolver " // &
      & "(associated): " 
  
! Signature of Print_GeometricTransformationSolverType has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, PROBLEM_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type (and equals subtype), use it as CheckVariable18
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19

    ! if variable was already followed
    Ptr9 => Variable%geometricTransformationSolver
    IF (ASSOCIATED(Ptr9, CheckVariable18)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"geometricTransformationSolver"
      CALL Print_GeometricTransformationSolverType(Variable% &
        & geometricTransformationSolver, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, &
        & CheckVariable5, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
        & CheckVariable18, CheckVariable40, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, &
        & CheckVariable25, CheckVariable27, CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, &
        & CheckVariable32, Variable2, CheckVariable36, CheckVariable37, CheckVariable39, CheckVariable19, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(GeometricTransformationSolverType), POINTER :: " // &
      & "geometricTransformationSolver (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%SOLVER_EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%SOLVER_EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: " // &
      & "SOLVER_EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_SOLVER_EQUATIONS_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, FIELD_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, PROBLEM_TYPE, EQUATIONS_SET_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, SOLVER_MATRICES_TYPE, LINEAR_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable25
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19

    ! if variable was already followed
    Ptr10 => Variable%SOLVER_EQUATIONS
    IF (ASSOCIATED(Ptr10, CheckVariable25)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"SOLVER_EQUATIONS"
      CALL Print_SOLVER_EQUATIONS_TYPE(Variable% &
        & SOLVER_EQUATIONS, NullPtr3, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, &
        & CheckVariable5, CheckVariable7, CheckVariable8, CheckVariable37, CheckVariable9, CheckVariable10, &
        & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, &
        & CheckVariable17, CheckVariable18, CheckVariable40, NullPtr4, CheckVariable20, CheckVariable21, CheckVariable22, &
        & CheckVariable23, CheckVariable25, CheckVariable27, CheckVariable29, CheckVariable30, CheckVariable31, &
        & CheckVariable32, Variable2, CheckVariable36, CheckVariable28, CheckVariable39, CheckVariable19, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: " // &
      & "SOLVER_EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%CELLML_EQUATIONS
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%CELLML_EQUATIONS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(CELLML_EQUATIONS_TYPE), POINTER :: " // &
      & "CELLML_EQUATIONS " // &
      & "(associated): " 
  
! Signature of Print_CELLML_EQUATIONS_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, GeometricTransformationSolverType, PROBLEM_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, EIGENPROBLEM_SOLVER_TYPE, 
! The type to handle in this routine is: SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), CONTROL_LOOP_WHILE_TYPE (CheckVariable1), FIELD_TYPE (CheckVariable2), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable3), LINEAR_DIRECT_SOLVER_TYPE (CheckVariable4), LINEAR_ITERATIVE_SOLVER_TYPE (CheckVariable5), NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable6), QUASI_NEWTON_SOLVER_TYPE (CheckVariable7), NONLINEAR_SOLVER_TYPE (CheckVariable8), NEWTON_SOLVER_TYPE (CheckVariable9), CONTROL_LOOP_FIXED_TYPE (CheckVariable10), CONTROL_LOOP_TIME_TYPE (CheckVariable11), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable12), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable13), OPTIMISER_SOLVER_TYPE (CheckVariable14), CONTROL_LOOP_SIMPLE_TYPE (CheckVariable15), DYNAMIC_SOLVER_TYPE (CheckVariable16), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable17), GeometricTransformationSolverType (CheckVariable18), EIGENPROBLEM_SOLVER_TYPE (CheckVariable19), BOUNDARY_CONDITIONS_TYPE (CheckVariable20), CELLML_EQUATIONS_TYPE (CheckVariable21), CONTROL_LOOP_TYPE (CheckVariable22), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable23), PROBLEMS_TYPE (CheckVariable24), SOLVER_EQUATIONS_TYPE (CheckVariable25), NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable26), CONTROL_LOOP_LOAD_INCREMENT_TYPE (CheckVariable27), SOLVER_MATRICES_TYPE (CheckVariable28), HISTORY_TYPE (CheckVariable29), DAE_SOLVER_TYPE (CheckVariable30), SOLVERS_TYPE (CheckVariable31), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable32), SOLVER_TYPE (CheckVariable33), QUASI_NEWTON_LINESEARCH_SOLVER_TYPE (CheckVariable34), QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE (CheckVariable35), SOLVER_MAPPING_TYPE (CheckVariable36), EULER_DAE_SOLVER_TYPE (CheckVariable37), PROBLEM_PTR_TYPE (CheckVariable38), LINEAR_SOLVER_TYPE (CheckVariable39), PROBLEM_TYPE (CheckVariable40), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type NEWTON_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type CONTROL_LOOP_FIXED_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type CONTROL_LOOP_TIME_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable18
! - signature type PROBLEM_TYPE
!   matches available passing type, use it as CheckVariable40
! - signature type BOUNDARY_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable21
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   matches available passing type, use it as CheckVariable27
! - signature type SOLVER_MATRICES_TYPE
!   matches available passing type, use it as CheckVariable28
! - signature type HISTORY_TYPE
!   matches available passing type, use it as CheckVariable29
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable30
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable31
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable32
! - signature type SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type SOLVER_MAPPING_TYPE
!   matches available passing type, use it as CheckVariable36
! - signature type EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable37
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable39
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable19

    ! if variable was already followed
    Ptr11 => Variable%CELLML_EQUATIONS
    IF (ASSOCIATED(Ptr11, CheckVariable21)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"CELLML_EQUATIONS"
      CALL Print_CELLML_EQUATIONS_TYPE(Variable% &
        & CELLML_EQUATIONS, CheckVariable0, CheckVariable1, CheckVariable3, CheckVariable4, CheckVariable5, CheckVariable7, &
        & CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, CheckVariable12, CheckVariable13, &
        & CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable40, &
        & CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable25, CheckVariable27, &
        & CheckVariable28, CheckVariable29, CheckVariable30, CheckVariable31, CheckVariable32, Variable2, CheckVariable36, &
        & CheckVariable37, CheckVariable39, CheckVariable19, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(CELLML_EQUATIONS_TYPE), POINTER :: " // &
      & "CELLML_EQUATIONS (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MeshElementsType(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, Depth, MaxDepth, MaxArrayLength)
  TYPE(MeshElementsType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MeshComponentTopologyType), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(MeshNodesType), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(MeshElementsType), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(MeshDataPointsType), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(MeshDofsType), POINTER, INTENT(IN) :: CheckVariable9

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DATA_PROJECTION_TYPE), POINTER :: NullPtr0
  TYPE(FIELD_TYPE), POINTER :: NullPtr1
  TYPE(FIELDS_TYPE), POINTER :: NullPtr2
  TYPE(DECOMPOSITION_TYPE), POINTER :: NullPtr3
  TYPE(REGION_TYPE), POINTER :: NullPtr4
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: NullPtr5
  TYPE(GENERATED_MESH_TYPE), POINTER :: NullPtr6
  TYPE(MESHES_TYPE), POINTER :: NullPtr7
  TYPE(InterfacePointsConnectivityType), POINTER :: NullPtr8

  TYPE(MeshComponentTopologyType), POINTER :: Ptr0

  TYPE(MeshElementsType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable5)) THEN
    Variable2 => CheckVariable5
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)

  
  ! Variable%meshComponentTopology
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%meshComponentTopology)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MeshComponentTopologyType), POINTER :: " // &
      & "meshComponentTopology " // &
      & "(associated): " 
  
! Signature of Print_MeshComponentTopologyType has the following CheckVariable types: DATA_PROJECTION_TYPE, MESH_TYPE, MeshDataPointsType, MeshComponentTopologyPtrType, FIELD_TYPE, MESH_PTR_TYPE, FIELDS_TYPE, DECOMPOSITION_TYPE, MeshNodesType, MeshElementsType, REGION_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, GENERATED_MESH_TYPE, MeshComponentTopologyType, MESHES_TYPE, DECOMPOSITIONS_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, MeshDofsType, 
! The type to handle in this routine is: MeshElementsType (Variable)
! Available CheckVariables are: MESH_TYPE (CheckVariable0), MeshComponentTopologyType (CheckVariable1), MeshComponentTopologyPtrType (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), MeshNodesType (CheckVariable4), MeshElementsType (CheckVariable5), MeshDataPointsType (CheckVariable6), DECOMPOSITIONS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), MeshDofsType (CheckVariable9), 
! - signature type DATA_PROJECTION_TYPE
!   is not available in passing variables, use NullPtr of type DATA_PROJECTION_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type MeshDataPointsType
!   matches available passing type, use it as CheckVariable6
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_TYPE
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type FIELDS_TYPE
!   is not available in passing variables, use NullPtr of type FIELDS_TYPE
! - signature type DECOMPOSITION_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_TYPE
! - signature type MeshNodesType
!   matches available passing type, use it as CheckVariable4
! - signature type MeshElementsType
!   is type of this print routine, use Variable2
! - signature type REGION_TYPE
!   is not available in passing variables, use NullPtr of type REGION_TYPE
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_MESH_CONNECTIVITY_TYPE
! - signature type GENERATED_MESH_TYPE
!   is not available in passing variables, use NullPtr of type GENERATED_MESH_TYPE
! - signature type MeshComponentTopologyType
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type MESHES_TYPE
!   is not available in passing variables, use NullPtr of type MESHES_TYPE
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type InterfacePointsConnectivityType
!   is not available in passing variables, use NullPtr of type InterfacePointsConnectivityType
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type MeshDofsType
!   matches available passing type, use it as CheckVariable9

    ! if variable was already followed
    Ptr0 => Variable%meshComponentTopology
    IF (ASSOCIATED(Ptr0, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"meshComponentTopology"
      CALL Print_MeshComponentTopologyType(Variable% &
        & meshComponentTopology, NullPtr0, CheckVariable0, CheckVariable6, CheckVariable2, NullPtr1, CheckVariable3, &
        & NullPtr2, NullPtr3, CheckVariable4, Variable2, NullPtr4, NullPtr5, NullPtr6, CheckVariable1, NullPtr7, &
        & CheckVariable7, NullPtr8, CheckVariable8, CheckVariable9, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MeshComponentTopologyType), POINTER :: " // &
      & "meshComponentTopology (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_ELEMENTS:              ", &
    & Variable%NUMBER_OF_ELEMENTS
  PRINT*, TRIM(PrintIndent),"LOGICAL :: " // &
    & "ELEMENTS_FINISHED:                               ", &
    & Variable%ELEMENTS_FINISHED
  
  ! Variable%ELEMENTS(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%ELEMENTS)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_ELEMENT_TYPE), POINTER :: " // &
      & "ELEMENTS(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%ELEMENTS,1), "): "
  
    DO I0 = LBOUND(Variable%ELEMENTS,1), MIN(LBOUND(Variable%ELEMENTS,1)+MaxArrayLength, UBOUND(Variable%ELEMENTS,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_MESH_ELEMENT_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: MeshElementsType (Variable)
! Available CheckVariables are: MESH_TYPE (CheckVariable0), MeshComponentTopologyType (CheckVariable1), MeshComponentTopologyPtrType (CheckVariable2), MESH_PTR_TYPE (CheckVariable3), MeshNodesType (CheckVariable4), MeshElementsType (CheckVariable5), MeshDataPointsType (CheckVariable6), DECOMPOSITIONS_TYPE (CheckVariable7), INTERFACE_TYPE (CheckVariable8), MeshDofsType (CheckVariable9), 
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"ELEMENTS("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_MESH_ELEMENT_TYPE(Variable%ELEMENTS(I0), Depth+1, MaxDepth, MaxArrayLength)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_ELEMENT_TYPE), POINTER :: " // &
      & "ELEMENTS(:) (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%ELEMENTS_TREE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%ELEMENTS_TREE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(TREE_TYPE), POINTER :: " // &
      & "ELEMENTS_TREE " // &
      & "(associated): " 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"TYPE(TREE_TYPE) :: Variable%" // &
        & "ELEMENTS_TREE (Type not defined in types.f90, therefore no output possible)"
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(TREE_TYPE), POINTER :: " // &
      & "ELEMENTS_TREE (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_MeshElementsType
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_MESHES_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, &
  & CheckVariable25, CheckVariable26, CheckVariable27, Depth, MaxDepth, MaxArrayLength)
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(MESH_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(NODES_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: CheckVariable22
  TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable23
  TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: CheckVariable24
  TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: CheckVariable25
  TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: CheckVariable26
  TYPE(REGION_TYPE), POINTER, INTENT(IN) :: CheckVariable27

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(EQUATIONS_SET_TYPE), POINTER :: NullPtr0
  TYPE(DOMAIN_TYPE), POINTER :: NullPtr1
  TYPE(CONTROL_LOOP_TYPE), POINTER :: NullPtr2
  TYPE(DOMAIN_PTR_TYPE), POINTER :: NullPtr3
  TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: NullPtr4
  TYPE(FIELD_VARIABLE_TYPE), POINTER :: NullPtr5
  TYPE(INTERFACE_CONDITION_TYPE), POINTER :: NullPtr6
  TYPE(MeshComponentTopologyType), POINTER :: NullPtr7
  TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: NullPtr8

  TYPE(REGION_TYPE), POINTER :: Ptr0
  TYPE(INTERFACE_TYPE), POINTER :: Ptr1
  TYPE(MESH_PTR_TYPE), POINTER :: Ptr2

  TYPE(MESHES_TYPE), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable0)) THEN
    Variable2 => CheckVariable0
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)

  
  ! Variable%REGION
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%REGION)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION " // &
      & "(associated): " 
  
! Signature of Print_REGION_TYPE has the following CheckVariable types: MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, EQUATIONS_SET_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, DOMAIN_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, CELLML_TYPE, MESH_TYPE, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, DOMAIN_PTR_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, EQUATIONS_SET_PTR_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESHES_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), MeshComponentTopologyPtrType (CheckVariable16), FIELDS_TYPE (CheckVariable17), GENERATED_MESHES_TYPE (CheckVariable18), DECOMPOSITIONS_TYPE (CheckVariable19), NODES_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), DECOMPOSITION_TYPE (CheckVariable25), EQUATIONS_SET_PTR_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type MESHES_TYPE
!   is type of this print routine, use Variable2
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type EQUATIONS_SET_TYPE
!   is not available in passing variables, use NullPtr of type EQUATIONS_SET_TYPE
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type DOMAIN_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_TYPE
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type CELLML_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type DOMAIN_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DOMAIN_PTR_TYPE
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type EQUATIONS_SET_PTR_TYPE
!   matches available passing type, use it as CheckVariable26
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable27

    ! if variable was already followed
    Ptr0 => Variable%REGION
    IF (ASSOCIATED(Ptr0, CheckVariable27)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"REGION"
      CALL Print_REGION_TYPE(Variable% &
        & REGION, Variable2, CheckVariable1, CheckVariable2, NullPtr0, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, NullPtr1, CheckVariable10, CheckVariable11, &
        & CheckVariable12, NullPtr2, CheckVariable13, CheckVariable15, CheckVariable17, CheckVariable18, CheckVariable19, &
        & CheckVariable20, NullPtr3, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, NullPtr4, &
        & CheckVariable25, CheckVariable26, NullPtr5, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(REGION_TYPE), POINTER :: " // &
      & "REGION (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%INTERFACE
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%INTERFACE)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE " // &
      & "(associated): " 
  
! Signature of Print_INTERFACE_TYPE has the following CheckVariable types: INTERFACE_CONDITION_TYPE, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, EQUATIONS_SETS_TYPE, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, CONTROL_LOOP_TYPE, INTERFACE_CONDITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, GENERATED_MESH_PTR_TYPE, DATA_PROJECTION_TYPE, FIELD_GEOMETRIC_PARAMETERS_TYPE, DECOMPOSITION_TYPE, FIELD_VARIABLE_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESHES_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), MeshComponentTopologyPtrType (CheckVariable16), FIELDS_TYPE (CheckVariable17), GENERATED_MESHES_TYPE (CheckVariable18), DECOMPOSITIONS_TYPE (CheckVariable19), NODES_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), DECOMPOSITION_TYPE (CheckVariable25), EQUATIONS_SET_PTR_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type INTERFACE_CONDITION_TYPE
!   is not available in passing variables, use NullPtr of type INTERFACE_CONDITION_TYPE
! - signature type MESHES_TYPE
!   is type of this print routine, use Variable2
! - signature type MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type EQUATIONS_SETS_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type INTERFACE_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable9
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TYPE
! - signature type INTERFACE_CONDITION_PTR_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable16
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type GENERATED_MESH_PTR_TYPE
!   matches available passing type, use it as CheckVariable23
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type FIELD_GEOMETRIC_PARAMETERS_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_GEOMETRIC_PARAMETERS_TYPE
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type FIELD_VARIABLE_TYPE
!   is not available in passing variables, use NullPtr of type FIELD_VARIABLE_TYPE
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27

    ! if variable was already followed
    Ptr1 => Variable%INTERFACE
    IF (ASSOCIATED(Ptr1, CheckVariable9)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"INTERFACE"
      CALL Print_INTERFACE_TYPE(Variable% &
        & INTERFACE, NullPtr6, Variable2, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, CheckVariable5, &
        & CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, CheckVariable11, &
        & CheckVariable12, NullPtr2, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, &
        & CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable23, CheckVariable24, NullPtr4, &
        & CheckVariable25, NullPtr5, CheckVariable27, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(INTERFACE_TYPE), POINTER :: " // &
      & "INTERFACE (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "NUMBER_OF_MESHES:                ", &
    & Variable%NUMBER_OF_MESHES
  
  ! Variable%MESHES(:)
  ! case pointer, array
  IsAssociated = ASSOCIATED(Variable%MESHES)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A,I3,A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(MESH_PTR_TYPE), POINTER :: " // &
      & "MESHES(:) " // &
      & "(associated, size=", &
      & SIZE(Variable%MESHES,1), "): "
  
    DO I0 = LBOUND(Variable%MESHES,1), MIN(LBOUND(Variable%MESHES,1)+MaxArrayLength, UBOUND(Variable%MESHES,1))
      WRITE(I0_STR,"(I4)") I0 

! Signature of Print_MESH_PTR_TYPE has the following CheckVariable types: MeshComponentTopologyType, MESHES_TYPE, MESH_PTR_TYPE, INTERFACE_CONDITIONS_TYPE, FIELD_PTR_TYPE, GENERATED_MESH_TYPE, FIELD_TYPE, REGION_PTR_TYPE, InterfacePointsConnectivityType, INTERFACE_TYPE, INTERFACE_PTR_TYPE, INTERFACE_MESH_CONNECTIVITY_TYPE, CELLML_ENVIRONMENTS_TYPE, DECOMPOSITION_PTR_TYPE, MESH_TYPE, MeshComponentTopologyPtrType, FIELDS_TYPE, GENERATED_MESHES_TYPE, DECOMPOSITIONS_TYPE, NODES_TYPE, INTERFACES_TYPE, DATA_POINTS_TYPE, DATA_PROJECTION_TYPE, DECOMPOSITION_TYPE, REGION_TYPE, 
! The type to handle in this routine is: MESHES_TYPE (Variable)
! Available CheckVariables are: MESHES_TYPE (CheckVariable0), MESH_PTR_TYPE (CheckVariable1), INTERFACE_CONDITIONS_TYPE (CheckVariable2), FIELD_PTR_TYPE (CheckVariable3), GENERATED_MESH_TYPE (CheckVariable4), FIELD_TYPE (CheckVariable5), REGION_PTR_TYPE (CheckVariable6), InterfacePointsConnectivityType (CheckVariable7), EQUATIONS_SETS_TYPE (CheckVariable8), INTERFACE_TYPE (CheckVariable9), INTERFACE_PTR_TYPE (CheckVariable10), INTERFACE_MESH_CONNECTIVITY_TYPE (CheckVariable11), CELLML_ENVIRONMENTS_TYPE (CheckVariable12), CELLML_TYPE (CheckVariable13), INTERFACE_CONDITION_PTR_TYPE (CheckVariable14), MESH_TYPE (CheckVariable15), MeshComponentTopologyPtrType (CheckVariable16), FIELDS_TYPE (CheckVariable17), GENERATED_MESHES_TYPE (CheckVariable18), DECOMPOSITIONS_TYPE (CheckVariable19), NODES_TYPE (CheckVariable20), INTERFACES_TYPE (CheckVariable21), DATA_POINTS_TYPE (CheckVariable22), GENERATED_MESH_PTR_TYPE (CheckVariable23), DATA_PROJECTION_TYPE (CheckVariable24), DECOMPOSITION_TYPE (CheckVariable25), EQUATIONS_SET_PTR_TYPE (CheckVariable26), REGION_TYPE (CheckVariable27), 
! - signature type MeshComponentTopologyType
!   is not available in passing variables, use NullPtr of type MeshComponentTopologyType
! - signature type MESHES_TYPE
!   is type of this print routine, use Variable2
! - signature type MESH_PTR_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type INTERFACE_CONDITIONS_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type FIELD_PTR_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type GENERATED_MESH_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type FIELD_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type REGION_PTR_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type InterfacePointsConnectivityType
!   matches available passing type, use it as CheckVariable7
! - signature type INTERFACE_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type INTERFACE_PTR_TYPE
!   matches available passing type, use it as CheckVariable10
! - signature type INTERFACE_MESH_CONNECTIVITY_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type CELLML_ENVIRONMENTS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type DECOMPOSITION_PTR_TYPE
!   is not available in passing variables, use NullPtr of type DECOMPOSITION_PTR_TYPE
! - signature type MESH_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type MeshComponentTopologyPtrType
!   matches available passing type, use it as CheckVariable16
! - signature type FIELDS_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type GENERATED_MESHES_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type DECOMPOSITIONS_TYPE
!   matches available passing type, use it as CheckVariable19
! - signature type NODES_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type INTERFACES_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type DATA_POINTS_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type DATA_PROJECTION_TYPE
!   matches available passing type, use it as CheckVariable24
! - signature type DECOMPOSITION_TYPE
!   matches available passing type, use it as CheckVariable25
! - signature type REGION_TYPE
!   matches available passing type, use it as CheckVariable27

      ! if variable was already followed
      Ptr2 => Variable%MESHES(I0)
      IF (ASSOCIATED(Ptr2, CheckVariable1)) THEN
        PRINT*, "(Pointer loop)"
      ELSE
        PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"MESHES("//TRIM(ADJUSTL(I0_STR))//")"
        CALL Print_MESH_PTR_TYPE(Variable% &
          & MESHES(I0), NullPtr7, Variable2, CheckVariable1, CheckVariable2, CheckVariable3, CheckVariable4, &
          & CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable9, CheckVariable10, CheckVariable11, &
          & CheckVariable12, NullPtr8, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable19, &
          & CheckVariable20, CheckVariable21, CheckVariable22, CheckVariable24, CheckVariable25, CheckVariable27, Depth+1, &
          & MaxDepth, MaxArrayLength)
      END IF

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(MESH_PTR_TYPE), POINTER :: " // &
      & "MESHES(:) (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_MESHES_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_EULER_DAE_SOLVER_TYPE(Variable, CheckVariable0, CheckVariable1, CheckVariable2, CheckVariable3, &
  & CheckVariable4, CheckVariable5, CheckVariable6, CheckVariable7, CheckVariable8, CheckVariable9, CheckVariable10, &
  & CheckVariable11, CheckVariable12, CheckVariable13, CheckVariable14, CheckVariable15, CheckVariable16, CheckVariable17, &
  & CheckVariable18, CheckVariable19, CheckVariable20, CheckVariable21, CheckVariable22, Depth, MaxDepth, MaxArrayLength)
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension
  TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable0
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable1
  TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable2
  TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable3
  TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable4
  TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable5
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable6
  TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: CheckVariable7
  TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable8
  TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable9
  TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: CheckVariable10
  TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable11
  TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable12
  TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable13
  TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: CheckVariable14
  TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable15
  TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: CheckVariable16
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable17
  TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable18
  TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable19
  TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable20
  TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable21
  TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: CheckVariable22

  ! iterator variables

  ! null pointers
  TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: NullPtr0
  TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: NullPtr1
  TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: NullPtr2
  TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: NullPtr3
  TYPE(NEWTON_SOLVER_TYPE), POINTER :: NullPtr4
  TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: NullPtr5
  TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: NullPtr6
  TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: NullPtr7
  TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: NullPtr8
  TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: NullPtr9
  TYPE(SOLVER_MATRICES_TYPE), POINTER :: NullPtr10
  TYPE(HISTORY_TYPE), POINTER :: NullPtr11
  TYPE(SOLVER_MAPPING_TYPE), POINTER :: NullPtr12
  TYPE(PROBLEM_TYPE), POINTER :: NullPtr13

  TYPE(DAE_SOLVER_TYPE), POINTER :: Ptr0
  TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: Ptr1
  TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: Ptr2
  TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: Ptr3

  TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: Variable2

  CHARACTER(len=1000) :: Comment

  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  IF (ASSOCIATED(CheckVariable19)) THEN
    Variable2 => CheckVariable19
  ELSE
    Variable2 => Variable
  END IF 

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)
  Nullify(NullPtr5)
  Nullify(NullPtr6)
  Nullify(NullPtr7)
  Nullify(NullPtr8)
  Nullify(NullPtr9)
  Nullify(NullPtr10)
  Nullify(NullPtr11)
  Nullify(NullPtr12)
  Nullify(NullPtr13)

  
  ! Variable%DAE_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%DAE_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_DAE_SOLVER_TYPE has the following CheckVariable types: BDF_DAE_SOLVER_TYPE, CONTROL_LOOP_WHILE_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, LINEAR_DIRECT_SOLVER_TYPE, LINEAR_ITERATIVE_SOLVER_TYPE, QUASI_NEWTON_SOLVER_TYPE, NONLINEAR_SOLVER_TYPE, NEWTON_SOLVER_TYPE, CONTROL_LOOP_FIXED_TYPE, CONTROL_LOOP_TIME_TYPE, EXTERNAL_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, OPTIMISER_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_SIMPLE_TYPE, DYNAMIC_SOLVER_TYPE, CELLML_EVALUATOR_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, GeometricTransformationSolverType, EIGENPROBLEM_SOLVER_TYPE, BOUNDARY_CONDITIONS_TYPE, CELLML_EQUATIONS_TYPE, CONTROL_LOOP_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, SOLVER_EQUATIONS_TYPE, CONTROL_LOOP_LOAD_INCREMENT_TYPE, SOLVER_MATRICES_TYPE, HISTORY_TYPE, DAE_SOLVER_TYPE, SOLVERS_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, SOLVER_TYPE, SOLVER_MAPPING_TYPE, EULER_DAE_SOLVER_TYPE, LINEAR_SOLVER_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, PROBLEM_TYPE, 
! The type to handle in this routine is: EULER_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable4), OPTIMISER_SOLVER_TYPE (CheckVariable5), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), DYNAMIC_SOLVER_TYPE (CheckVariable8), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable9), GeometricTransformationSolverType (CheckVariable10), EIGENPROBLEM_SOLVER_TYPE (CheckVariable11), CELLML_EQUATIONS_TYPE (CheckVariable12), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), DAE_SOLVER_TYPE (CheckVariable15), SOLVERS_TYPE (CheckVariable16), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), EULER_DAE_SOLVER_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable21), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable22), 
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type CONTROL_LOOP_WHILE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_WHILE_TYPE
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type LINEAR_DIRECT_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_DIRECT_SOLVER_TYPE
! - signature type LINEAR_ITERATIVE_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type LINEAR_ITERATIVE_SOLVER_TYPE
! - signature type QUASI_NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type QUASI_NEWTON_SOLVER_TYPE
! - signature type NONLINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable3
! - signature type NEWTON_SOLVER_TYPE
!   is not available in passing variables, use NullPtr of type NEWTON_SOLVER_TYPE
! - signature type CONTROL_LOOP_FIXED_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_FIXED_TYPE
! - signature type CONTROL_LOOP_TIME_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_TIME_TYPE
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22
! - signature type OPTIMISER_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable5
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_SIMPLE_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_SIMPLE_TYPE
! - signature type DYNAMIC_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable8
! - signature type CELLML_EVALUATOR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable9
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type GeometricTransformationSolverType
!   matches available passing type, use it as CheckVariable10
! - signature type EIGENPROBLEM_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable11
! - signature type BOUNDARY_CONDITIONS_TYPE
!   is not available in passing variables, use NullPtr of type BOUNDARY_CONDITIONS_TYPE
! - signature type CELLML_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable12
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type SOLVER_EQUATIONS_TYPE
!   matches available passing type, use it as CheckVariable14
! - signature type CONTROL_LOOP_LOAD_INCREMENT_TYPE
!   is not available in passing variables, use NullPtr of type CONTROL_LOOP_LOAD_INCREMENT_TYPE
! - signature type SOLVER_MATRICES_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MATRICES_TYPE
! - signature type HISTORY_TYPE
!   is not available in passing variables, use NullPtr of type HISTORY_TYPE
! - signature type DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable15
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type SOLVER_MAPPING_TYPE
!   is not available in passing variables, use NullPtr of type SOLVER_MAPPING_TYPE
! - signature type EULER_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type LINEAR_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable20
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type PROBLEM_TYPE
!   is not available in passing variables, use NullPtr of type PROBLEM_TYPE

    ! if variable was already followed
    Ptr0 => Variable%DAE_SOLVER
    IF (ASSOCIATED(Ptr0, CheckVariable15)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"DAE_SOLVER"
      CALL Print_DAE_SOLVER_TYPE(Variable% &
        & DAE_SOLVER, CheckVariable0, NullPtr0, CheckVariable2, NullPtr1, NullPtr2, NullPtr3, CheckVariable3, NullPtr4, &
        & NullPtr5, NullPtr6, CheckVariable4, CheckVariable22, CheckVariable5, CheckVariable6, NullPtr7, CheckVariable8, &
        & CheckVariable9, CheckVariable1, CheckVariable10, CheckVariable11, NullPtr8, CheckVariable12, CheckVariable7, &
        & CheckVariable13, CheckVariable14, NullPtr9, NullPtr10, NullPtr11, CheckVariable15, CheckVariable16, &
        & CheckVariable21, CheckVariable18, NullPtr12, Variable2, CheckVariable20, CheckVariable17, NullPtr13, Depth+1, &
        & MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DAE_SOLVER_TYPE), POINTER :: " // &
      & "DAE_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "EULER_TYPE:                      ", &
    & Variable%EULER_TYPE
  
  ! Variable%FORWARD_EULER_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%FORWARD_EULER_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "FORWARD_EULER_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_FORWARD_EULER_DAE_SOLVER_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, SOLVERS_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, SOLVER_TYPE, EXTERNAL_DAE_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_TYPE, BDF_DAE_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: EULER_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable4), OPTIMISER_SOLVER_TYPE (CheckVariable5), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), DYNAMIC_SOLVER_TYPE (CheckVariable8), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable9), GeometricTransformationSolverType (CheckVariable10), EIGENPROBLEM_SOLVER_TYPE (CheckVariable11), CELLML_EQUATIONS_TYPE (CheckVariable12), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), DAE_SOLVER_TYPE (CheckVariable15), SOLVERS_TYPE (CheckVariable16), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), EULER_DAE_SOLVER_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable21), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable22), 
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type EULER_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable1
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22

    ! if variable was already followed
    Ptr1 => Variable%FORWARD_EULER_SOLVER
    IF (ASSOCIATED(Ptr1, CheckVariable1)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"FORWARD_EULER_SOLVER"
      CALL Print_FORWARD_EULER_DAE_SOLVER_TYPE(Variable% &
        & FORWARD_EULER_SOLVER, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable4, &
        & Variable2, CheckVariable13, CheckVariable1, CheckVariable21, CheckVariable6, CheckVariable7, CheckVariable0, &
        & CheckVariable2, CheckVariable22, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "FORWARD_EULER_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%BACKWARD_EULER_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%BACKWARD_EULER_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "BACKWARD_EULER_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_BACKWARD_EULER_DAE_SOLVER_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, SOLVERS_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, SOLVER_TYPE, EXTERNAL_DAE_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_TYPE, BDF_DAE_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: EULER_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable4), OPTIMISER_SOLVER_TYPE (CheckVariable5), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), DYNAMIC_SOLVER_TYPE (CheckVariable8), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable9), GeometricTransformationSolverType (CheckVariable10), EIGENPROBLEM_SOLVER_TYPE (CheckVariable11), CELLML_EQUATIONS_TYPE (CheckVariable12), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), DAE_SOLVER_TYPE (CheckVariable15), SOLVERS_TYPE (CheckVariable16), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), EULER_DAE_SOLVER_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable21), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable22), 
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type EULER_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable6
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22

    ! if variable was already followed
    Ptr2 => Variable%BACKWARD_EULER_SOLVER
    IF (ASSOCIATED(Ptr2, CheckVariable6)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"BACKWARD_EULER_SOLVER"
      CALL Print_BACKWARD_EULER_DAE_SOLVER_TYPE(Variable% &
        & BACKWARD_EULER_SOLVER, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable4, &
        & Variable2, CheckVariable13, CheckVariable1, CheckVariable21, CheckVariable6, CheckVariable7, CheckVariable0, &
        & CheckVariable2, CheckVariable22, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "BACKWARD_EULER_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%IMPROVED_EULER_SOLVER
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%IMPROVED_EULER_SOLVER)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "IMPROVED_EULER_SOLVER " // &
      & "(associated): " 
  
! Signature of Print_IMPROVED_EULER_DAE_SOLVER_TYPE has the following CheckVariable types: DAE_SOLVER_TYPE, SOLVERS_TYPE, IMPROVED_EULER_DAE_SOLVER_TYPE, SOLVER_TYPE, EXTERNAL_DAE_SOLVER_TYPE, EULER_DAE_SOLVER_TYPE, CRANK_NICOLSON_DAE_SOLVER_TYPE, FORWARD_EULER_DAE_SOLVER_TYPE, ADAMS_MOULTON_DAE_SOLVER_TYPE, BACKWARD_EULER_DAE_SOLVER_TYPE, CONTROL_LOOP_TYPE, BDF_DAE_SOLVER_TYPE, RUSH_LARSON_DAE_SOLVER_TYPE, RUNGE_KUTTA_DAE_SOLVER_TYPE, 
! The type to handle in this routine is: EULER_DAE_SOLVER_TYPE (Variable)
! Available CheckVariables are: BDF_DAE_SOLVER_TYPE (CheckVariable0), FORWARD_EULER_DAE_SOLVER_TYPE (CheckVariable1), RUSH_LARSON_DAE_SOLVER_TYPE (CheckVariable2), NONLINEAR_SOLVER_TYPE (CheckVariable3), EXTERNAL_DAE_SOLVER_TYPE (CheckVariable4), OPTIMISER_SOLVER_TYPE (CheckVariable5), BACKWARD_EULER_DAE_SOLVER_TYPE (CheckVariable6), CONTROL_LOOP_TYPE (CheckVariable7), DYNAMIC_SOLVER_TYPE (CheckVariable8), CELLML_EVALUATOR_SOLVER_TYPE (CheckVariable9), GeometricTransformationSolverType (CheckVariable10), EIGENPROBLEM_SOLVER_TYPE (CheckVariable11), CELLML_EQUATIONS_TYPE (CheckVariable12), CRANK_NICOLSON_DAE_SOLVER_TYPE (CheckVariable13), SOLVER_EQUATIONS_TYPE (CheckVariable14), DAE_SOLVER_TYPE (CheckVariable15), SOLVERS_TYPE (CheckVariable16), IMPROVED_EULER_DAE_SOLVER_TYPE (CheckVariable17), SOLVER_TYPE (CheckVariable18), EULER_DAE_SOLVER_TYPE (CheckVariable19), LINEAR_SOLVER_TYPE (CheckVariable20), ADAMS_MOULTON_DAE_SOLVER_TYPE (CheckVariable21), RUNGE_KUTTA_DAE_SOLVER_TYPE (CheckVariable22), 
! - signature type DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable15
! - signature type SOLVERS_TYPE
!   matches available passing type, use it as CheckVariable16
! - signature type IMPROVED_EULER_DAE_SOLVER_TYPE
!   matches available passing type (and equals subtype), use it as CheckVariable17
! - signature type SOLVER_TYPE
!   matches available passing type, use it as CheckVariable18
! - signature type EXTERNAL_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable4
! - signature type EULER_DAE_SOLVER_TYPE
!   is type of this print routine, use Variable2
! - signature type CRANK_NICOLSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable13
! - signature type FORWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable1
! - signature type ADAMS_MOULTON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable21
! - signature type BACKWARD_EULER_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable6
! - signature type CONTROL_LOOP_TYPE
!   matches available passing type, use it as CheckVariable7
! - signature type BDF_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable0
! - signature type RUSH_LARSON_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable2
! - signature type RUNGE_KUTTA_DAE_SOLVER_TYPE
!   matches available passing type, use it as CheckVariable22

    ! if variable was already followed
    Ptr3 => Variable%IMPROVED_EULER_SOLVER
    IF (ASSOCIATED(Ptr3, CheckVariable17)) THEN
      PRINT*, "(Pointer loop)"
    ELSE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"IMPROVED_EULER_SOLVER"
      CALL Print_IMPROVED_EULER_DAE_SOLVER_TYPE(Variable% &
        & IMPROVED_EULER_SOLVER, CheckVariable15, CheckVariable16, CheckVariable17, CheckVariable18, CheckVariable4, &
        & Variable2, CheckVariable13, CheckVariable1, CheckVariable21, CheckVariable6, CheckVariable7, CheckVariable0, &
        & CheckVariable2, CheckVariable22, Depth+1, MaxDepth, MaxArrayLength)
    END IF

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: " // &
      & "IMPROVED_EULER_SOLVER (NULL)"
  ENDIF ! IF (IsAssociated)
  Comment = ""
  IF (Variable%SOLVER_LIBRARY == 1) THEN
    Comment = "SOLVER_CMISS_LIBRARY " // & 
      & "!CMISS (internal) solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 2) THEN
    Comment = "SOLVER_PETSC_LIBRARY " // & 
      & "!PETSc solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 3) THEN
    Comment = "SOLVER_MUMPS_LIBRARY " // & 
      & "!MUMPS solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 4) THEN
    Comment = "SOLVER_SUPERLU_LIBRARY " // & 
      & "!SuperLU solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 5) THEN
    Comment = "SOLVER_SPOOLES_LIBRARY " // & 
      & "!Spooles solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 6) THEN
    Comment = "SOLVER_UMFPACK_LIBRARY " // & 
      & "!UMFPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 7) THEN
    Comment = "SOLVER_LUSOL_LIBRARY " // & 
      & "!LUSOL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 8) THEN
    Comment = "SOLVER_ESSL_LIBRARY " // & 
      & "!ESSL solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 9) THEN
    Comment = "SOLVER_LAPACK_LIBRARY " // & 
      & "!LAPACK solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 10) THEN
    Comment = "SOLVER_TAO_LIBRARY " // & 
      & "!TAO solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 11) THEN
    Comment = "SOLVER_HYPRE_LIBRARY " // & 
      & "!Hypre solver library"
  ENDIF
  IF (Variable%SOLVER_LIBRARY == 12) THEN
    Comment = "SOLVER_PASTIX_LIBRARY " // & 
      & "!PaStiX solver library"
  ENDIF
  
  PRINT*, TRIM(PrintIndent),"INTEGER(INTG) :: " // &
    & "SOLVER_LIBRARY:                  ", &
    & Variable%SOLVER_LIBRARY, " ", TRIM(Comment)

  
END SUBROUTINE Print_EULER_DAE_SOLVER_TYPE
    
  
!
!================================================================================================================================
!
RECURSIVE SUBROUTINE Print_BoundaryConditionsNeumannType(Variable, Depth, MaxDepth, MaxArrayLength)
  TYPE(BoundaryConditionsNeumannType), POINTER, INTENT(IN) :: Variable
  INTEGER(INTG), INTENT(IN) :: Depth   !< the recursion depth
  INTEGER(INTG), INTENT(IN) :: MaxDepth   !< the maximum recursion depth for which data is printed
  INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
  CHARACTER(LEN=400) :: PrintIndent   !< a string containing 2*Depth space characters
  LOGICAL :: IsAllocated
  LOGICAL :: IsAssociated
  INTEGER(INTG) :: Dimension

  ! iterator variables
  INTEGER(INTG) :: I, I0
  CHARACTER(LEN=30) :: I0_STR

  ! null pointers
  TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER :: NullPtr0
  TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER :: NullPtr1
  TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: NullPtr2
  TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: NullPtr3
  TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: NullPtr4


  TYPE(BoundaryConditionsNeumannType), POINTER :: Variable2



  ! return if maximum allowed depth is reached
  IF (DEPTH > MaxDepth) THEN
    RETURN
  END IF

  PrintIndent = TRIM(GetPrintIndent(Depth))
  Variable2 => Variable

  Nullify(NullPtr0)
  Nullify(NullPtr1)
  Nullify(NullPtr2)
  Nullify(NullPtr3)
  Nullify(NullPtr4)

  
  ! Variable%setDofs(:)
  ! case allocatable
  IsAllocated = ALLOCATED(Variable%setDofs)
  IF (IsAllocated) THEN 
    Dimension = SIZE(SHAPE(Variable%setDofs),1)
    WRITE(*,'(3A,I2,A)',advance='no') &
      & " ",TRIM(PrintIndent), "INTEGER(INTG), ALLOCATABLE :: " // &
      & "setDofs(:) " // &
      & "(allocated, rank=", Dimension, ", size="

    ! loop over dimensions
    DO I = 1,Dimension
      WRITE(*,'(I5)',advance='no') &
        & SIZE(Variable%setDofs, I)
      IF (I /= Dimension) WRITE(*,'(A)',advance='no') " x "
    ENDDO
    WRITE(*,'(A)',advance='no') "): "
    PRINT*," "
    DO I0 = LBOUND(Variable%setDofs,1), MIN(LBOUND(Variable%setDofs,1)+MaxArrayLength, UBOUND(Variable%setDofs,1))
      WRITE(I0_STR,"(I4)") I0 

      PRINT*, TRIM(PrintIndent), Variable%setDofs(I0)

    ENDDO  ! I0
  ELSE
    PRINT*, TRIM(PrintIndent),"INTEGER(INTG), ALLOCATABLE :: " // &
      & "setDofs(:) (not allocated)"
  ENDIF ! IF (IsAllocated)
  
  ! Variable%integrationMatrix
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%integrationMatrix)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "integrationMatrix " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_MATRIX_TYPE has the following CheckVariable types: DISTRIBUTED_MATRIX_CMISS_TYPE, DISTRIBUTED_MATRIX_PETSC_TYPE, 
! The type to handle in this routine is: BoundaryConditionsNeumannType (Variable)
! Available CheckVariables are: 
! - signature type DISTRIBUTED_MATRIX_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_CMISS_TYPE
! - signature type DISTRIBUTED_MATRIX_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_MATRIX_PETSC_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"integrationMatrix"
      CALL Print_DISTRIBUTED_MATRIX_TYPE(Variable%integrationMatrix, NullPtr0, NullPtr1, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: " // &
      & "integrationMatrix (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%pointValues
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%pointValues)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "pointValues " // &
      & "(associated): " 
  
! Signature of Print_DISTRIBUTED_VECTOR_TYPE has the following CheckVariable types: DISTRIBUTED_VECTOR_TYPE, DISTRIBUTED_VECTOR_PETSC_TYPE, DISTRIBUTED_VECTOR_CMISS_TYPE, 
! The type to handle in this routine is: BoundaryConditionsNeumannType (Variable)
! Available CheckVariables are: 
! - signature type DISTRIBUTED_VECTOR_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_TYPE
! - signature type DISTRIBUTED_VECTOR_PETSC_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_PETSC_TYPE
! - signature type DISTRIBUTED_VECTOR_CMISS_TYPE
!   is not available in passing variables, use NullPtr of type DISTRIBUTED_VECTOR_CMISS_TYPE
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"pointValues"
      CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable%pointValues, NullPtr2, NullPtr3, NullPtr4, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: " // &
      & "pointValues (NULL)"
  ENDIF ! IF (IsAssociated)
  
  ! Variable%pointDofMapping
  ! case pointer
  IsAssociated = ASSOCIATED(Variable%pointDofMapping)
  IF (IsAssociated) THEN 
    WRITE(*,'(3A)',advance='no') &
      & " ",TRIM(PrintIndent), "TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "pointDofMapping " // &
      & "(associated): " 
  
! Signature of Print_DOMAIN_MAPPING_TYPE has the following CheckVariable types: 
! The type to handle in this routine is: BoundaryConditionsNeumannType (Variable)
! Available CheckVariables are: 
      PRINT*, NEW_LINE('A') // " " // TRIM(PrintIndent),"pointDofMapping"
      CALL Print_DOMAIN_MAPPING_TYPE(Variable%pointDofMapping, Depth+1, MaxDepth, MaxArrayLength)

  ELSE
    PRINT*, TRIM(PrintIndent),"TYPE(DOMAIN_MAPPING_TYPE), POINTER :: " // &
      & "pointDofMapping (NULL)"
  ENDIF ! IF (IsAssociated)

  
END SUBROUTINE Print_BoundaryConditionsNeumannType
    
  
  ! Wrappers
    
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DECOMPOSITION_ADJACENT_ELEMENT(Variable, MaxDepth, MaxArrayLength)
    TYPE(DECOMPOSITION_ADJACENT_ELEMENT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DECOMPOSITION_ADJACENT_ELEMENT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DECOMPOSITION_ADJACENT_ELEMENT_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DECOMPOSITION_ADJACENT_ELEMENT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_VARIABLE_TO_SOLVER_COL_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(VARIABLE_TO_SOLVER_COL_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(VARIABLE_TO_SOLVER_COL_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_VARIABLE_TO_SOLVER_COL_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_VARIABLE_TO_SOLVER_COL_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_MESH_CONNECTIVITY(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable7
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable10
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable12
    TYPE(MESH_TYPE), POINTER :: DummyVariable13
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable14
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable15
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable16
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable17
    TYPE(NODES_TYPE), POINTER :: DummyVariable18
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable19
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable20
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable21
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable22
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable23
    TYPE(REGION_TYPE), POINTER :: DummyVariable24

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)

    PRINT*, "Print TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_MESH_CONNECTIVITY_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_MESH_CONNECTIVITY
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MeshComponentTopologyType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(MeshComponentTopologyType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_TYPE), POINTER :: DummyVariable1
    TYPE(MeshDataPointsType), POINTER :: DummyVariable2
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable3
    TYPE(FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable5
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable6
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable7
    TYPE(MeshNodesType), POINTER :: DummyVariable8
    TYPE(MeshElementsType), POINTER :: DummyVariable9
    TYPE(REGION_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable11
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable12
    TYPE(MeshComponentTopologyType), POINTER :: DummyVariable13
    TYPE(MESHES_TYPE), POINTER :: DummyVariable14
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable15
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable16
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable17
    TYPE(MeshDofsType), POINTER :: DummyVariable18

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)

    PRINT*, "Print TYPE(MeshComponentTopologyType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_MeshComponentTopologyType(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MeshComponentTopologyType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable5
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable6
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable7
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable9
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable10
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_TYPE), POINTER :: DummyVariable12
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable13
    TYPE(MESH_TYPE), POINTER :: DummyVariable14
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable15
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable16
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable17
    TYPE(NODES_TYPE), POINTER :: DummyVariable18
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable19
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable20
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable21
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable22
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable23
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable24
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable25
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable26
    TYPE(REGION_TYPE), POINTER :: DummyVariable27

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)

    PRINT*, "Print TYPE(FIELD_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_FIELD_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_SET_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(FIELD_TYPE), POINTER :: DummyVariable1
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable3
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable4
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable5
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable6
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable7
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable8
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable9
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable10
    TYPE(NODES_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable12
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable13
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable14
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable15
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable16
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable18
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable19
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable20
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable21
    TYPE(REGION_TYPE), POINTER :: DummyVariable22

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)

    PRINT*, "Print TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_SET_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_SET_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_NEWTON_LINESEARCH_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable4
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable8
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable10
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable15
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: DummyVariable16

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)

    PRINT*, "Print TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_NEWTON_LINESEARCH_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_NEWTON_LINESEARCH_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable5
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable6
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable7
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable8
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable9
    TYPE(MESH_TYPE), POINTER :: DummyVariable10
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable11
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable12
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable13
    TYPE(NODES_TYPE), POINTER :: DummyVariable14
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable15
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable16
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable17
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable18
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable19
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable20
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable21
    TYPE(REGION_TYPE), POINTER :: DummyVariable22

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)

    PRINT*, "Print TYPE(FIELD_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_FIELD_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_LINE_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_LINE_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DOMAIN_LINE_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_LINE_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_LINE_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BoundaryConditionsCoupledDofsType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(BoundaryConditionsCoupledDofsType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(BoundaryConditionsCoupledDofsType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_BoundaryConditionsCoupledDofsType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BoundaryConditionsCoupledDofsType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: DummyVariable0
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable1
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_LINES_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(DOMAIN_DOFS_TYPE), POINTER :: DummyVariable5
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable6
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable7
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable8
    TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: DummyVariable9
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable10
    TYPE(CELLML_TYPE), POINTER :: DummyVariable11
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: DummyVariable12
    TYPE(MESH_TYPE), POINTER :: DummyVariable13
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable14
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DummyVariable15
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable16
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable17
    TYPE(DOMAIN_FACES_TYPE), POINTER :: DummyVariable18
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable19
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DummyVariable20
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable21
    TYPE(DecompositionDataPointsType), POINTER :: DummyVariable22
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DummyVariable23
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: DummyVariable24
    TYPE(REGION_TYPE), POINTER :: DummyVariable25

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)

    PRINT*, "Print TYPE(DOMAIN_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_DOMAIN_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_DATA_POINT_PARAM_TO_DOF_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_DATA_POINT_PARAM_TO_DOF_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_DATA_POINT_PARAM_TO_DOF_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_DATA_POINT_PARAM_TO_DOF_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_DATA_POINT_PARAM_TO_DOF_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_PHYSICAL_POINT_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_PHYSICAL_POINT_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_PHYSICAL_POINT_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_PHYSICAL_POINT_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_PHYSICAL_POINT_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_MODEL_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_MODEL_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(CELLML_MODEL_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_MODEL_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_MODEL_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_GENERATED_MESH_CYLINDER(Variable, MaxDepth, MaxArrayLength)
    TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_TYPE), POINTER :: DummyVariable2
    TYPE(MESHES_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: DummyVariable4
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable5
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable6
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable7
    TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: DummyVariable8
    TYPE(REGION_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable10
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable11
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable12
    TYPE(FIELD_TYPE), POINTER :: DummyVariable13
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable14
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable15
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable16
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable17

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)

    PRINT*, "Print TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_GENERATED_MESH_CYLINDER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_GENERATED_MESH_CYLINDER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_ENVIRONMENTS(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable10
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable12
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable13
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: DummyVariable15
    TYPE(CELLML_TYPE), POINTER :: DummyVariable16
    TYPE(MESH_TYPE), POINTER :: DummyVariable17
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable18
    TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: DummyVariable19
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable20
    TYPE(NODES_TYPE), POINTER :: DummyVariable21
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable22
    TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: DummyVariable23
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable24
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable25
    TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: DummyVariable26
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable27
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable28
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable29
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable30
    TYPE(REGION_TYPE), POINTER :: DummyVariable31

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)

    PRINT*, "Print TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_ENVIRONMENTS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, &
      & DummyVariable29, DummyVariable30, DummyVariable31, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_ENVIRONMENTS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_EQUATIONS(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: DummyVariable1
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_MATRICES_TYPE), POINTER :: DummyVariable3
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable6
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: DummyVariable8
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_MAPPING_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_PENALTY_TYPE), POINTER :: DummyVariable11
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable12
    TYPE(FIELD_TYPE), POINTER :: DummyVariable13
    TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: DummyVariable14
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable15
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable16

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)

    PRINT*, "Print TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_EQUATIONS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_EQUATIONS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_STATE_FIELD(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_STATE_FIELD_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: DummyVariable1
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable2
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable3
    TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: DummyVariable4
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable5
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable6
    TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: DummyVariable7
    TYPE(FIELD_TYPE), POINTER :: DummyVariable8
    TYPE(CELLML_TYPE), POINTER :: DummyVariable9
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: DummyVariable10
    TYPE(REGION_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: DummyVariable12

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)

    PRINT*, "Print TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_STATE_FIELD_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_STATE_FIELD
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CellMLPETScContextType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(CellMLPETScContextType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(CellMLPETScContextType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CellMLPETScContextType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CellMLPETScContextType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MeshDataPointType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(MeshDataPointType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(MeshDataPointType), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_MeshDataPointType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MeshDataPointType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_SCALING(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_SCALING_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_SCALING_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_FIELD_SCALING_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_SCALING
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MAPPING_RHS(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: DummyVariable1
    TYPE(REGION_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_TYPE), POINTER :: DummyVariable3

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)

    PRINT*, "Print TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MAPPING_RHS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, 1, &
      & MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MAPPING_RHS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FORWARD_EULER_DAE_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable1
    TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable10
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable13

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)

    PRINT*, "Print TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FORWARD_EULER_DAE_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FORWARD_EULER_DAE_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DATA_PROJECTION_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(DATA_PROJECTION_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable5
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable6
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable7
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable8
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable9
    TYPE(MESH_TYPE), POINTER :: DummyVariable10
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable11
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable12
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable13
    TYPE(NODES_TYPE), POINTER :: DummyVariable14
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable15
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable16
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable17
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable18
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable19
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable20
    TYPE(REGION_TYPE), POINTER :: DummyVariable21

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)

    PRINT*, "Print TYPE(DATA_PROJECTION_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DATA_PROJECTION_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DATA_PROJECTION_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_GENERATED_MESH(Variable, MaxDepth, MaxArrayLength)
    TYPE(GENERATED_MESH_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MeshComponentTopologyType), POINTER :: DummyVariable0
    TYPE(MESHES_TYPE), POINTER :: DummyVariable1
    TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: DummyVariable2
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable4
    TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: DummyVariable5
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable7
    TYPE(FIELD_TYPE), POINTER :: DummyVariable8
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable9
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable10
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable12
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable13
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable14
    TYPE(MESH_TYPE), POINTER :: DummyVariable15
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable16
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable17
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable18
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable19
    TYPE(NODES_TYPE), POINTER :: DummyVariable20
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable21
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable22
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable23
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable24
    TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: DummyVariable25
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable26
    TYPE(REGION_TYPE), POINTER :: DummyVariable27

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)

    PRINT*, "Print TYPE(GENERATED_MESH_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_GENERATED_MESH_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_GENERATED_MESH
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_GAUSS_POINT_PARAM_TO_DOF_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_GAUSS_POINT_PARAM_TO_DOF_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_GAUSS_POINT_PARAM_TO_DOF_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_GAUSS_POINT_PARAM_TO_DOF_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_GAUSS_POINT_PARAM_TO_DOF_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_SET_INDEPENDENT(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable2
    TYPE(EquationsSetDerivedType), POINTER :: DummyVariable3
    TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable6
    TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(FIELD_TYPE), POINTER :: DummyVariable12
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable13
    TYPE(REGION_TYPE), POINTER :: DummyVariable14
    TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: DummyVariable15

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)

    PRINT*, "Print TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_SET_INDEPENDENT_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_SET_INDEPENDENT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_TO_SOLVER_MAPS(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_TO_SOLVER_MAPS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(INTERFACE_TO_SOLVER_MAPS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_TO_SOLVER_MAPS_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_TO_SOLVER_MAPS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_ROW_TO_EQUATIONS_MAPS(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_ROW_TO_EQUATIONS_MAPS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(SOLVER_ROW_TO_EQUATIONS_MAPS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_ROW_TO_EQUATIONS_MAPS_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_ROW_TO_EQUATIONS_MAPS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_InterfacePointsConnectivityType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(InterfacePointsConnectivityType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable7
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable10
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable12
    TYPE(MESH_TYPE), POINTER :: DummyVariable13
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable14
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable15
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable16
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable17
    TYPE(NODES_TYPE), POINTER :: DummyVariable18
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable19
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable20
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable21
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable22
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable23
    TYPE(REGION_TYPE), POINTER :: DummyVariable24

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)

    PRINT*, "Print TYPE(InterfacePointsConnectivityType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_InterfacePointsConnectivityType(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_InterfacePointsConnectivityType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_RUSH_LARSON_DAE_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable3
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable6
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable19

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)

    PRINT*, "Print TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_RUSH_LARSON_DAE_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_RUSH_LARSON_DAE_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MESH_ELEMENT(Variable, MaxDepth, MaxArrayLength)
    TYPE(MESH_ELEMENT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(MESH_ELEMENT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_MESH_ELEMENT_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MESH_ELEMENT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BACKWARD_EULER_DAE_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable1
    TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable10
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable13

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)

    PRINT*, "Print TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_BACKWARD_EULER_DAE_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BACKWARD_EULER_DAE_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_VECTOR(Variable, MaxDepth, MaxArrayLength)
    TYPE(VECTOR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(VECTOR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_VECTOR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_VECTOR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_REGION_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(REGION_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable12
    TYPE(CELLML_TYPE), POINTER :: DummyVariable13
    TYPE(MESH_TYPE), POINTER :: DummyVariable14
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable15
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable16
    TYPE(NODES_TYPE), POINTER :: DummyVariable17
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable18
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable19
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable20
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable21
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable22
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable23
    TYPE(REGION_TYPE), POINTER :: DummyVariable24

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)

    PRINT*, "Print TYPE(REGION_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_REGION_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_REGION_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_GeometricTransformationSolverType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(GeometricTransformationSolverType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable1
    TYPE(FIELD_TYPE), POINTER :: DummyVariable2
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable10
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable14
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable17
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable18
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable19
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable20
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable21
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable22
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable23
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable24
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable25
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable26
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable27
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable28
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable29
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable30
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable31
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable32
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable33
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable34

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)
    NULLIFY(DummyVariable32)
    NULLIFY(DummyVariable33)
    NULLIFY(DummyVariable34)

    PRINT*, "Print TYPE(GeometricTransformationSolverType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_GeometricTransformationSolverType(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, &
      & DummyVariable29, DummyVariable30, DummyVariable31, DummyVariable32, DummyVariable33, DummyVariable34, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_GeometricTransformationSolverType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_MATRIX_TO_VAR_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_MATRIX_TO_VAR_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_MAPPING_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable1
    TYPE(FIELD_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable3

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)

    PRINT*, "Print TYPE(INTERFACE_MATRIX_TO_VAR_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_MATRIX_TO_VAR_MAP_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_MATRIX_TO_VAR_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(FIELD_TYPE), POINTER :: DummyVariable1
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: DummyVariable3
    TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable5
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable6
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable7
    TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: DummyVariable8
    TYPE(CELLML_TYPE), POINTER :: DummyVariable9
    TYPE(MESH_TYPE), POINTER :: DummyVariable10
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: DummyVariable12
    TYPE(CELLML_MODEL_TYPE), POINTER :: DummyVariable13
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable14
    TYPE(NODES_TYPE), POINTER :: DummyVariable15
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable16
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable17
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable18
    TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: DummyVariable19
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable20
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable21
    TYPE(REGION_TYPE), POINTER :: DummyVariable22

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)

    PRINT*, "Print TYPE(CELLML_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_CELLML_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_CONDITION_TO_SOLVER_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable5
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable6
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable7

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)

    PRINT*, "Print TYPE(INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_CONDITION_TO_SOLVER_MAP_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, &
      & DummyVariable3, DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_CONDITION_TO_SOLVER_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_ADJACENT_DOMAIN(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_ADJACENT_DOMAIN_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DOMAIN_ADJACENT_DOMAIN_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DOMAIN_ADJACENT_DOMAIN_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_ADJACENT_DOMAIN
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DISTRIBUTED_MATRIX_CMISS(Variable, MaxDepth, MaxArrayLength)
    TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: DummyVariable0

    NULLIFY(DummyVariable0)

    PRINT*, "Print TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DISTRIBUTED_MATRIX_CMISS_TYPE(Variable, DummyVariable0, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DISTRIBUTED_MATRIX_CMISS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CONTROL_LOOP_LOAD_INCREMENT(Variable, MaxDepth, MaxArrayLength)
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable0
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable5
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable6
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable10
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable11

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)

    PRINT*, "Print TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CONTROL_LOOP_LOAD_INCREMENT_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CONTROL_LOOP_LOAD_INCREMENT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_MATRIX_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_MATRIX_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable5

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)

    PRINT*, "Print TYPE(SOLVER_MATRIX_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_MATRIX_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_MATRIX_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_COLUMN_TO_SOLVER_ROWS_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DECOMPOSITION_FACES(Variable, MaxDepth, MaxArrayLength)
    TYPE(DECOMPOSITION_FACES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_TYPE), POINTER :: DummyVariable1
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable3
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable4
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable5
    TYPE(DecompositionDataPointsType), POINTER :: DummyVariable6
    TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: DummyVariable7
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: DummyVariable8
    TYPE(FIELD_TYPE), POINTER :: DummyVariable9
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable10
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable11

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)

    PRINT*, "Print TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DECOMPOSITION_FACES_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DECOMPOSITION_FACES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MESH_ADJACENT_ELEMENT(Variable, MaxDepth, MaxArrayLength)
    TYPE(MESH_ADJACENT_ELEMENT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(MESH_ADJACENT_ELEMENT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_MESH_ADJACENT_ELEMENT_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MESH_ADJACENT_ELEMENT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_EQUATIONS(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable0
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_TYPE), POINTER :: DummyVariable3
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable11
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable12
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable16
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable19
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable20
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable21
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable22
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable23
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable24
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable25
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable26
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable27
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable28
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable29
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable30
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable31
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable32
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable33
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable34
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable35
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable36

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)
    NULLIFY(DummyVariable32)
    NULLIFY(DummyVariable33)
    NULLIFY(DummyVariable34)
    NULLIFY(DummyVariable35)
    NULLIFY(DummyVariable36)

    PRINT*, "Print TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_EQUATIONS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, &
      & DummyVariable29, DummyVariable30, DummyVariable31, DummyVariable32, DummyVariable33, DummyVariable34, &
      & DummyVariable35, DummyVariable36, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_EQUATIONS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELDS(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELDS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable12
    TYPE(CELLML_TYPE), POINTER :: DummyVariable13
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable14
    TYPE(MESH_TYPE), POINTER :: DummyVariable15
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable16
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable17
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable18
    TYPE(NODES_TYPE), POINTER :: DummyVariable19
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable20
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable21
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable22
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable23
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable24
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable25
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable26
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable27
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable28
    TYPE(REGION_TYPE), POINTER :: DummyVariable29

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)

    PRINT*, "Print TYPE(FIELDS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_FIELDS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, DummyVariable29, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_FIELDS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_FACE(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_FACE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DOMAIN_FACE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_FACE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_FACE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_NODE(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_NODE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DOMAIN_NODE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_NODE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_NODE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_DEPENDENT(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable3
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: DummyVariable4
    TYPE(INTERFACE_PENALTY_TYPE), POINTER :: DummyVariable5
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable6
    TYPE(FIELD_TYPE), POINTER :: DummyVariable7
    TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable10

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)

    PRINT*, "Print TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_DEPENDENT_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, 1, &
      & MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_DEPENDENT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_NODE(Variable, MaxDepth, MaxArrayLength)
    TYPE(NODE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(NODE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_NODE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_NODE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_GRID_POINT_PARAM_TO_DOF_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_GRID_POINT_PARAM_TO_DOF_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_GRID_POINT_PARAM_TO_DOF_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_GRID_POINT_PARAM_TO_DOF_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_GRID_POINT_PARAM_TO_DOF_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DecompositionElementDataPointsType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(DecompositionElementDataPointsType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DecompositionElementDataPointsType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DecompositionElementDataPointsType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DecompositionElementDataPointsType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_CREATE_VALUES_CACHE(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_CREATE_VALUES_CACHE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_CREATE_VALUES_CACHE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_CREATE_VALUES_CACHE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_CREATE_VALUES_CACHE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVERS(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVERS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable0
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable2
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable5
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable7
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable10
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable13
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable15
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable16
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable17
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable19
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable20
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable21
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable22
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable23

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)

    PRINT*, "Print TYPE(SOLVERS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_SOLVERS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_SOLVERS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_OPTIMISER_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable1
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable9
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable16
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable17
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable18
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable19
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable20
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable21
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable22
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable23
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable24
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable25
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable26
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable27
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable28
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable29
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable30
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable31
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable32
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable33

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)
    NULLIFY(DummyVariable32)
    NULLIFY(DummyVariable33)

    PRINT*, "Print TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_OPTIMISER_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, &
      & DummyVariable29, DummyVariable30, DummyVariable31, DummyVariable32, DummyVariable33, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_OPTIMISER_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_SET_GEOMETRY(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_SET_GEOMETRY_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable2
    TYPE(EquationsSetDerivedType), POINTER :: DummyVariable3
    TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable6
    TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(FIELD_TYPE), POINTER :: DummyVariable12
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable13
    TYPE(REGION_TYPE), POINTER :: DummyVariable14
    TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: DummyVariable15

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)

    PRINT*, "Print TYPE(EQUATIONS_SET_GEOMETRY_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_SET_GEOMETRY_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_SET_GEOMETRY
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_JACOBIAN_TO_SOLVER_MAP_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(JACOBIAN_TO_SOLVER_MAP_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable2

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)

    PRINT*, "Print TYPE(JACOBIAN_TO_SOLVER_MAP_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_JACOBIAN_TO_SOLVER_MAP_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_JACOBIAN_TO_SOLVER_MAP_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_MATRIX(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_MATRIX_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable4

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)

    PRINT*, "Print TYPE(SOLVER_MATRIX_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_SOLVER_MATRIX_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_MATRIX
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_GENERATED_MESHES(Variable, MaxDepth, MaxArrayLength)
    TYPE(GENERATED_MESHES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable5
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable6
    TYPE(FIELD_TYPE), POINTER :: DummyVariable7
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable8
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable9
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable12
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable13
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_TYPE), POINTER :: DummyVariable15
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable16
    TYPE(MESH_TYPE), POINTER :: DummyVariable17
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable18
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable19
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable20
    TYPE(NODES_TYPE), POINTER :: DummyVariable21
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable22
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable23
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable24
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable25
    TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: DummyVariable26
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable27
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable28
    TYPE(REGION_TYPE), POINTER :: DummyVariable29

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)

    PRINT*, "Print TYPE(GENERATED_MESHES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_GENERATED_MESHES_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, &
      & DummyVariable29, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_GENERATED_MESHES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_EQUATIONS_INTERPOLATION(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable5

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)

    PRINT*, "Print TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_EQUATIONS_INTERPOLATION_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, &
      & DummyVariable3, DummyVariable4, DummyVariable5, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_EQUATIONS_INTERPOLATION
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_JACOBIAN_TO_VAR_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_JACOBIAN_TO_VAR_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_JACOBIAN_TO_VAR_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MeshNodeDerivativeType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(MeshNodeDerivativeType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(MeshNodeDerivativeType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_MeshNodeDerivativeType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MeshNodeDerivativeType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_NewtonSolverConvergenceTest_(Variable, MaxDepth, MaxArrayLength)
    TYPE(NewtonSolverConvergenceTest), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(NewtonSolverConvergenceTest), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_NewtonSolverConvergenceTest(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_NewtonSolverConvergenceTest_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BOUNDARY_CONDITIONS_VARIABLE_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(BOUNDARY_CONDITIONS_VARIABLE_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(REGION_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER :: DummyVariable6

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)

    PRINT*, "Print TYPE(BOUNDARY_CONDITIONS_VARIABLE_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_BOUNDARY_CONDITIONS_VARIABLE_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, &
      & DummyVariable3, DummyVariable4, DummyVariable5, DummyVariable6, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BOUNDARY_CONDITIONS_VARIABLE_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_TOPOLOGY(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: DummyVariable0
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable1
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DummyVariable2
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable3
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: DummyVariable4
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable5
    TYPE(DOMAIN_NODES_TYPE), POINTER :: DummyVariable6
    TYPE(DOMAIN_LINES_TYPE), POINTER :: DummyVariable7
    TYPE(FIELD_TYPE), POINTER :: DummyVariable8
    TYPE(DOMAIN_DOFS_TYPE), POINTER :: DummyVariable9
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(REGION_TYPE), POINTER :: DummyVariable11
    TYPE(DOMAIN_FACES_TYPE), POINTER :: DummyVariable12

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)

    PRINT*, "Print TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_TOPOLOGY_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_TOPOLOGY
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CONTROL_LOOP(Variable, MaxDepth, MaxArrayLength)
    TYPE(CONTROL_LOOP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable0
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable1
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable2
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable3
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable5
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable8
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable10
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable11
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable13
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable14
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable15
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable17
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable19
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable20
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable21

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)

    PRINT*, "Print TYPE(CONTROL_LOOP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_CONTROL_LOOP_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CONTROL_LOOP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_MAPPINGS(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable0
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DummyVariable1
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: DummyVariable3
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_TYPE), POINTER :: DummyVariable7

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)

    PRINT*, "Print TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_MAPPINGS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_MAPPINGS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_ADAMS_MOULTON_DAE_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable3
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable6
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable19

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)

    PRINT*, "Print TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_ADAMS_MOULTON_DAE_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_ADAMS_MOULTON_DAE_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DISTRIBUTED_VECTOR_PETSC(Variable, MaxDepth, MaxArrayLength)
    TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: DummyVariable0
    TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: DummyVariable1
    TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: DummyVariable2

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)

    PRINT*, "Print TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DISTRIBUTED_VECTOR_PETSC_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DISTRIBUTED_VECTOR_PETSC
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MATRICES_RHS(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable2

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)

    PRINT*, "Print TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MATRICES_RHS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MATRICES_RHS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EquationsSetDerivedType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(EquationsSetDerivedType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable2
    TYPE(EquationsSetDerivedType), POINTER :: DummyVariable3
    TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable6
    TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(FIELD_TYPE), POINTER :: DummyVariable12
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable13
    TYPE(REGION_TYPE), POINTER :: DummyVariable14
    TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: DummyVariable15

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)

    PRINT*, "Print TYPE(EquationsSetDerivedType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EquationsSetDerivedType(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EquationsSetDerivedType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_QUASI_NEWTON_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable0
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable5
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable7
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable10
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable13
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable15
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable16
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable17
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable19
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable20
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: DummyVariable21
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable22
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable23

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)

    PRINT*, "Print TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_QUASI_NEWTON_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_QUASI_NEWTON_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_INTERPOLATED_POINT_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_INTERPOLATED_POINT_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_INTERPOLATED_POINT_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_INTERPOLATED_POINT_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable0
    TYPE(MESHES_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable4
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable5
    TYPE(FIELD_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable8
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable12
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable13
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable14
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable15
    TYPE(MESH_TYPE), POINTER :: DummyVariable16
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable17
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable18
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable19
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable20
    TYPE(NODES_TYPE), POINTER :: DummyVariable21
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable22
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable23
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable24
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable25
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable26
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable27
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable28
    TYPE(REGION_TYPE), POINTER :: DummyVariable29

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)

    PRINT*, "Print TYPE(INTERFACE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, DummyVariable29, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_SET_ANALYTIC(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable2
    TYPE(EquationsSetDerivedType), POINTER :: DummyVariable3
    TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable6
    TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(FIELD_TYPE), POINTER :: DummyVariable12
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable13
    TYPE(REGION_TYPE), POINTER :: DummyVariable14
    TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: DummyVariable15

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)

    PRINT*, "Print TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_SET_ANALYTIC_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_SET_ANALYTIC
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MAPPING(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MAPPING_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER :: DummyVariable2
    TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER :: DummyVariable3
    TYPE(EQUATIONS_MAPPING_RHS_TYPE), POINTER :: DummyVariable4
    TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: DummyVariable5
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_TYPE), POINTER :: DummyVariable7
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable8
    TYPE(FIELD_TYPE), POINTER :: DummyVariable9
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable10
    TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER :: DummyVariable11
    TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER :: DummyVariable12

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)

    PRINT*, "Print TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MAPPING_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MAPPING
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_QUADRATURE_SCHEME(Variable, MaxDepth, MaxArrayLength)
    TYPE(QUADRATURE_SCHEME_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BASIS_TYPE), POINTER :: DummyVariable0
    TYPE(QUADRATURE_SCHEME_PTR_TYPE), POINTER :: DummyVariable1

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)

    PRINT*, "Print TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_QUADRATURE_SCHEME_TYPE(Variable, DummyVariable0, DummyVariable1, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_QUADRATURE_SCHEME
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_INTERPOLATED_POINT_METRICS_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_INTERPOLATED_POINT_METRICS_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_INTERPOLATED_POINT_METRICS_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_COL_TO_EQUATIONS_SET_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable1

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)

    PRINT*, "Print TYPE(SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_COL_TO_EQUATIONS_SET_MAP_TYPE(Variable, DummyVariable0, DummyVariable1, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_COL_TO_EQUATIONS_SET_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_PENALTY(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_PENALTY_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable3
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable4
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_TYPE), POINTER :: DummyVariable6
    TYPE(INTERFACE_PENALTY_TYPE), POINTER :: DummyVariable7
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable8
    TYPE(FIELD_TYPE), POINTER :: DummyVariable9
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable12
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable13

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)

    PRINT*, "Print TYPE(INTERFACE_PENALTY_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_PENALTY_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_PENALTY
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_QUASI_NEWTON_TRUSTREGION_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable4
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable10
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable12
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable15
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable16

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)

    PRINT*, "Print TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, &
      & DummyVariable3, DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, &
      & DummyVariable10, DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, &
      & DummyVariable16, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_QUASI_NEWTON_TRUSTREGION_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_DOFS(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_DOFS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DummyVariable0
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable1
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable4

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)

    PRINT*, "Print TYPE(DOMAIN_DOFS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_DOFS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_DOFS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_REAL_DP_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(REAL_DP_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(REAL_DP_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_REAL_DP_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_REAL_DP_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(FIELD_TYPE), POINTER :: DummyVariable1
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: DummyVariable3
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable4
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable5
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable6
    TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: DummyVariable7
    TYPE(CELLML_TYPE), POINTER :: DummyVariable8
    TYPE(MESH_TYPE), POINTER :: DummyVariable9
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable10
    TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: DummyVariable11
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable12
    TYPE(NODES_TYPE), POINTER :: DummyVariable13
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: DummyVariable15
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable16
    TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: DummyVariable17
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable18
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable19
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable20
    TYPE(REGION_TYPE), POINTER :: DummyVariable21

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)

    PRINT*, "Print TYPE(CELLML_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_CELLML_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MATRIX_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MATRIX_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_MATRIX_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MATRIX_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MATRIX_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_INTERPOLATION_PARAMETERS_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(FIELD_TYPE), POINTER :: DummyVariable0

    NULLIFY(DummyVariable0)

    PRINT*, "Print TYPE(FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_INTERPOLATION_PARAMETERS_PTR_TYPE(Variable, DummyVariable0, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_INTERPOLATION_PARAMETERS_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_NODES(Variable, MaxDepth, MaxArrayLength)
    TYPE(NODES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable12
    TYPE(CELLML_TYPE), POINTER :: DummyVariable13
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable14
    TYPE(MESH_TYPE), POINTER :: DummyVariable15
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable16
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable17
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable18
    TYPE(NODES_TYPE), POINTER :: DummyVariable19
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable20
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable21
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable22
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable23
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable24
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable25
    TYPE(REGION_TYPE), POINTER :: DummyVariable26

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)

    PRINT*, "Print TYPE(NODES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_NODES_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_NODES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_QUASI_NEWTON_LINESEARCH_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable4
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable10
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable12
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable15
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable16

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)

    PRINT*, "Print TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_QUASI_NEWTON_LINESEARCH_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, &
      & DummyVariable3, DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, &
      & DummyVariable10, DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, &
      & DummyVariable16, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_QUASI_NEWTON_LINESEARCH_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: DummyVariable0
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_TYPE), POINTER :: DummyVariable2
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable6
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: DummyVariable7
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable8
    TYPE(DecompositionDataPointsType), POINTER :: DummyVariable9
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DummyVariable11
    TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: DummyVariable12
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: DummyVariable13
    TYPE(FIELD_TYPE), POINTER :: DummyVariable14
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable15
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable16
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable17
    TYPE(REGION_TYPE), POINTER :: DummyVariable18

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)

    PRINT*, "Print TYPE(DOMAIN_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_DOMAIN_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_SET_SOURCE(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable2
    TYPE(EquationsSetDerivedType), POINTER :: DummyVariable3
    TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable6
    TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(FIELD_TYPE), POINTER :: DummyVariable12
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable13
    TYPE(REGION_TYPE), POINTER :: DummyVariable14
    TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: DummyVariable15

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)

    PRINT*, "Print TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_SET_SOURCE_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_SET_SOURCE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EMBEDDING_GAUSSPOINT(Variable, MaxDepth, MaxArrayLength)
    TYPE(EMBEDDING_GAUSSPOINT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EMBEDDING_GAUSSPOINT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EMBEDDING_GAUSSPOINT_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EMBEDDING_GAUSSPOINT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_NODE_DERIVATIVE(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_NODE_DERIVATIVE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DOMAIN_NODE_DERIVATIVE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DOMAIN_NODE_DERIVATIVE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_NODE_DERIVATIVE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_LINE(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_LINE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DOMAIN_LINE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_LINE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_LINE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_MAPPING(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_MAPPING_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DOMAIN_MAPPING_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_MAPPING_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_MAPPING
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_EQUATIONS_INTERPOLATION_SET(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_EQUATIONS_INTERPOLATION_SET_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_EQUATIONS_INTERPOLATION_SET
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DYNAMIC_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable1
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable9
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable16
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable18
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable19
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable20
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable21
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable22
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable23
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable24
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable25
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable26
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable27
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable28
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable29
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable30
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable31
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable32
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable33

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)
    NULLIFY(DummyVariable32)
    NULLIFY(DummyVariable33)

    PRINT*, "Print TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DYNAMIC_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, &
      & DummyVariable29, DummyVariable30, DummyVariable31, DummyVariable32, DummyVariable33, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DYNAMIC_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CONTROL_LOOP_WHILE(Variable, MaxDepth, MaxArrayLength)
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable0
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable5
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable6
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable10
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable11

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)

    PRINT*, "Print TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CONTROL_LOOP_WHILE_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CONTROL_LOOP_WHILE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_SCALINGS(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_SCALINGS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_SCALINGS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_FIELD_SCALINGS_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_SCALINGS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CRANK_NICOLSON_DAE_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable3
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable6
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable19

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)

    PRINT*, "Print TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CRANK_NICOLSON_DAE_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CRANK_NICOLSON_DAE_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_QUADRATURE_SCHEME_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(QUADRATURE_SCHEME_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BASIS_TYPE), POINTER :: DummyVariable0
    TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: DummyVariable1

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)

    PRINT*, "Print TYPE(QUADRATURE_SCHEME_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_QUADRATURE_SCHEME_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_QUADRATURE_SCHEME_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable1
    TYPE(EquationsSetDerivedType), POINTER :: DummyVariable2
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable3
    TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: DummyVariable6
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: DummyVariable8
    TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: DummyVariable9
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable10
    TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: DummyVariable11
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable12
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable13
    TYPE(FIELD_TYPE), POINTER :: DummyVariable14
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable15
    TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: DummyVariable16
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable17
    TYPE(REGION_TYPE), POINTER :: DummyVariable18
    TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: DummyVariable19

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)

    PRINT*, "Print TYPE(EQUATIONS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_PARAMETER_SET_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_PARAMETER_SET_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_PARAMETER_SET_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_PARAMETER_SET_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_PARAMETER_SET_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_INTERPOLATION_PARAMETERS(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(FIELD_TYPE), POINTER :: DummyVariable0

    NULLIFY(DummyVariable0)

    PRINT*, "Print TYPE(FIELD_INTERPOLATION_PARAMETERS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_INTERPOLATION_PARAMETERS_TYPE(Variable, DummyVariable0, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_INTERPOLATION_PARAMETERS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DECOMPOSITION_ELEMENT(Variable, MaxDepth, MaxArrayLength)
    TYPE(DECOMPOSITION_ELEMENT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DECOMPOSITION_ELEMENT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DECOMPOSITION_ELEMENT_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DECOMPOSITION_ELEMENT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_ELEMENT_CONNECTIVITY(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_ELEMENT_CONNECTIVITY_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(INTERFACE_ELEMENT_CONNECTIVITY_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_ELEMENT_CONNECTIVITY_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_ELEMENT_CONNECTIVITY
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MeshElementDataPointType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(MeshElementDataPointType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(MeshElementDataPointType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_MeshElementDataPointType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MeshElementDataPointType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_COL_TO_INTERFACE_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_COL_TO_INTERFACE_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable1

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)

    PRINT*, "Print TYPE(SOLVER_COL_TO_INTERFACE_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_COL_TO_INTERFACE_MAP_TYPE(Variable, DummyVariable0, DummyVariable1, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_COL_TO_INTERFACE_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_HISTORY(Variable, MaxDepth, MaxArrayLength)
    TYPE(HISTORY_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable0
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable5
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable6
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable10
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable11

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)

    PRINT*, "Print TYPE(HISTORY_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_HISTORY_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_HISTORY
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BDF_DAE_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable3
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable6
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable19

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)

    PRINT*, "Print TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_BDF_DAE_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BDF_DAE_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BOUNDARY_CONDITIONS_DIRICHLET(Variable, MaxDepth, MaxArrayLength)
    TYPE(BOUNDARY_CONDITIONS_DIRICHLET_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(BOUNDARY_CONDITIONS_DIRICHLET_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_BOUNDARY_CONDITIONS_DIRICHLET_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BOUNDARY_CONDITIONS_DIRICHLET
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED(Variable, MaxDepth, MaxArrayLength)
    TYPE(BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED_TYPE), POINTER :: Variable with maximum depth ",MaxDepth, &
      & ", maximum array length:",MaxArrayLength
    CALL Print_BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BOUNDARY_CONDITIONS_PRESSURE_INCREMENTED
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_COL_TO_SOLVER_COLS_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_COL_TO_SOLVER_COLS_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_COL_TO_SOLVER_COLS_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_ELEMENT_MATRIX(Variable, MaxDepth, MaxArrayLength)
    TYPE(ELEMENT_MATRIX_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(ELEMENT_MATRIX_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_ELEMENT_MATRIX_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_ELEMENT_MATRIX
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CONTROL_LOOP_SIMPLE(Variable, MaxDepth, MaxArrayLength)
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable0
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable5
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable6
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable10
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable11

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)

    PRINT*, "Print TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CONTROL_LOOP_SIMPLE_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CONTROL_LOOP_SIMPLE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_MODEL_MAPS(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_MODEL_MAPS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(CELLML_MODEL_MAPS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_MODEL_MAPS_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_MODEL_MAPS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DecompositionDataPointsType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(DecompositionDataPointsType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_TYPE), POINTER :: DummyVariable1
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable3
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable4
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable5
    TYPE(DecompositionDataPointsType), POINTER :: DummyVariable6
    TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: DummyVariable7
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: DummyVariable8
    TYPE(FIELD_TYPE), POINTER :: DummyVariable9
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable10
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable11

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)

    PRINT*, "Print TYPE(DecompositionDataPointsType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DecompositionDataPointsType(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DecompositionDataPointsType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_MODEL_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_MODEL_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: DummyVariable0
    TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_MODEL_TYPE), POINTER :: DummyVariable2
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable3
    TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(CELLML_TYPE), POINTER :: DummyVariable6
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: DummyVariable7
    TYPE(REGION_TYPE), POINTER :: DummyVariable8
    TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: DummyVariable9

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)

    PRINT*, "Print TYPE(CELLML_MODEL_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_MODEL_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_MODEL_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DISTRIBUTED_VECTOR(Variable, MaxDepth, MaxArrayLength)
    TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: DummyVariable0
    TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: DummyVariable1
    TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: DummyVariable2

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)

    PRINT*, "Print TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DISTRIBUTED_VECTOR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DISTRIBUTED_VECTOR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DECOMPOSITION(Variable, MaxDepth, MaxArrayLength)
    TYPE(DECOMPOSITION_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: DummyVariable2
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable4
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable5
    TYPE(FIELD_TYPE), POINTER :: DummyVariable6
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable7
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable8
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable10
    TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: DummyVariable11
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: DummyVariable12
    TYPE(MESH_TYPE), POINTER :: DummyVariable13
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable14
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable15
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable16
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable17
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable18
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable19
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DummyVariable20
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable21
    TYPE(DecompositionDataPointsType), POINTER :: DummyVariable22
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: DummyVariable23
    TYPE(REGION_TYPE), POINTER :: DummyVariable24

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)

    PRINT*, "Print TYPE(DECOMPOSITION_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DECOMPOSITION_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DECOMPOSITION
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_REGIONS(Variable, MaxDepth, MaxArrayLength)
    TYPE(REGIONS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(REGIONS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_REGIONS_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_REGIONS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MAPPING_NONLINEAR(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: DummyVariable1

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)

    PRINT*, "Print TYPE(EQUATIONS_MAPPING_NONLINEAR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MAPPING_NONLINEAR_TYPE(Variable, DummyVariable0, DummyVariable1, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MAPPING_NONLINEAR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MeshElementDataPointsType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(MeshElementDataPointsType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(MeshElementDataPointsType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_MeshElementDataPointsType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MeshElementDataPointsType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_NodalVectorType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(NodalVectorType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(NodalVectorType), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_NodalVectorType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_NodalVectorType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_GEOMETRIC_PARAMETERS(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable1
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_TYPE), POINTER :: DummyVariable7

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)

    PRINT*, "Print TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_GEOMETRIC_PARAMETERS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_GEOMETRIC_PARAMETERS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DISTRIBUTED_VECTOR_CMISS(Variable, MaxDepth, MaxArrayLength)
    TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: DummyVariable0
    TYPE(DISTRIBUTED_VECTOR_PETSC_TYPE), POINTER :: DummyVariable1
    TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: DummyVariable2

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)

    PRINT*, "Print TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DISTRIBUTED_VECTOR_CMISS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DISTRIBUTED_VECTOR_CMISS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_PARAMETER_SETS(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_PARAMETER_SETS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable1
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_TYPE), POINTER :: DummyVariable7

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)

    PRINT*, "Print TYPE(FIELD_PARAMETER_SETS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_PARAMETER_SETS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_PARAMETER_SETS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DECOMPOSITION_LINE(Variable, MaxDepth, MaxArrayLength)
    TYPE(DECOMPOSITION_LINE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DECOMPOSITION_LINE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DECOMPOSITION_LINE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DECOMPOSITION_LINE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DECOMPOSITION_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable0
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_TYPE), POINTER :: DummyVariable2
    TYPE(MESHES_TYPE), POINTER :: DummyVariable3
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable4
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable6
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable7
    TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: DummyVariable8
    TYPE(DecompositionDataPointsType), POINTER :: DummyVariable9
    TYPE(REGION_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable11
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable12
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: DummyVariable13
    TYPE(FIELD_TYPE), POINTER :: DummyVariable14
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable15
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable16
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable17
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable18

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)

    PRINT*, "Print TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DECOMPOSITION_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DECOMPOSITION_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_PROBLEM(Variable, MaxDepth, MaxArrayLength)
    TYPE(PROBLEM_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable0
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable5
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable6
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable10
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable11

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)

    PRINT*, "Print TYPE(PROBLEM_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_PROBLEM_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_PROBLEM
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BOUNDARY_CONDITIONS(Variable, MaxDepth, MaxArrayLength)
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable1
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable3
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable4
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable5
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_TYPE), POINTER :: DummyVariable7
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable9
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable10
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable12
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(FIELD_TYPE), POINTER :: DummyVariable14
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable15
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER :: DummyVariable17
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable19
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable20

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)

    PRINT*, "Print TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_BOUNDARY_CONDITIONS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BOUNDARY_CONDITIONS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_LIST_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(LIST_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(LIST_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_LIST_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_LIST_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SolverMappingDofCouplingsType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(SolverMappingDofCouplingsType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(SolverMappingDofCouplingsType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SolverMappingDofCouplingsType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SolverMappingDofCouplingsType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable3

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)

    PRINT*, "Print TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth, &
      & ", maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, &
      & DummyVariable3, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_EQUATIONS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_EQUATIONS_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MeshNodesType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(MeshNodesType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESH_TYPE), POINTER :: DummyVariable0
    TYPE(MeshComponentTopologyType), POINTER :: DummyVariable1
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable2
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(MeshNodesType), POINTER :: DummyVariable4
    TYPE(MeshElementsType), POINTER :: DummyVariable5
    TYPE(MeshDataPointsType), POINTER :: DummyVariable6
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable7
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable8
    TYPE(MeshDofsType), POINTER :: DummyVariable9

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)

    PRINT*, "Print TYPE(MeshNodesType), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_MeshNodesType(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MeshNodesType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_FACES(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_FACES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DummyVariable0
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable1
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable4

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)

    PRINT*, "Print TYPE(DOMAIN_FACES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_FACES_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_FACES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_LIST(Variable, MaxDepth, MaxArrayLength)
    TYPE(LIST_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(LIST_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_LIST_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_LIST
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CONTROL_LOOP_TIME(Variable, MaxDepth, MaxArrayLength)
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable0
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable5
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable6
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable10
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable11

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)

    PRINT*, "Print TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CONTROL_LOOP_TIME_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CONTROL_LOOP_TIME
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_SET_EQUATIONS_SET_FIELD(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_SET_EQUATIONS_SET_FIELD_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable2
    TYPE(EquationsSetDerivedType), POINTER :: DummyVariable3
    TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable6
    TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(FIELD_TYPE), POINTER :: DummyVariable12
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable13
    TYPE(REGION_TYPE), POINTER :: DummyVariable14
    TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: DummyVariable15

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)

    PRINT*, "Print TYPE(EQUATIONS_SET_EQUATIONS_SET_FIELD_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_SET_EQUATIONS_SET_FIELD_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, &
      & DummyVariable3, DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, &
      & DummyVariable10, DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_SET_EQUATIONS_SET_FIELD
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_MAPPING_RHS(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_MAPPING_TYPE), POINTER :: DummyVariable0
    TYPE(FIELD_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable2

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)

    PRINT*, "Print TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_MAPPING_RHS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_MAPPING_RHS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES(Variable, MaxDepth, MaxArrayLength)
    TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_NODE_PARAM_TO_DOF_MAP_DERIVATIVE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DECOMPOSITION_TOPOLOGY(Variable, MaxDepth, MaxArrayLength)
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_TYPE), POINTER :: DummyVariable1
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable3
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable4
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable6
    TYPE(DecompositionDataPointsType), POINTER :: DummyVariable7
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable8
    TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: DummyVariable9
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: DummyVariable10
    TYPE(FIELD_TYPE), POINTER :: DummyVariable11
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable12
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable13
    TYPE(REGION_TYPE), POINTER :: DummyVariable14

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)

    PRINT*, "Print TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DECOMPOSITION_TOPOLOGY_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DECOMPOSITION_TOPOLOGY
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_LAGRANGE(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_LAGRANGE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable3
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable4
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_TYPE), POINTER :: DummyVariable6
    TYPE(INTERFACE_PENALTY_TYPE), POINTER :: DummyVariable7
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable8
    TYPE(FIELD_TYPE), POINTER :: DummyVariable9
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable12
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable13

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)

    PRINT*, "Print TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_LAGRANGE_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_LAGRANGE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BOUNDARY_CONDITIONS_VARIABLE(Variable, MaxDepth, MaxArrayLength)
    TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(REGION_TYPE), POINTER :: DummyVariable5

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)

    PRINT*, "Print TYPE(BOUNDARY_CONDITIONS_VARIABLE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_BOUNDARY_CONDITIONS_VARIABLE_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BOUNDARY_CONDITIONS_VARIABLE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_LINES(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_LINES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DummyVariable0
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable1
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable4

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)

    PRINT*, "Print TYPE(DOMAIN_LINES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_LINES_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_LINES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DATA_POINTS(Variable, MaxDepth, MaxArrayLength)
    TYPE(DATA_POINTS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable12
    TYPE(CELLML_TYPE), POINTER :: DummyVariable13
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable14
    TYPE(MESH_TYPE), POINTER :: DummyVariable15
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable16
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable17
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable18
    TYPE(NODES_TYPE), POINTER :: DummyVariable19
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable20
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable21
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable22
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable23
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable24
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable25
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable26
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable27
    TYPE(REGION_TYPE), POINTER :: DummyVariable28

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)

    PRINT*, "Print TYPE(DATA_POINTS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DATA_POINTS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DATA_POINTS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTEGER_INTG_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTEGER_INTG_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(INTEGER_INTG_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTEGER_INTG_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTEGER_INTG_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_VARIABLE(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_VARIABLE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable1
    TYPE(MESHES_TYPE), POINTER :: DummyVariable2
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable3
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable4
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable5
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable7
    TYPE(CELLML_TYPE), POINTER :: DummyVariable8
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable9
    TYPE(FIELD_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable12
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable13
    TYPE(NODES_TYPE), POINTER :: DummyVariable14
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable15
    TYPE(REGION_TYPE), POINTER :: DummyVariable16
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable17

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)

    PRINT*, "Print TYPE(FIELD_VARIABLE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_FIELD_VARIABLE_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_VARIABLE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_PARAM_TO_DOF_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_PARAM_TO_DOF_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_PARAM_TO_DOF_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_PARAM_TO_DOF_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_PARAM_TO_DOF_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DATA_PROJECTION(Variable, MaxDepth, MaxArrayLength)
    TYPE(DATA_PROJECTION_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable7
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable9
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable10
    TYPE(MESH_TYPE), POINTER :: DummyVariable11
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable12
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable13
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable14
    TYPE(NODES_TYPE), POINTER :: DummyVariable15
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable16
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable17
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable18
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable19
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable20
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable21
    TYPE(REGION_TYPE), POINTER :: DummyVariable22

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)

    PRINT*, "Print TYPE(DATA_PROJECTION_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DATA_PROJECTION_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_DATA_PROJECTION
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_COL_TO_STATIC_EQUATIONS_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_COL_TO_STATIC_EQUATIONS_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(SOLVER_COL_TO_STATIC_EQUATIONS_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_COL_TO_STATIC_EQUATIONS_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_COL_TO_STATIC_EQUATIONS_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_PARAMETERS_FIELD(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: DummyVariable1
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable2
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable3
    TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: DummyVariable4
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable5
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable6
    TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: DummyVariable7
    TYPE(FIELD_TYPE), POINTER :: DummyVariable8
    TYPE(CELLML_TYPE), POINTER :: DummyVariable9
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: DummyVariable10
    TYPE(REGION_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: DummyVariable12

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)

    PRINT*, "Print TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_PARAMETERS_FIELD_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_PARAMETERS_FIELD
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_MATRICES(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_MATRICES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable5
    TYPE(INTERFACE_RHS_TYPE), POINTER :: DummyVariable6
    TYPE(FIELD_TYPE), POINTER :: DummyVariable7
    TYPE(INTERFACE_MAPPING_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)

    PRINT*, "Print TYPE(INTERFACE_MATRICES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_MATRICES_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_MATRICES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DISTRIBUTED_MATRIX_PETSC(Variable, MaxDepth, MaxArrayLength)
    TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: DummyVariable0

    NULLIFY(DummyVariable0)

    PRINT*, "Print TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DISTRIBUTED_MATRIX_PETSC_TYPE(Variable, DummyVariable0, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DISTRIBUTED_MATRIX_PETSC
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MeshNodeType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(MeshNodeType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(MeshNodeType), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_MeshNodeType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MeshNodeType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_PROBLEMS(Variable, MaxDepth, MaxArrayLength)
    TYPE(PROBLEMS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable0
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable2
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable3
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable5
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable9
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable10

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)

    PRINT*, "Print TYPE(PROBLEMS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_PROBLEMS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_PROBLEMS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_CONDITION_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable0
    TYPE(MESHES_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable5
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable6
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable9
    TYPE(MESH_TYPE), POINTER :: DummyVariable10
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable11
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable12
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable13
    TYPE(NODES_TYPE), POINTER :: DummyVariable14
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable15
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable16
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable17
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable18
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable19
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable20
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable21
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable22
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable23
    TYPE(REGION_TYPE), POINTER :: DummyVariable24

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)

    PRINT*, "Print TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_CONDITION_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_CONDITION_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_SET_MATERIALS(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable2
    TYPE(EquationsSetDerivedType), POINTER :: DummyVariable3
    TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable6
    TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(FIELD_TYPE), POINTER :: DummyVariable12
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable13
    TYPE(REGION_TYPE), POINTER :: DummyVariable14
    TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: DummyVariable15

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)

    PRINT*, "Print TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_SET_MATERIALS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_SET_MATERIALS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_MAPPING(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_MAPPING_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACE_MAPPING_RHS_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable6
    TYPE(INTERFACE_MATRICES_TYPE), POINTER :: DummyVariable7

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)

    PRINT*, "Print TYPE(INTERFACE_MAPPING_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_MAPPING_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_MAPPING
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_SM(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_SM_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_SM
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MATRICES_LINEAR(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable2

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)

    PRINT*, "Print TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MATRICES_LINEAR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MATRICES_LINEAR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_EQUATIONS_INTERPOLATION_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable1
    TYPE(FIELD_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable3

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)

    PRINT*, "Print TYPE(INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE), POINTER :: Variable with maximum depth ",MaxDepth, &
      & ", maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, &
      & DummyVariable3, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_EQUATIONS_DOMAIN_INTERPOLATION
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_CONDITIONS(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable0
    TYPE(MESHES_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable4
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable5
    TYPE(FIELD_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable13
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable14
    TYPE(MESH_TYPE), POINTER :: DummyVariable15
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable16
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable17
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable18
    TYPE(NODES_TYPE), POINTER :: DummyVariable19
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable20
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable21
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable22
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable23
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable24
    TYPE(REGION_TYPE), POINTER :: DummyVariable25

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)

    PRINT*, "Print TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_CONDITIONS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_CONDITIONS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MAPPING_SOURCE(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: DummyVariable1
    TYPE(REGION_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_TYPE), POINTER :: DummyVariable3

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)

    PRINT*, "Print TYPE(EQUATIONS_MAPPING_SOURCE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MAPPING_SOURCE_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, 1, &
      & MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MAPPING_SOURCE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BASIS_FUNCTIONS(Variable, MaxDepth, MaxArrayLength)
    TYPE(BASIS_FUNCTIONS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(BASIS_FUNCTIONS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_BASIS_FUNCTIONS_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BASIS_FUNCTIONS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MATRIX(Variable, MaxDepth, MaxArrayLength)
    TYPE(MATRIX_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(MATRIX_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_MATRIX_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MATRIX
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACES(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable12
    TYPE(CELLML_TYPE), POINTER :: DummyVariable13
    TYPE(MESH_TYPE), POINTER :: DummyVariable14
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable15
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable16
    TYPE(NODES_TYPE), POINTER :: DummyVariable17
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable18
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable19
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable20
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable21
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable22
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable23
    TYPE(REGION_TYPE), POINTER :: DummyVariable24

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)

    PRINT*, "Print TYPE(INTERFACES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_INTERFACES_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_MAPPING_VARIABLES(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_MAPPING_VARIABLES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(SOLVER_MAPPING_VARIABLES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_MAPPING_VARIABLES_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_MAPPING_VARIABLES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_NEWTON_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(NEWTON_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable0
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable5
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable6
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable8
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable11
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable12
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable13
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable14
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable15
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable17
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable18
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable19
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable20
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable21
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable22
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable23

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)

    PRINT*, "Print TYPE(NEWTON_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_NEWTON_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_NEWTON_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_VAR_TO_EQUATIONS_COLUMN_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(VAR_TO_EQUATIONS_COLUMN_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(VAR_TO_EQUATIONS_COLUMN_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_VAR_TO_EQUATIONS_COLUMN_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_VAR_TO_EQUATIONS_COLUMN_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DISTRIBUTED_VECTOR_TRANSFER(Variable, MaxDepth, MaxArrayLength)
    TYPE(DISTRIBUTED_VECTOR_TRANSFER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DISTRIBUTED_VECTOR_TYPE), POINTER :: DummyVariable0
    TYPE(DISTRIBUTED_VECTOR_CMISS_TYPE), POINTER :: DummyVariable1

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)

    PRINT*, "Print TYPE(DISTRIBUTED_VECTOR_TRANSFER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DISTRIBUTED_VECTOR_TRANSFER_TYPE(Variable, DummyVariable0, DummyVariable1, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DISTRIBUTED_VECTOR_TRANSFER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_TO_SOLVER_MAPS(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_TO_SOLVER_MAPS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_TO_SOLVER_MAPS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_TO_SOLVER_MAPS_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_TO_SOLVER_MAPS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EXTERNAL_DAE_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable3
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable6
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable19

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)

    PRINT*, "Print TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EXTERNAL_DAE_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EXTERNAL_DAE_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_FIELD_MAPS(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_FIELD_MAPS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable3
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable4
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable5
    TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: DummyVariable6
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable7
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable8
    TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: DummyVariable9
    TYPE(FIELD_TYPE), POINTER :: DummyVariable10
    TYPE(CELLML_TYPE), POINTER :: DummyVariable11
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable12
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: DummyVariable13
    TYPE(REGION_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: DummyVariable15

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)

    PRINT*, "Print TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_FIELD_MAPS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_FIELD_MAPS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_ELEMENT(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_ELEMENT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DOMAIN_ELEMENT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_ELEMENT_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_ELEMENT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_QUADRATURE(Variable, MaxDepth, MaxArrayLength)
    TYPE(QUADRATURE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BASIS_TYPE), POINTER :: DummyVariable0
    TYPE(QUADRATURE_SCHEME_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(QUADRATURE_SCHEME_TYPE), POINTER :: DummyVariable2
    TYPE(BASIS_PTR_TYPE), POINTER :: DummyVariable3

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)

    PRINT*, "Print TYPE(QUADRATURE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_QUADRATURE_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_QUADRATURE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_EM
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_PHYSICAL_POINT(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_PHYSICAL_POINT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_PHYSICAL_POINT_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_PHYSICAL_POINT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_VARIABLE_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_VARIABLE_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable1
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_TYPE), POINTER :: DummyVariable7
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable8

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)

    PRINT*, "Print TYPE(FIELD_VARIABLE_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_VARIABLE_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_VARIABLE_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable3

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)

    PRINT*, "Print TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth, &
      & ", maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, &
      & DummyVariable3, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_INTERFACE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_RUNGE_KUTTA_DAE_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable3
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable6
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable19

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)

    PRINT*, "Print TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_RUNGE_KUTTA_DAE_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_RUNGE_KUTTA_DAE_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_FACE_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_FACE_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DOMAIN_FACE_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_FACE_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_FACE_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_ELEMENTS(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_ELEMENTS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DummyVariable0
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable1
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable4

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)

    PRINT*, "Print TYPE(DOMAIN_ELEMENTS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_ELEMENTS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_ELEMENTS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BoundaryConditionsCoupledDofsPtrType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(BoundaryConditionsCoupledDofsPtrType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(BoundaryConditionsCoupledDofsPtrType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_BoundaryConditionsCoupledDofsPtrType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BoundaryConditionsCoupledDofsPtrType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_GENERATED_MESH_ELLIPSOID(Variable, MaxDepth, MaxArrayLength)
    TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_TYPE), POINTER :: DummyVariable2
    TYPE(MESHES_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: DummyVariable4
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable5
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable6
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable7
    TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: DummyVariable8
    TYPE(REGION_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable10
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable11
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable12
    TYPE(FIELD_TYPE), POINTER :: DummyVariable13
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable14
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable15
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable16
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable17

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)

    PRINT*, "Print TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_GENERATED_MESH_ELLIPSOID_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_GENERATED_MESH_ELLIPSOID
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_GEOMETRY(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_GEOMETRY_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable3
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable4
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_TYPE), POINTER :: DummyVariable6
    TYPE(INTERFACE_PENALTY_TYPE), POINTER :: DummyVariable7
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable8
    TYPE(FIELD_TYPE), POINTER :: DummyVariable9
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable12
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable13

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)

    PRINT*, "Print TYPE(INTERFACE_GEOMETRY_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_GEOMETRY_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_GEOMETRY
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_VAR_TO_EQUATIONS_JACOBIAN_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(VAR_TO_EQUATIONS_JACOBIAN_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(VAR_TO_EQUATIONS_JACOBIAN_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_VAR_TO_EQUATIONS_JACOBIAN_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_VAR_TO_EQUATIONS_JACOBIAN_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_CONDITION(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_CONDITION_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable0
    TYPE(MESHES_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable5
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable6
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable9
    TYPE(MESH_TYPE), POINTER :: DummyVariable10
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable12
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable13
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable14
    TYPE(INTERFACE_LAGRANGE_TYPE), POINTER :: DummyVariable15
    TYPE(NODES_TYPE), POINTER :: DummyVariable16
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable17
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable18
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable19
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable20
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable21
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable22
    TYPE(INTERFACE_DEPENDENT_TYPE), POINTER :: DummyVariable23
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable24
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable25
    TYPE(INTERFACE_PENALTY_TYPE), POINTER :: DummyVariable26
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable27
    TYPE(REGION_TYPE), POINTER :: DummyVariable28

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)

    PRINT*, "Print TYPE(INTERFACE_CONDITION_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_CONDITION_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_CONDITION
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_MATRIX(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_MATRIX_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_MATRICES_TYPE), POINTER :: DummyVariable0

    NULLIFY(DummyVariable0)

    PRINT*, "Print TYPE(INTERFACE_MATRIX_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_MATRIX_TYPE(Variable, DummyVariable0, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_MATRIX
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_SET_TO_SOLVER_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_SET_TO_SOLVER_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable5
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable6
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable7

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)

    PRINT*, "Print TYPE(EQUATIONS_SET_TO_SOLVER_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_SET_TO_SOLVER_MAP_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_SET_TO_SOLVER_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MATRICES_DYNAMIC(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable2

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)

    PRINT*, "Print TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MATRICES_DYNAMIC_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MATRICES_DYNAMIC
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable1
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable2
    TYPE(MESHES_TYPE), POINTER :: DummyVariable3
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(MESH_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable11
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable12
    TYPE(FIELD_TYPE), POINTER :: DummyVariable13
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable14
    TYPE(NODES_TYPE), POINTER :: DummyVariable15
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable16
    TYPE(REGION_TYPE), POINTER :: DummyVariable17
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable18

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)

    PRINT*, "Print TYPE(INTERFACE_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_INTERFACE_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MATRICES(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MATRICES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_MATRICES_DYNAMIC_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable5
    TYPE(EQUATIONS_MATRICES_RHS_TYPE), POINTER :: DummyVariable6
    TYPE(EQUATIONS_MATRICES_LINEAR_TYPE), POINTER :: DummyVariable7
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable8
    TYPE(FIELD_TYPE), POINTER :: DummyVariable9
    TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER :: DummyVariable10
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable11
    TYPE(REGION_TYPE), POINTER :: DummyVariable12
    TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: DummyVariable13

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)

    PRINT*, "Print TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MATRICES_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MATRICES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_COL_TO_INTERFACE_EQUATIONS_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MAPPING_CREATE_VALUES_CACHE(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MAPPING_CREATE_VALUES_CACHE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MAPPING_CREATE_VALUES_CACHE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MeshDataPointsType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(MeshDataPointsType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESH_TYPE), POINTER :: DummyVariable0
    TYPE(MeshComponentTopologyType), POINTER :: DummyVariable1
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable2
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(MeshNodesType), POINTER :: DummyVariable4
    TYPE(MeshElementsType), POINTER :: DummyVariable5
    TYPE(MeshDataPointsType), POINTER :: DummyVariable6
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable7
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable8
    TYPE(MeshDofsType), POINTER :: DummyVariable9

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)

    PRINT*, "Print TYPE(MeshDataPointsType), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_MeshDataPointsType(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MeshDataPointsType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DATA_POINT(Variable, MaxDepth, MaxArrayLength)
    TYPE(DATA_POINT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DATA_POINT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_DATA_POINT_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DATA_POINT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_JACOBIAN_COL_TO_SOLVER_COLS_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(JACOBIAN_COL_TO_SOLVER_COLS_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(JACOBIAN_COL_TO_SOLVER_COLS_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_JACOBIAN_COL_TO_SOLVER_COLS_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_JACOBIAN_COL_TO_SOLVER_COLS_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_GENERATED_MESH_REGULAR(Variable, MaxDepth, MaxArrayLength)
    TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_TYPE), POINTER :: DummyVariable2
    TYPE(MESHES_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: DummyVariable4
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable5
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable6
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable7
    TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: DummyVariable8
    TYPE(REGION_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable10
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable11
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable12
    TYPE(FIELD_TYPE), POINTER :: DummyVariable13
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable14
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable15
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable16
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable17

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)

    PRINT*, "Print TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_GENERATED_MESH_REGULAR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_GENERATED_MESH_REGULAR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_MODEL(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_MODEL_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: DummyVariable0
    TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable2
    TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(CELLML_TYPE), POINTER :: DummyVariable5
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_TYPE), POINTER :: DummyVariable7
    TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: DummyVariable8

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)

    PRINT*, "Print TYPE(CELLML_MODEL_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_CELLML_MODEL_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_MODEL
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_EQUATIONS(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_EQUATIONS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable1
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable9
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable16
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable17
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable18
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable19
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable20
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable21
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable22
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable23
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable24
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable25
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable26
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable27
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable28
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable29
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable30
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable31
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable32
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable33

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)
    NULLIFY(DummyVariable32)
    NULLIFY(DummyVariable33)

    PRINT*, "Print TYPE(CELLML_EQUATIONS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_EQUATIONS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, &
      & DummyVariable29, DummyVariable30, DummyVariable31, DummyVariable32, DummyVariable33, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_EQUATIONS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_NODE_PARAM_TO_DOF_MAP_NODE(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_NODE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_NODE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_NODE_PARAM_TO_DOF_MAP_NODE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_NODE_PARAM_TO_DOF_MAP_NODE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DecompositionElementDataPointType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(DecompositionElementDataPointType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DecompositionElementDataPointType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DecompositionElementDataPointType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DecompositionElementDataPointType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MATRIX_TO_VAR_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MATRIX_TO_VAR_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_MATRIX_TO_VAR_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MATRIX_TO_VAR_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MATRIX_TO_VAR_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_MAPPING_CREATE_VALUES_CACHE(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(INTERFACE_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_MAPPING_CREATE_VALUES_CACHE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_MAPPING_CREATE_VALUES_CACHE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_NEWTON_TRUSTREGION_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable4
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable8
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable10
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable15
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: DummyVariable16

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)

    PRINT*, "Print TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_NEWTON_TRUSTREGION_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_NEWTON_TRUSTREGION_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_SET_SETUP(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_SET_SETUP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_SET_SETUP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_SET_SETUP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_SET_SETUP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_RHS(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_RHS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable0
    TYPE(INTERFACE_MATRICES_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable2

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)

    PRINT*, "Print TYPE(INTERFACE_RHS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_INTERFACE_RHS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_RHS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MESH(Variable, MaxDepth, MaxArrayLength)
    TYPE(MESH_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MeshComponentTopologyType), POINTER :: DummyVariable0
    TYPE(MESHES_TYPE), POINTER :: DummyVariable1
    TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: DummyVariable2
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable4
    TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable6
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable8
    TYPE(FIELD_TYPE), POINTER :: DummyVariable9
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable10
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable11
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable12
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable13
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable14
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable15
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable16
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable17
    TYPE(MESH_TYPE), POINTER :: DummyVariable18
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable19
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable20
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable21
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable22
    TYPE(NODES_TYPE), POINTER :: DummyVariable23
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable24
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable25
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable26
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable27
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable28
    TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: DummyVariable29
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable30
    TYPE(REGION_TYPE), POINTER :: DummyVariable31

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)

    PRINT*, "Print TYPE(MESH_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_MESH_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, DummyVariable29, &
      & DummyVariable30, DummyVariable31, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MESH
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_SET(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_SET_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(MESHES_TYPE), POINTER :: DummyVariable1
    TYPE(EquationsSetDerivedType), POINTER :: DummyVariable2
    TYPE(FIELD_TYPE), POINTER :: DummyVariable3
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable4
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable5
    TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: DummyVariable6
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable7
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable9
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable10
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable11
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable12
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable13
    TYPE(NODES_TYPE), POINTER :: DummyVariable14
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable15
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable16
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable17
    TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: DummyVariable18
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable19
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable20
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable21
    TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: DummyVariable22
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable23
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable24
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable25
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable26
    TYPE(REGION_TYPE), POINTER :: DummyVariable27
    TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: DummyVariable28

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)

    PRINT*, "Print TYPE(EQUATIONS_SET_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_EQUATIONS_SET_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_SET
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_PROBLEM_SETUP(Variable, MaxDepth, MaxArrayLength)
    TYPE(PROBLEM_SETUP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(PROBLEM_SETUP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_PROBLEM_SETUP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_PROBLEM_SETUP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth, &
      & ", maximum array length:",MaxArrayLength
    CALL Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BOUNDARY_CONDITIONS_SPARSITY_INDICES_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_IMPROVED_EULER_DAE_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable1
    TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable10
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable13

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)

    PRINT*, "Print TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_IMPROVED_EULER_DAE_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_IMPROVED_EULER_DAE_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MATRICES_SOURCE(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable2

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)

    PRINT*, "Print TYPE(EQUATIONS_MATRICES_SOURCE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MATRICES_SOURCE_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MATRICES_SOURCE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BASIS_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(BASIS_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BASIS_TYPE), POINTER :: DummyVariable0
    TYPE(BASIS_PTR_TYPE), POINTER :: DummyVariable1

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)

    PRINT*, "Print TYPE(BASIS_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_BASIS_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BASIS_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MESH_EMBEDDING(Variable, MaxDepth, MaxArrayLength)
    TYPE(MESH_EMBEDDING_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(MESH_EMBEDDING_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_MESH_EMBEDDING_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MESH_EMBEDDING
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_MODELS_FIELD(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: DummyVariable1
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable2
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable3
    TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: DummyVariable4
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable5
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable6
    TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: DummyVariable7
    TYPE(FIELD_TYPE), POINTER :: DummyVariable8
    TYPE(CELLML_TYPE), POINTER :: DummyVariable9
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: DummyVariable10
    TYPE(REGION_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: DummyVariable12

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)

    PRINT*, "Print TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_MODELS_FIELD_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_MODELS_FIELD
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MeshDofsType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(MeshDofsType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESH_TYPE), POINTER :: DummyVariable0
    TYPE(MeshComponentTopologyType), POINTER :: DummyVariable1
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable2
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(MeshNodesType), POINTER :: DummyVariable4
    TYPE(MeshElementsType), POINTER :: DummyVariable5
    TYPE(MeshDataPointsType), POINTER :: DummyVariable6
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable7
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable8
    TYPE(MeshDofsType), POINTER :: DummyVariable9

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)

    PRINT*, "Print TYPE(MeshDofsType), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_MeshDofsType(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MeshDofsType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_MODEL_MAPS_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_MODEL_MAPS_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(CELLML_MODEL_MAPS_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_MODEL_MAPS_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_MODEL_MAPS_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_MAPPING_CREATE_VALUES_CACHE(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(SOLVER_MAPPING_CREATE_VALUES_CACHE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_MAPPING_CREATE_VALUES_CACHE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_MAPPING_CREATE_VALUES_CACHE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BoundaryConditionsDofConstraintType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(BoundaryConditionsDofConstraintType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(BoundaryConditionsDofConstraintType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_BoundaryConditionsDofConstraintType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BoundaryConditionsDofConstraintType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_COL_TO_EQUATIONS_MAPS(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_COL_TO_EQUATIONS_MAPS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: DummyVariable0
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable5
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable6
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable7

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)

    PRINT*, "Print TYPE(SOLVER_COL_TO_EQUATIONS_MAPS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_COL_TO_EQUATIONS_MAPS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_COL_TO_EQUATIONS_MAPS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTEGER_CINT_ALLOC(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTEGER_CINT_ALLOC_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(INTEGER_CINT_ALLOC_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTEGER_CINT_ALLOC_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTEGER_CINT_ALLOC
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_IM(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_IM_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_TO_SOLVER_MATRIX_MAPS_IM
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_JACOBIAN_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_JACOBIAN_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_JACOBIAN_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_JACOBIAN_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_JACOBIAN_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_INTERPOLATED_POINT_METRICS(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_INTERPOLATED_POINT_METRICS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_INTERPOLATED_POINT_METRICS_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_INTERPOLATED_POINT_METRICS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_GENERATED_MESH_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(GENERATED_MESH_CYLINDER_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_ELLIPSOID_TYPE), POINTER :: DummyVariable4
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable5
    TYPE(FIELD_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable10
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable11
    TYPE(MESH_TYPE), POINTER :: DummyVariable12
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable13
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable14
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable15
    TYPE(NODES_TYPE), POINTER :: DummyVariable16
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable17
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable18
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable19
    TYPE(GENERATED_MESH_REGULAR_TYPE), POINTER :: DummyVariable20
    TYPE(REGION_TYPE), POINTER :: DummyVariable21

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)

    PRINT*, "Print TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_GENERATED_MESH_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_GENERATED_MESH_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_ROW_TO_SOLVER_ROWS_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_ROW_TO_SOLVER_ROWS_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(INTERFACE_ROW_TO_SOLVER_ROWS_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_ROW_TO_SOLVER_ROWS_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_ROW_TO_SOLVER_ROWS_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_NODES(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_NODES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DOMAIN_TOPOLOGY_TYPE), POINTER :: DummyVariable0
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable1
    TYPE(DOMAIN_MAPPINGS_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable4

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)

    PRINT*, "Print TYPE(DOMAIN_NODES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DOMAIN_NODES_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_NODES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_VAR_TO_EQUATIONS_MATRICES_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(VAR_TO_EQUATIONS_MATRICES_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(VAR_TO_EQUATIONS_MATRICES_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_VAR_TO_EQUATIONS_MATRICES_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_VAR_TO_EQUATIONS_MATRICES_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MAPPING_LINEAR(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: DummyVariable1

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)

    PRINT*, "Print TYPE(EQUATIONS_MAPPING_LINEAR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MAPPING_LINEAR_TYPE(Variable, DummyVariable0, DummyVariable1, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MAPPING_LINEAR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CONTROL_LOOP_FIXED(Variable, MaxDepth, MaxArrayLength)
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable0
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable5
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable6
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable10
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable11

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)

    PRINT*, "Print TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CONTROL_LOOP_FIXED_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CONTROL_LOOP_FIXED
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DECOMPOSITION_LINES(Variable, MaxDepth, MaxArrayLength)
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_TYPE), POINTER :: DummyVariable1
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable3
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable4
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable5
    TYPE(DecompositionDataPointsType), POINTER :: DummyVariable6
    TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: DummyVariable7
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: DummyVariable8
    TYPE(FIELD_TYPE), POINTER :: DummyVariable9
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable10
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable11

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)

    PRINT*, "Print TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DECOMPOSITION_LINES_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DECOMPOSITION_LINES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable1
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable6
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable9
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable16
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable18
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable19
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable20
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable21
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable22
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable23
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable24
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable25
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable26
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable27
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable28
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable29
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable30
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable31
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable32
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable33
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable34
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable35

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)
    NULLIFY(DummyVariable32)
    NULLIFY(DummyVariable33)
    NULLIFY(DummyVariable34)
    NULLIFY(DummyVariable35)

    PRINT*, "Print TYPE(SOLVER_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_SOLVER_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, DummyVariable29, &
      & DummyVariable30, DummyVariable31, DummyVariable32, DummyVariable33, DummyVariable34, DummyVariable35, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BASIS(Variable, MaxDepth, MaxArrayLength)
    TYPE(BASIS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BASIS_TYPE), POINTER :: DummyVariable0
    TYPE(BASIS_PTR_TYPE), POINTER :: DummyVariable1

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)

    PRINT*, "Print TYPE(BASIS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_BASIS_TYPE(Variable, DummyVariable0, DummyVariable1, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BASIS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_SETS(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_SETS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable1
    TYPE(MESHES_TYPE), POINTER :: DummyVariable2
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable3
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable4
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable5
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable6
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable8
    TYPE(FIELD_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable12
    TYPE(NODES_TYPE), POINTER :: DummyVariable13
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable14
    TYPE(REGION_TYPE), POINTER :: DummyVariable15
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable16

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)

    PRINT*, "Print TYPE(EQUATIONS_SETS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_EQUATIONS_SETS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_SETS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MESH_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(MESH_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MeshComponentTopologyType), POINTER :: DummyVariable0
    TYPE(MESHES_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable4
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable5
    TYPE(FIELD_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable12
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable13
    TYPE(MESH_TYPE), POINTER :: DummyVariable14
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable15
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable16
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable17
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable18
    TYPE(NODES_TYPE), POINTER :: DummyVariable19
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable20
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable21
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable22
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable23
    TYPE(REGION_TYPE), POINTER :: DummyVariable24

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)

    PRINT*, "Print TYPE(MESH_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_MESH_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MESH_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DISTRIBUTED_MATRIX(Variable, MaxDepth, MaxArrayLength)
    TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DISTRIBUTED_MATRIX_CMISS_TYPE), POINTER :: DummyVariable0
    TYPE(DISTRIBUTED_MATRIX_PETSC_TYPE), POINTER :: DummyVariable1

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)

    PRINT*, "Print TYPE(DISTRIBUTED_MATRIX_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DISTRIBUTED_MATRIX_TYPE(Variable, DummyVariable0, DummyVariable1, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DISTRIBUTED_MATRIX
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DOMAIN_GLOBAL_MAPPING(Variable, MaxDepth, MaxArrayLength)
    TYPE(DOMAIN_GLOBAL_MAPPING_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DOMAIN_GLOBAL_MAPPING_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DOMAIN_GLOBAL_MAPPING_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DOMAIN_GLOBAL_MAPPING
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_ROW_TO_SOLVER_ROWS_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_ROW_TO_SOLVER_ROWS_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_ROW_TO_SOLVER_ROWS_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_ROW_TO_SOLVER_ROWS_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_ROW_TO_SOLVER_ROWS_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_TO_SOLVER_MAPS_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_TO_SOLVER_MAPS_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_TO_SOLVER_MAPS_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_INTERPOLATED_POINT(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_INTERPOLATED_POINT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_INTERPOLATED_POINT_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_INTERPOLATED_POINT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_MODEL_MAP_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_MODEL_MAP_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(CELLML_MODEL_MAP_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_MODEL_MAP_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_MODEL_MAP_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BoundaryConditionsDofConstraintsType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(BoundaryConditionsDofConstraintsType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(BoundaryConditionsDofConstraintsType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_BoundaryConditionsDofConstraintsType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BoundaryConditionsDofConstraintsType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_PARAMETER_SET(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_PARAMETER_SET_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_PARAMETER_SET_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_PARAMETER_SET_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_PARAMETER_SET
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MATRIX(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MATRIX_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_MATRIX_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MATRIX_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MATRIX
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_PROBLEM_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(PROBLEM_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable0
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable2
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable3
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable5
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable9
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable10

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)

    PRINT*, "Print TYPE(PROBLEM_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_PROBLEM_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_PROBLEM_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_ELEMENT_VECTOR(Variable, MaxDepth, MaxArrayLength)
    TYPE(ELEMENT_VECTOR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(ELEMENT_VECTOR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_ELEMENT_VECTOR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_ELEMENT_VECTOR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MeshComponentTopologyPtrType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(MeshComponentTopologyPtrType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_TYPE), POINTER :: DummyVariable1
    TYPE(MeshComponentTopologyType), POINTER :: DummyVariable2
    TYPE(MESHES_TYPE), POINTER :: DummyVariable3
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable6
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable7
    TYPE(REGION_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable9
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable10
    TYPE(FIELD_TYPE), POINTER :: DummyVariable11
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable12
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable13
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable14

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)

    PRINT*, "Print TYPE(MeshComponentTopologyPtrType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_MeshComponentTopologyPtrType(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MeshComponentTopologyPtrType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_REGION(Variable, MaxDepth, MaxArrayLength)
    TYPE(REGION_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable4
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable5
    TYPE(FIELD_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable8
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable10
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable12
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable13
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable14
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable15
    TYPE(CELLML_TYPE), POINTER :: DummyVariable16
    TYPE(MESH_TYPE), POINTER :: DummyVariable17
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable18
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable19
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable20
    TYPE(NODES_TYPE), POINTER :: DummyVariable21
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable22
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable23
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable24
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable25
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable26
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable27
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable28
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable29
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable30
    TYPE(REGION_TYPE), POINTER :: DummyVariable31

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)

    PRINT*, "Print TYPE(REGION_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_REGION_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, DummyVariable29, &
      & DummyVariable30, DummyVariable31, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_REGION
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_LINEAR_DIRECT_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable5
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable7
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable9
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable14

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)

    PRINT*, "Print TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_LINEAR_DIRECT_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_LINEAR_DIRECT_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_JACOBIAN_TO_SOLVER_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(JACOBIAN_TO_SOLVER_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable2

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)

    PRINT*, "Print TYPE(JACOBIAN_TO_SOLVER_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_JACOBIAN_TO_SOLVER_MAP_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_JACOBIAN_TO_SOLVER_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CONTROL_LOOP_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(CONTROL_LOOP_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable0
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable1
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable4
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable5
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable6
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable10
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable11

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)

    PRINT*, "Print TYPE(CONTROL_LOOP_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CONTROL_LOOP_PTR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CONTROL_LOOP_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_COORDINATE_SYSTEM_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(COORDINATE_SYSTEM_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(COORDINATE_SYSTEM_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_COORDINATE_SYSTEM_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_COORDINATE_SYSTEM_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DATA_PROJECTION_RESULT(Variable, MaxDepth, MaxArrayLength)
    TYPE(DATA_PROJECTION_RESULT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DATA_PROJECTION_RESULT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DATA_PROJECTION_RESULT_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DATA_PROJECTION_RESULT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_DOF_TO_PARAM_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_DOF_TO_PARAM_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_DOF_TO_PARAM_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_DOF_TO_PARAM_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_DOF_TO_PARAM_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_VARIABLE_COMPONENT(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_VARIABLE_COMPONENT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(FIELD_GEOMETRIC_PARAMETERS_TYPE), POINTER :: DummyVariable1
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_VARIABLE_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_TYPE), POINTER :: DummyVariable7

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)

    PRINT*, "Print TYPE(FIELD_VARIABLE_COMPONENT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_VARIABLE_COMPONENT_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_VARIABLE_COMPONENT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_MAPPING(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_MAPPING_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_CONDITION_TYPE), POINTER :: DummyVariable0
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable2
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable4
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable5
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable6
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable7
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_EQUATIONS_TYPE), POINTER :: DummyVariable9
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable11
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: DummyVariable12
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable14
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable16
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable19
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable20

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)

    PRINT*, "Print TYPE(SOLVER_MAPPING_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_SOLVER_MAPPING_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_MAPPING
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MATRICES_NONLINEAR(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_MATRICES_TYPE), POINTER :: DummyVariable0
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable2

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)

    PRINT*, "Print TYPE(EQUATIONS_MATRICES_NONLINEAR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MATRICES_NONLINEAR_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MATRICES_NONLINEAR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_EVALUATOR_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable1
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable9
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable16
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable17
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable18
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable19
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable20
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable21
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable22
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable23
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable24
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable25
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable26
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable27
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable28
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable29
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable30
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable31
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable32
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable33

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)
    NULLIFY(DummyVariable32)
    NULLIFY(DummyVariable33)

    PRINT*, "Print TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_EVALUATOR_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, &
      & DummyVariable29, DummyVariable30, DummyVariable31, DummyVariable32, DummyVariable33, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_EVALUATOR_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_CELLML_INTERMEDIATE_FIELD(Variable, MaxDepth, MaxArrayLength)
    TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(CELLML_PARAMETERS_FIELD_TYPE), POINTER :: DummyVariable1
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable2
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable3
    TYPE(CELLML_FIELD_MAPS_TYPE), POINTER :: DummyVariable4
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable5
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable6
    TYPE(CELLML_STATE_FIELD_TYPE), POINTER :: DummyVariable7
    TYPE(FIELD_TYPE), POINTER :: DummyVariable8
    TYPE(CELLML_TYPE), POINTER :: DummyVariable9
    TYPE(CELLML_MODELS_FIELD_TYPE), POINTER :: DummyVariable10
    TYPE(REGION_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: DummyVariable12

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)

    PRINT*, "Print TYPE(CELLML_INTERMEDIATE_FIELD_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_CELLML_INTERMEDIATE_FIELD_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_CELLML_INTERMEDIATE_FIELD
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_LINEAR_ITERATIVE_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable5
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable7
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable9
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable14

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)

    PRINT*, "Print TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_LINEAR_ITERATIVE_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_LINEAR_ITERATIVE_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_TO_SOLVER_MATRIX_MAPS_SM
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_NODE_PARAM_TO_DOF_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_NODE_PARAM_TO_DOF_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_NODE_PARAM_TO_DOF_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_NODE_PARAM_TO_DOF_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_NONLINEAR_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable1
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable10
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable14
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable17
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable19
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable20
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable21
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: DummyVariable22
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable23
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: DummyVariable24
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable25
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable26
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable27
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable28
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable29
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable30
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable31
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: DummyVariable32
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable33
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable34
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable35
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable36
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable37

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)
    NULLIFY(DummyVariable32)
    NULLIFY(DummyVariable33)
    NULLIFY(DummyVariable34)
    NULLIFY(DummyVariable35)
    NULLIFY(DummyVariable36)
    NULLIFY(DummyVariable37)

    PRINT*, "Print TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_NONLINEAR_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, &
      & DummyVariable29, DummyVariable30, DummyVariable31, DummyVariable32, DummyVariable33, DummyVariable34, &
      & DummyVariable35, DummyVariable36, DummyVariable37, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_NONLINEAR_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_COORDINATE_SYSTEM(Variable, MaxDepth, MaxArrayLength)
    TYPE(COORDINATE_SYSTEM_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(COORDINATE_SYSTEM_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_COORDINATE_SYSTEM_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_COORDINATE_SYSTEM
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EIGENPROBLEM_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable1
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable9
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable16
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable18
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable19
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable20
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable21
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable22
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable23
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable24
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable25
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable26
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable27
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable28
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable29
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable30
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable31
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable32
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable33

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)
    NULLIFY(DummyVariable32)
    NULLIFY(DummyVariable33)

    PRINT*, "Print TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EIGENPROBLEM_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, &
      & DummyVariable29, DummyVariable30, DummyVariable31, DummyVariable32, DummyVariable33, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EIGENPROBLEM_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DECOMPOSITION_FACE(Variable, MaxDepth, MaxArrayLength)
    TYPE(DECOMPOSITION_FACE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(DECOMPOSITION_FACE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DECOMPOSITION_FACE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DECOMPOSITION_FACE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_LINEAR_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(LINEAR_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable1
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable9
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable13
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable16
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable18
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable19
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable20
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable21
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable22
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable23
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable24
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable25
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable26
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable27
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable28
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable29
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable30
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable31
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable32
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable33

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)
    NULLIFY(DummyVariable32)
    NULLIFY(DummyVariable33)

    PRINT*, "Print TYPE(LINEAR_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_LINEAR_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, DummyVariable29, &
      & DummyVariable30, DummyVariable31, DummyVariable32, DummyVariable33, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_LINEAR_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DECOMPOSITIONS(Variable, MaxDepth, MaxArrayLength)
    TYPE(DECOMPOSITIONS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MeshComponentTopologyType), POINTER :: DummyVariable0
    TYPE(MESHES_TYPE), POINTER :: DummyVariable1
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable3
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable5
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable6
    TYPE(FIELD_TYPE), POINTER :: DummyVariable7
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable8
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable9
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable10
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable11
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable12
    TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: DummyVariable13
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: DummyVariable14
    TYPE(MESH_TYPE), POINTER :: DummyVariable15
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable16
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable17
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable18
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable19
    TYPE(NODES_TYPE), POINTER :: DummyVariable20
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable21
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable22
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable23
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable24
    TYPE(DecompositionDataPointsType), POINTER :: DummyVariable25
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: DummyVariable26
    TYPE(REGION_TYPE), POINTER :: DummyVariable27

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)

    PRINT*, "Print TYPE(DECOMPOSITIONS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_DECOMPOSITIONS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, &
      & DummyVariable23, DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DECOMPOSITIONS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_INTERPOLATION(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable1
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable2
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable3
    TYPE(FIELD_TYPE), POINTER :: DummyVariable4
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable5
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable6
    TYPE(REGION_TYPE), POINTER :: DummyVariable7

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)

    PRINT*, "Print TYPE(EQUATIONS_INTERPOLATION_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_INTERPOLATION_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_INTERPOLATION
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_InterfacePointConnectivityType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(InterfacePointConnectivityType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(InterfacePointConnectivityType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_InterfacePointConnectivityType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_InterfacePointConnectivityType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_JACOBIAN(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_JACOBIAN_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EQUATIONS_JACOBIAN_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_JACOBIAN_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_JACOBIAN
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_MAPPING_DYNAMIC(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_MAPPING_TYPE), POINTER :: DummyVariable1
    TYPE(REGION_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_TYPE), POINTER :: DummyVariable3

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)

    PRINT*, "Print TYPE(EQUATIONS_MAPPING_DYNAMIC_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_MAPPING_DYNAMIC_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, 1, &
      & MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_MAPPING_DYNAMIC
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_COL_TO_DYNAMIC_EQUATIONS_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EQUATIONS_SET_DEPENDENT(Variable, MaxDepth, MaxArrayLength)
    TYPE(EQUATIONS_SET_DEPENDENT_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable0
    TYPE(EQUATIONS_TYPE), POINTER :: DummyVariable1
    TYPE(EQUATIONS_SET_TYPE), POINTER :: DummyVariable2
    TYPE(EquationsSetDerivedType), POINTER :: DummyVariable3
    TYPE(EQUATIONS_SET_ANALYTIC_TYPE), POINTER :: DummyVariable4
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable5
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable6
    TYPE(EQUATIONS_SET_SOURCE_TYPE), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SET_MATERIALS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable11
    TYPE(FIELD_TYPE), POINTER :: DummyVariable12
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable13
    TYPE(REGION_TYPE), POINTER :: DummyVariable14
    TYPE(EQUATIONS_SET_INDEPENDENT_TYPE), POINTER :: DummyVariable15

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)

    PRINT*, "Print TYPE(EQUATIONS_SET_DEPENDENT_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EQUATIONS_SET_DEPENDENT_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EQUATIONS_SET_DEPENDENT
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EMBEDDING_XI(Variable, MaxDepth, MaxArrayLength)
    TYPE(EMBEDDING_XI_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(EMBEDDING_XI_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_EMBEDDING_XI_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_EMBEDDING_XI
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_FIELD_ELEMENT_PARAM_TO_DOF_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(FIELD_ELEMENT_PARAM_TO_DOF_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(FIELD_ELEMENT_PARAM_TO_DOF_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_FIELD_ELEMENT_PARAM_TO_DOF_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_FIELD_ELEMENT_PARAM_TO_DOF_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_DOF_TO_VARIABLE_MAP(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_DOF_TO_VARIABLE_MAP_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(SOLVER_DOF_TO_VARIABLE_MAP_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_DOF_TO_VARIABLE_MAP_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_DOF_TO_VARIABLE_MAP
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_MATRICES(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_MATRICES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable3
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable4
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable6
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable7
    TYPE(SOLVER_MATRIX_TYPE), POINTER :: DummyVariable8
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable10
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable12
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable15
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable16

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)

    PRINT*, "Print TYPE(SOLVER_MATRICES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_SOLVER_MATRICES_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_MATRICES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_TO_SOLVER_MAPS_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_TO_SOLVER_MAPS_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(INTERFACE_TO_SOLVER_MAPS_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_TO_SOLVER_MAPS_PTR_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_TO_SOLVER_MAPS_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER_MAPPING_VARIABLE(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_MAPPING_VARIABLE_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(SOLVER_MAPPING_VARIABLE_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_SOLVER_MAPPING_VARIABLE_TYPE(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER_MAPPING_VARIABLE
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DECOMPOSITION_ELEMENTS(Variable, MaxDepth, MaxArrayLength)
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_TYPE), POINTER :: DummyVariable1
    TYPE(DECOMPOSITION_PTR_TYPE), POINTER :: DummyVariable2
    TYPE(DOMAIN_TYPE), POINTER :: DummyVariable3
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable4
    TYPE(DECOMPOSITION_TOPOLOGY_TYPE), POINTER :: DummyVariable5
    TYPE(DecompositionDataPointsType), POINTER :: DummyVariable6
    TYPE(DECOMPOSITION_FACES_TYPE), POINTER :: DummyVariable7
    TYPE(DECOMPOSITION_LINES_TYPE), POINTER :: DummyVariable8
    TYPE(FIELD_TYPE), POINTER :: DummyVariable9
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable10
    TYPE(DOMAIN_PTR_TYPE), POINTER :: DummyVariable11

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)

    PRINT*, "Print TYPE(DECOMPOSITION_ELEMENTS_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_DECOMPOSITION_ELEMENTS_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DECOMPOSITION_ELEMENTS
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_INTERFACE_MATRIX_PTR(Variable, MaxDepth, MaxArrayLength)
    TYPE(INTERFACE_MATRIX_PTR_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(INTERFACE_MATRICES_TYPE), POINTER :: DummyVariable0

    NULLIFY(DummyVariable0)

    PRINT*, "Print TYPE(INTERFACE_MATRIX_PTR_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_INTERFACE_MATRIX_PTR_TYPE(Variable, DummyVariable0, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_INTERFACE_MATRIX_PTR
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_InterfaceCoupledElementsType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(InterfaceCoupledElementsType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(InterfaceCoupledElementsType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_InterfaceCoupledElementsType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_InterfaceCoupledElementsType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_NodalMatrixType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(NodalMatrixType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(NodalMatrixType), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_NodalMatrixType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_NodalMatrixType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_DAE_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable1
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable8
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable9
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable10
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable14
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable18
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable19
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable20
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable21
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable22
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable23
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable24
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable25
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable26
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable27
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable28
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable29
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable30
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable31
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable32
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable33
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable34
    TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable35
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable36

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)
    NULLIFY(DummyVariable32)
    NULLIFY(DummyVariable33)
    NULLIFY(DummyVariable34)
    NULLIFY(DummyVariable35)
    NULLIFY(DummyVariable36)

    PRINT*, "Print TYPE(DAE_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_DAE_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, DummyVariable29, &
      & DummyVariable30, DummyVariable31, DummyVariable32, DummyVariable33, DummyVariable34, DummyVariable35, &
      & DummyVariable36, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_DAE_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BoundaryConditionsDofConstraintPtrType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(BoundaryConditionsDofConstraintPtrType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(BoundaryConditionsDofConstraintPtrType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_BoundaryConditionsDofConstraintPtrType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BoundaryConditionsDofConstraintPtrType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(CONTROL_LOOP_WHILE_TYPE), POINTER :: DummyVariable1
    TYPE(FIELD_TYPE), POINTER :: DummyVariable2
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(LINEAR_DIRECT_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(LINEAR_ITERATIVE_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(QUASI_NEWTON_SOLVER_TYPE), POINTER :: DummyVariable7
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(NEWTON_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(CONTROL_LOOP_FIXED_TYPE), POINTER :: DummyVariable10
    TYPE(CONTROL_LOOP_TIME_TYPE), POINTER :: DummyVariable11
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable12
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable14
    TYPE(CONTROL_LOOP_SIMPLE_TYPE), POINTER :: DummyVariable15
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable16
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable18
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable19
    TYPE(BOUNDARY_CONDITIONS_TYPE), POINTER :: DummyVariable20
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable21
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable22
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable23
    TYPE(PROBLEMS_TYPE), POINTER :: DummyVariable24
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable25
    TYPE(NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: DummyVariable26
    TYPE(CONTROL_LOOP_LOAD_INCREMENT_TYPE), POINTER :: DummyVariable27
    TYPE(SOLVER_MATRICES_TYPE), POINTER :: DummyVariable28
    TYPE(HISTORY_TYPE), POINTER :: DummyVariable29
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable30
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable31
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable32
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable33
    TYPE(QUASI_NEWTON_LINESEARCH_SOLVER_TYPE), POINTER :: DummyVariable34
    TYPE(QUASI_NEWTON_TRUSTREGION_SOLVER_TYPE), POINTER :: DummyVariable35
    TYPE(SOLVER_MAPPING_TYPE), POINTER :: DummyVariable36
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable37
    TYPE(PROBLEM_PTR_TYPE), POINTER :: DummyVariable38
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable39
    TYPE(PROBLEM_TYPE), POINTER :: DummyVariable40

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)
    NULLIFY(DummyVariable28)
    NULLIFY(DummyVariable29)
    NULLIFY(DummyVariable30)
    NULLIFY(DummyVariable31)
    NULLIFY(DummyVariable32)
    NULLIFY(DummyVariable33)
    NULLIFY(DummyVariable34)
    NULLIFY(DummyVariable35)
    NULLIFY(DummyVariable36)
    NULLIFY(DummyVariable37)
    NULLIFY(DummyVariable38)
    NULLIFY(DummyVariable39)
    NULLIFY(DummyVariable40)

    PRINT*, "Print TYPE(SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, DummyVariable28, DummyVariable29, &
      & DummyVariable30, DummyVariable31, DummyVariable32, DummyVariable33, DummyVariable34, DummyVariable35, &
      & DummyVariable36, DummyVariable37, DummyVariable38, DummyVariable39, DummyVariable40, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MeshElementsType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(MeshElementsType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESH_TYPE), POINTER :: DummyVariable0
    TYPE(MeshComponentTopologyType), POINTER :: DummyVariable1
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable2
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(MeshNodesType), POINTER :: DummyVariable4
    TYPE(MeshElementsType), POINTER :: DummyVariable5
    TYPE(MeshDataPointsType), POINTER :: DummyVariable6
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable7
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable8
    TYPE(MeshDofsType), POINTER :: DummyVariable9

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)

    PRINT*, "Print TYPE(MeshElementsType), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:", &
      & MaxArrayLength
    CALL Print_MeshElementsType(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MeshElementsType_
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_MESHES(Variable, MaxDepth, MaxArrayLength)
    TYPE(MESHES_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(MESHES_TYPE), POINTER :: DummyVariable0
    TYPE(MESH_PTR_TYPE), POINTER :: DummyVariable1
    TYPE(INTERFACE_CONDITIONS_TYPE), POINTER :: DummyVariable2
    TYPE(FIELD_PTR_TYPE), POINTER :: DummyVariable3
    TYPE(GENERATED_MESH_TYPE), POINTER :: DummyVariable4
    TYPE(FIELD_TYPE), POINTER :: DummyVariable5
    TYPE(REGION_PTR_TYPE), POINTER :: DummyVariable6
    TYPE(InterfacePointsConnectivityType), POINTER :: DummyVariable7
    TYPE(EQUATIONS_SETS_TYPE), POINTER :: DummyVariable8
    TYPE(INTERFACE_TYPE), POINTER :: DummyVariable9
    TYPE(INTERFACE_PTR_TYPE), POINTER :: DummyVariable10
    TYPE(INTERFACE_MESH_CONNECTIVITY_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_ENVIRONMENTS_TYPE), POINTER :: DummyVariable12
    TYPE(CELLML_TYPE), POINTER :: DummyVariable13
    TYPE(INTERFACE_CONDITION_PTR_TYPE), POINTER :: DummyVariable14
    TYPE(MESH_TYPE), POINTER :: DummyVariable15
    TYPE(MeshComponentTopologyPtrType), POINTER :: DummyVariable16
    TYPE(FIELDS_TYPE), POINTER :: DummyVariable17
    TYPE(GENERATED_MESHES_TYPE), POINTER :: DummyVariable18
    TYPE(DECOMPOSITIONS_TYPE), POINTER :: DummyVariable19
    TYPE(NODES_TYPE), POINTER :: DummyVariable20
    TYPE(INTERFACES_TYPE), POINTER :: DummyVariable21
    TYPE(DATA_POINTS_TYPE), POINTER :: DummyVariable22
    TYPE(GENERATED_MESH_PTR_TYPE), POINTER :: DummyVariable23
    TYPE(DATA_PROJECTION_TYPE), POINTER :: DummyVariable24
    TYPE(DECOMPOSITION_TYPE), POINTER :: DummyVariable25
    TYPE(EQUATIONS_SET_PTR_TYPE), POINTER :: DummyVariable26
    TYPE(REGION_TYPE), POINTER :: DummyVariable27

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)
    NULLIFY(DummyVariable23)
    NULLIFY(DummyVariable24)
    NULLIFY(DummyVariable25)
    NULLIFY(DummyVariable26)
    NULLIFY(DummyVariable27)

    PRINT*, "Print TYPE(MESHES_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,", maximum array length:",MaxArrayLength
    CALL Print_MESHES_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, DummyVariable4, &
      & DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, DummyVariable11, &
      & DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, DummyVariable17, &
      & DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, DummyVariable23, &
      & DummyVariable24, DummyVariable25, DummyVariable26, DummyVariable27, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_MESHES
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_EULER_DAE_SOLVER(Variable, MaxDepth, MaxArrayLength)
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  
    TYPE(BDF_DAE_SOLVER_TYPE), POINTER :: DummyVariable0
    TYPE(FORWARD_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable1
    TYPE(RUSH_LARSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable2
    TYPE(NONLINEAR_SOLVER_TYPE), POINTER :: DummyVariable3
    TYPE(EXTERNAL_DAE_SOLVER_TYPE), POINTER :: DummyVariable4
    TYPE(OPTIMISER_SOLVER_TYPE), POINTER :: DummyVariable5
    TYPE(BACKWARD_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable6
    TYPE(CONTROL_LOOP_TYPE), POINTER :: DummyVariable7
    TYPE(DYNAMIC_SOLVER_TYPE), POINTER :: DummyVariable8
    TYPE(CELLML_EVALUATOR_SOLVER_TYPE), POINTER :: DummyVariable9
    TYPE(GeometricTransformationSolverType), POINTER :: DummyVariable10
    TYPE(EIGENPROBLEM_SOLVER_TYPE), POINTER :: DummyVariable11
    TYPE(CELLML_EQUATIONS_TYPE), POINTER :: DummyVariable12
    TYPE(CRANK_NICOLSON_DAE_SOLVER_TYPE), POINTER :: DummyVariable13
    TYPE(SOLVER_EQUATIONS_TYPE), POINTER :: DummyVariable14
    TYPE(DAE_SOLVER_TYPE), POINTER :: DummyVariable15
    TYPE(SOLVERS_TYPE), POINTER :: DummyVariable16
    TYPE(IMPROVED_EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable17
    TYPE(SOLVER_TYPE), POINTER :: DummyVariable18
    TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: DummyVariable19
    TYPE(LINEAR_SOLVER_TYPE), POINTER :: DummyVariable20
    TYPE(ADAMS_MOULTON_DAE_SOLVER_TYPE), POINTER :: DummyVariable21
    TYPE(RUNGE_KUTTA_DAE_SOLVER_TYPE), POINTER :: DummyVariable22

    NULLIFY(DummyVariable0)
    NULLIFY(DummyVariable1)
    NULLIFY(DummyVariable2)
    NULLIFY(DummyVariable3)
    NULLIFY(DummyVariable4)
    NULLIFY(DummyVariable5)
    NULLIFY(DummyVariable6)
    NULLIFY(DummyVariable7)
    NULLIFY(DummyVariable8)
    NULLIFY(DummyVariable9)
    NULLIFY(DummyVariable10)
    NULLIFY(DummyVariable11)
    NULLIFY(DummyVariable12)
    NULLIFY(DummyVariable13)
    NULLIFY(DummyVariable14)
    NULLIFY(DummyVariable15)
    NULLIFY(DummyVariable16)
    NULLIFY(DummyVariable17)
    NULLIFY(DummyVariable18)
    NULLIFY(DummyVariable19)
    NULLIFY(DummyVariable20)
    NULLIFY(DummyVariable21)
    NULLIFY(DummyVariable22)

    PRINT*, "Print TYPE(EULER_DAE_SOLVER_TYPE), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_EULER_DAE_SOLVER_TYPE(Variable, DummyVariable0, DummyVariable1, DummyVariable2, DummyVariable3, &
      & DummyVariable4, DummyVariable5, DummyVariable6, DummyVariable7, DummyVariable8, DummyVariable9, DummyVariable10, &
      & DummyVariable11, DummyVariable12, DummyVariable13, DummyVariable14, DummyVariable15, DummyVariable16, &
      & DummyVariable17, DummyVariable18, DummyVariable19, DummyVariable20, DummyVariable21, DummyVariable22, 1, MaxDepth, &
      & MaxArrayLength)
    
  END SUBROUTINE Print_EULER_DAE_SOLVER
  
  !
  !================================================================================================================================
  !
  SUBROUTINE Print_BoundaryConditionsNeumannType_(Variable, MaxDepth, MaxArrayLength)
    TYPE(BoundaryConditionsNeumannType), POINTER, INTENT(IN) :: Variable   !< the variable to be printed
    INTEGER(INTG), INTENT(IN) :: MaxDepth           !< the maximum recursion depth down to which data is printed
    INTEGER(INTG), INTENT(IN) :: MaxArrayLength   !< the maximum array length that is printed  


    PRINT*, "Print TYPE(BoundaryConditionsNeumannType), POINTER :: Variable with maximum depth ",MaxDepth,"," // &
      & "maximum array length:",MaxArrayLength
    CALL Print_BoundaryConditionsNeumannType(Variable, 1, MaxDepth, MaxArrayLength)
    
  END SUBROUTINE Print_BoundaryConditionsNeumannType_
  
END MODULE PRINT_TYPES_ROUTINES
